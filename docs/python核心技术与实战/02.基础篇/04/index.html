<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>04 | 字典、集合，你真的了解吗？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/python核心技术与实战/02.基础篇/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a aria-current="page" class="active" href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a aria-current="page" class="active" href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/python核心技术与实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-backend/python核心技术与实战/01.开篇词/01"><span>开篇词 | 从工程的角度深入理解Python</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/python核心技术与实战/02.基础篇">02.基础篇</a><ul><li><a href="/blog-backend/python核心技术与实战/02.基础篇/01"><span>01 | 如何逐步突破，成为Python高手？</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/02"><span>02 | Jupyter Notebook为什么是现代Python的必学技术？</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/03"><span>03 | 列表和元组，到底用哪一个？</span></a></li><li><a aria-current="page" class="active" href="/blog-backend/python核心技术与实战/02.基础篇/04"><span>04 | 字典、集合，你真的了解吗？</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/05"><span>05 | 深入浅出字符串</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/06"><span>06 | Python “黑箱”：输入与输出</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/07"><span>07 | 修炼基本功：条件与循环</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/08"><span>08 | 异常处理：如何提高程序的稳定性？</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/09"><span>09 | 不可或缺的自定义函数</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/10"><span>10 | 简约不简单的匿名函数</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/11"><span>11 | 面向对象（上）：从生活中的类比说起</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/12"><span>12 | 面向对象（下）：如何实现一个搜索引擎？</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/13"><span>13 | 搭建积木：Python 模块化</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/14"><span>14 | 答疑（一）：列表和元组的内部实现是怎样的？</span></a></li></ul></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇">03.进阶篇</a><ul><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/01"><span>15 | Python对象的比较、拷贝</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/02"><span>16 | 值传递，引用传递or其他，Python里参数是如何传递的？</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/03"><span>17 | 强大的装饰器</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/04"><span>18 | metaclass，是潘多拉魔盒还是阿拉丁神灯？</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/05"><span>19 | 深入理解迭代器和生成器</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/06"><span>20 | 揭秘 Python 协程</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/07"><span>21 | Python并发编程之Futures</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/08"><span>22 | 并发编程之Asyncio</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/09"><span>23 | 你真的懂Python GIL（全局解释器锁）吗？</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/10"><span>24 | 带你解析 Python 垃圾回收机制</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/11"><span>25 | 答疑（二）：GIL与多线程是什么关系呢？</span></a></li></ul></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇">04.规范篇</a><ul><li><a href="/blog-backend/python核心技术与实战/04.规范篇/01"><span>26 | 活都来不及干了，还有空注意代码风格？！</span></a></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇/02"><span>27 | 学会合理分解代码，提高代码可读性</span></a></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇/03"><span>28 | 如何合理利用assert？</span></a></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇/04"><span>29 | 巧用上下文管理器和With语句精简代码</span></a></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇/05"><span>30 | 真的有必要写单元测试吗？</span></a></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇/06"><span>31 | pdb &amp; cProfile：调试和性能分析的法宝</span></a></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇/07"><span>32 | 答疑（三）：如何选择合适的异常处理方式？</span></a></li></ul></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇">05.量化交易实战篇</a><ul><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/01"><span>33 | 带你初探量化世界</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/02"><span>34 | RESTful &amp; Socket：搭建交易执行层核心</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/03"><span>35 | RESTful &amp; Socket：行情数据对接和抓取</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/04"><span>36 | Pandas &amp; Numpy：策略与回测系统</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/05"><span>37 | Kafka &amp; ZMQ：自动化交易流水线</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/06"><span>38 | MySQL：日志和数据存储系统</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/07"><span>39 | Django：搭建监控平台</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/08"><span>40 | 总结：Python中的数据结构与算法全景</span></a></li></ul></li><li><a href="/blog-backend/python核心技术与实战/06.技术见闻与分享">06.技术见闻与分享</a><ul><li><a href="/blog-backend/python核心技术与实战/06.技术见闻与分享/01"><span>41 | 硅谷一线互联网公司的工作体验</span></a></li><li><a href="/blog-backend/python核心技术与实战/06.技术见闻与分享/02"><span>42 | 细数技术研发的注意事项</span></a></li><li><a href="/blog-backend/python核心技术与实战/06.技术见闻与分享/03"><span>加餐 | 带你上手SWIG：一份清晰好用的SWIG编程实践指南</span></a></li><li><a href="/blog-backend/python核心技术与实战/06.技术见闻与分享/04"><span>43 | Q&amp;A：聊一聊职业发展和选择</span></a></li></ul></li><li><a href="/blog-backend/python核心技术与实战/07.结束语">07.结束语</a><ul><li><a href="/blog-backend/python核心技术与实战/07.结束语/01"><span>结束语 | 技术之外的几点成长建议</span></a></li><li><a href="/blog-backend/python核心技术与实战/07.结束语/02"><span>结课测试 | 关于Python的这些知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-backend/python核心技术与实战/summary">python核心技术与实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="字典和集合基础" data-depth="2"><a href="/blog-backend/python核心技术与实战/02.基础篇/04#字典和集合基础"><span>字典和集合基础</span></a></li><li title="字典和集合性能" data-depth="2"><a href="/blog-backend/python核心技术与实战/02.基础篇/04#字典和集合性能"><span>字典和集合性能</span></a></li><li title="字典和集合的工作原理" data-depth="2"><a href="/blog-backend/python核心技术与实战/02.基础篇/04#字典和集合的工作原理"><span>字典和集合的工作原理</span></a></li><li title="插入操作" data-depth="3"><a href="/blog-backend/python核心技术与实战/02.基础篇/04#插入操作"><span>插入操作</span></a></li><li title="查找操作" data-depth="3"><a href="/blog-backend/python核心技术与实战/02.基础篇/04#查找操作"><span>查找操作</span></a></li><li title="删除操作" data-depth="3"><a href="/blog-backend/python核心技术与实战/02.基础篇/04#删除操作"><span>删除操作</span></a></li><li title="总结" data-depth="2"><a href="/blog-backend/python核心技术与实战/02.基础篇/04#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-backend/python核心技术与实战/02.基础篇/04#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="04--字典集合你真的了解吗"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/04#04--字典集合你真的了解吗"><span class="icon icon-link"></span></a>04 | 字典、集合，你真的了解吗？</h1><p>你好，我是景霄。</p><p>前面的课程，我们学习了Python中的列表和元组，了解了他们的基本操作和性能比较。这节课，我们再来学习两个同样很常见并且很有用的数据结构：字典（dict）和集合（set）。字典和集合在Python被广泛使用，并且性能进行了高度优化，其重要性不言而喻。</p><h2 id="字典和集合基础"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/04#字典和集合基础"><span class="icon icon-link"></span></a>字典和集合基础</h2><p>那究竟什么是字典，什么是集合呢？字典是一系列由键（key）和值（value）配对组成的元素的集合，在Python3.7+，字典被确定为有序（注意：在3.6中，字典有序是一个implementation detail，在3.7才正式成为语言特性，因此3.6中无法100%确保其有序性），而3.6之前是无序的，其长度大小可变，元素可以任意地删减和改变。</p><p>相比于列表和元组，字典的性能更优，特别是对于查找、添加和删除操作，字典都能在常数时间复杂度内完成。</p><p>而集合和字典基本相同，唯一的区别，就是集合没有键和值的配对，是一系列无序的、唯一的元素组合。</p><p>首先我们来看字典和集合的创建，通常有下面这几种方式：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">d1 = {&#x27;name&#x27;: &#x27;jason&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;}</span></div><div class="token-line"><span class="token plain">    d2 = dict({&#x27;name&#x27;: &#x27;jason&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;})</span></div><div class="token-line"><span class="token plain">    d3 = dict([(&#x27;name&#x27;, &#x27;jason&#x27;), (&#x27;age&#x27;, 20), (&#x27;gender&#x27;, &#x27;male&#x27;)])</span></div><div class="token-line"><span class="token plain">    d4 = dict(name=&#x27;jason&#x27;, age=20, gender=&#x27;male&#x27;) </span></div><div class="token-line"><span class="token plain">    d1 == d2 == d3 ==d4</span></div><div class="token-line"><span class="token plain">    True</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    s1 = {1, 2, 3}</span></div><div class="token-line"><span class="token plain">    s2 = set([1, 2, 3])</span></div><div class="token-line"><span class="token plain">    s1 == s2</span></div><div class="token-line"><span class="token plain">    True</span></div></pre></div><p>这里注意，Python中字典和集合，无论是键还是值，都可以是混合类型。比如下面这个例子，我创建了一个元素为<code>1</code>，<code>&#x27;hello&#x27;</code>，<code>5.0</code>的集合：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">s = {1, &#x27;hello&#x27;, 5.0}</span></div></pre></div><p>再来看元素访问的问题。字典访问可以直接索引键，如果不存在，就会抛出异常：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">d = {&#x27;name&#x27;: &#x27;jason&#x27;, &#x27;age&#x27;: 20}</span></div><div class="token-line"><span class="token plain">    d[&#x27;name&#x27;]</span></div><div class="token-line"><span class="token plain">    &#x27;jason&#x27;</span></div><div class="token-line"><span class="token plain">    d[&#x27;location&#x27;]</span></div><div class="token-line"><span class="token plain">    Traceback (most recent call last):</span></div><div class="token-line"><span class="token plain">      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span></div><div class="token-line"><span class="token plain">    KeyError: &#x27;location&#x27;</span></div></pre></div><p>也可以使用get(key, default)函数来进行索引。如果键不存在，调用get()函数可以返回一个默认值。比如下面这个示例，返回了<code>&#x27;null&#x27;</code>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">d = {&#x27;name&#x27;: &#x27;jason&#x27;, &#x27;age&#x27;: 20}</span></div><div class="token-line"><span class="token plain">    d.get(&#x27;name&#x27;)</span></div><div class="token-line"><span class="token plain">    &#x27;jason&#x27;</span></div><div class="token-line"><span class="token plain">    d.get(&#x27;location&#x27;, &#x27;null&#x27;)</span></div><div class="token-line"><span class="token plain">    &#x27;null&#x27;</span></div></pre></div><p>说完了字典的访问，我们再来看集合。</p><p>首先我要强调的是，<strong>集合并不支持索引操作，因为集合本质上是一个哈希表，和列表不一样</strong>。所以，下面这样的操作是错误的，Python会抛出异常：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">s = {1, 2, 3}</span></div><div class="token-line"><span class="token plain">    s[0]</span></div><div class="token-line"><span class="token plain">    Traceback (most recent call last):</span></div><div class="token-line"><span class="token plain">      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span></div><div class="token-line"><span class="token plain">    TypeError: &#x27;set&#x27; object does not support indexing</span></div></pre></div><p>想要判断一个元素在不在字典或集合内，我们可以用value in dict/set 来判断。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">s = {1, 2, 3}</span></div><div class="token-line"><span class="token plain">    1 in s</span></div><div class="token-line"><span class="token plain">    True</span></div><div class="token-line"><span class="token plain">    10 in s</span></div><div class="token-line"><span class="token plain">    False</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    d = {&#x27;name&#x27;: &#x27;jason&#x27;, &#x27;age&#x27;: 20}</span></div><div class="token-line"><span class="token plain">    &#x27;name&#x27; in d</span></div><div class="token-line"><span class="token plain">    True</span></div><div class="token-line"><span class="token plain">    &#x27;location&#x27; in d</span></div><div class="token-line"><span class="token plain">    False</span></div></pre></div><p>当然，除了创建和访问，字典和集合也同样支持增加、删除、更新等操作。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">d = {&#x27;name&#x27;: &#x27;jason&#x27;, &#x27;age&#x27;: 20}</span></div><div class="token-line"><span class="token plain">    d[&#x27;gender&#x27;] = &#x27;male&#x27; # 增加元素对&#x27;gender&#x27;: &#x27;male&#x27;</span></div><div class="token-line"><span class="token plain">    d[&#x27;dob&#x27;] = &#x27;1999-02-01&#x27; # 增加元素对&#x27;dob&#x27;: &#x27;1999-02-01&#x27;</span></div><div class="token-line"><span class="token plain">    d</span></div><div class="token-line"><span class="token plain">    {&#x27;name&#x27;: &#x27;jason&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;, &#x27;dob&#x27;: &#x27;1999-02-01&#x27;}</span></div><div class="token-line"><span class="token plain">    d[&#x27;dob&#x27;] = &#x27;1998-01-01&#x27; # 更新键&#x27;dob&#x27;对应的值 </span></div><div class="token-line"><span class="token plain">    d.pop(&#x27;dob&#x27;) # 删除键为&#x27;dob&#x27;的元素对</span></div><div class="token-line"><span class="token plain">    &#x27;1998-01-01&#x27;</span></div><div class="token-line"><span class="token plain">    d</span></div><div class="token-line"><span class="token plain">    {&#x27;name&#x27;: &#x27;jason&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    s = {1, 2, 3}</span></div><div class="token-line"><span class="token plain">    s.add(4) # 增加元素4到集合</span></div><div class="token-line"><span class="token plain">    s</span></div><div class="token-line"><span class="token plain">    {1, 2, 3, 4}</span></div><div class="token-line"><span class="token plain">    s.remove(4) # 从集合中删除元素4</span></div><div class="token-line"><span class="token plain">    s</span></div><div class="token-line"><span class="token plain">    {1, 2, 3}</span></div></pre></div><p>不过要注意，集合的pop()操作是删除集合中最后一个元素，可是集合本身是无序的，你无法知道会删除哪个元素，因此这个操作得谨慎使用。</p><p>实际应用中，很多情况下，我们需要对字典或集合进行排序，比如，取出值最大的50对。</p><p>对于字典，我们通常会根据键或值，进行升序或降序排序：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">d = {&#x27;b&#x27;: 1, &#x27;a&#x27;: 2, &#x27;c&#x27;: 10}</span></div><div class="token-line"><span class="token plain">    d_sorted_by_key = sorted(d.items(), key=lambda x: x[0]) # 根据字典键的升序排序</span></div><div class="token-line"><span class="token plain">    d_sorted_by_value = sorted(d.items(), key=lambda x: x[1]) # 根据字典值的升序排序</span></div><div class="token-line"><span class="token plain">    d_sorted_by_key</span></div><div class="token-line"><span class="token plain">    [(&#x27;a&#x27;, 2), (&#x27;b&#x27;, 1), (&#x27;c&#x27;, 10)]</span></div><div class="token-line"><span class="token plain">    d_sorted_by_value</span></div><div class="token-line"><span class="token plain">    [(&#x27;b&#x27;, 1), (&#x27;a&#x27;, 2), (&#x27;c&#x27;, 10)]</span></div></pre></div><p>这里返回了一个列表。列表中的每个元素，是由原字典的键和值组成的元组。</p><p>而对于集合，其排序和前面讲过的列表、元组很类似，直接调用sorted(set)即可，结果会返回一个排好序的列表。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">s = {3, 4, 2, 1}</span></div><div class="token-line"><span class="token plain">    sorted(s) # 对集合的元素进行升序排序</span></div><div class="token-line"><span class="token plain">    [1, 2, 3, 4]</span></div></pre></div><h2 id="字典和集合性能"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/04#字典和集合性能"><span class="icon icon-link"></span></a>字典和集合性能</h2><p>文章开头我就说到了，字典和集合是进行过性能高度优化的数据结构，特别是对于查找、添加和删除操作。那接下来，我们就来看看，它们在具体场景下的性能表现，以及与列表等其他数据结构的对比。</p><p>比如电商企业的后台，存储了每件产品的ID、名称和价格。现在的需求是，给定某件商品的ID，我们要找出其价格。</p><p>如果我们用列表来存储这些数据结构，并进行查找，相应的代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">def find_product_price(products, product_id):</span></div><div class="token-line"><span class="token plain">        for id, price in products:</span></div><div class="token-line"><span class="token plain">            if id == product_id:</span></div><div class="token-line"><span class="token plain">                return price</span></div><div class="token-line"><span class="token plain">        return None </span></div><div class="token-line"><span class="token plain">         </span></div><div class="token-line"><span class="token plain">    products = [</span></div><div class="token-line"><span class="token plain">        (143121312, 100), </span></div><div class="token-line"><span class="token plain">        (432314553, 30),</span></div><div class="token-line"><span class="token plain">        (32421912367, 150) </span></div><div class="token-line"><span class="token plain">    ]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    print(&#x27;The price of product 432314553 is {}&#x27;.format(find_product_price(products, 432314553)))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 输出</span></div><div class="token-line"><span class="token plain">    The price of product 432314553 is 30</span></div></pre></div><p>假设列表有n个元素，而查找的过程要遍历列表，那么时间复杂度就为O(n)。即使我们先对列表进行排序，然后使用二分查找，也会需要O(logn)的时间复杂度，更何况，列表的排序还需要O(nlogn)的时间。</p><p>但如果我们用字典来存储这些数据，那么查找就会非常便捷高效，只需O(1)的时间复杂度就可以完成。原因也很简单，刚刚提到过的，字典的内部组成是一张哈希表，你可以直接通过键的哈希值，找到其对应的值。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">products = {</span></div><div class="token-line"><span class="token plain">      143121312: 100,</span></div><div class="token-line"><span class="token plain">      432314553: 30,</span></div><div class="token-line"><span class="token plain">      32421912367: 150</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    print(&#x27;The price of product 432314553 is {}&#x27;.format(products[432314553])) </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 输出</span></div><div class="token-line"><span class="token plain">    The price of product 432314553 is 30</span></div></pre></div><p>类似的，现在需求变成，要找出这些商品有多少种不同的价格。我们还用同样的方法来比较一下。</p><p>如果还是选择使用列表，对应的代码如下，其中，A和B是两层循环。同样假设原始列表有n个元素，那么，在最差情况下，需要O(n^2)的时间复杂度。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># list version</span></div><div class="token-line"><span class="token plain">    def find_unique_price_using_list(products):</span></div><div class="token-line"><span class="token plain">        unique_price_list = []</span></div><div class="token-line"><span class="token plain">        for _, price in products: # A</span></div><div class="token-line"><span class="token plain">            if price not in unique_price_list: #B</span></div><div class="token-line"><span class="token plain">                unique_price_list.append(price)</span></div><div class="token-line"><span class="token plain">        return len(unique_price_list)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    products = [</span></div><div class="token-line"><span class="token plain">        (143121312, 100), </span></div><div class="token-line"><span class="token plain">        (432314553, 30),</span></div><div class="token-line"><span class="token plain">        (32421912367, 150),</span></div><div class="token-line"><span class="token plain">        (937153201, 30)</span></div><div class="token-line"><span class="token plain">    ]</span></div><div class="token-line"><span class="token plain">    print(&#x27;number of unique price is: {}&#x27;.format(find_unique_price_using_list(products)))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 输出</span></div><div class="token-line"><span class="token plain">    number of unique price is: 3</span></div></pre></div><p>但如果我们选择使用集合这个数据结构，由于集合是高度优化的哈希表，里面元素不能重复，并且其添加和查找操作只需O(1)的复杂度，那么，总的时间复杂度就只有O(n)。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># set version</span></div><div class="token-line"><span class="token plain">    def find_unique_price_using_set(products):</span></div><div class="token-line"><span class="token plain">        unique_price_set = set()</span></div><div class="token-line"><span class="token plain">        for _, price in products:</span></div><div class="token-line"><span class="token plain">            unique_price_set.add(price)</span></div><div class="token-line"><span class="token plain">        return len(unique_price_set)        </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    products = [</span></div><div class="token-line"><span class="token plain">        (143121312, 100), </span></div><div class="token-line"><span class="token plain">        (432314553, 30),</span></div><div class="token-line"><span class="token plain">        (32421912367, 150),</span></div><div class="token-line"><span class="token plain">        (937153201, 30)</span></div><div class="token-line"><span class="token plain">    ]</span></div><div class="token-line"><span class="token plain">    print(&#x27;number of unique price is: {}&#x27;.format(find_unique_price_using_set(products)))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 输出</span></div><div class="token-line"><span class="token plain">    number of unique price is: 3</span></div></pre></div><p>可能你对这些时间复杂度没有直观的认识，我可以举一个实际工作场景中的例子，让你来感受一下。</p><p>下面的代码，初始化了含有100,000个元素的产品，并分别计算了使用列表和集合来统计产品价格数量的运行时间：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import time</span></div><div class="token-line"><span class="token plain">    id = [x for x in range(0, 100000)]</span></div><div class="token-line"><span class="token plain">    price = [x for x in range(200000, 300000)]</span></div><div class="token-line"><span class="token plain">    products = list(zip(id, price))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 计算列表版本的时间</span></div><div class="token-line"><span class="token plain">    start_using_list = time.perf_counter()</span></div><div class="token-line"><span class="token plain">    find_unique_price_using_list(products)</span></div><div class="token-line"><span class="token plain">    end_using_list = time.perf_counter()</span></div><div class="token-line"><span class="token plain">    print(&quot;time elapse using list: {}&quot;.format(end_using_list - start_using_list))</span></div><div class="token-line"><span class="token plain">    ## 输出</span></div><div class="token-line"><span class="token plain">    time elapse using list: 41.61519479751587</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 计算集合版本的时间</span></div><div class="token-line"><span class="token plain">    start_using_set = time.perf_counter()</span></div><div class="token-line"><span class="token plain">    find_unique_price_using_set(products)</span></div><div class="token-line"><span class="token plain">    end_using_set = time.perf_counter()</span></div><div class="token-line"><span class="token plain">    print(&quot;time elapse using set: {}&quot;.format(end_using_set - start_using_set))</span></div><div class="token-line"><span class="token plain">    # 输出</span></div><div class="token-line"><span class="token plain">    time elapse using set: 0.008238077163696289</span></div></pre></div><p>你可以看到，仅仅十万的数据量，两者的速度差异就如此之大。事实上，大型企业的后台数据往往有上亿乃至十亿数量级，如果使用了不合适的数据结构，就很容易造成服务器的崩溃，不但影响用户体验，并且会给公司带来巨大的财产损失。</p><h2 id="字典和集合的工作原理"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/04#字典和集合的工作原理"><span class="icon icon-link"></span></a>字典和集合的工作原理</h2><p>我们通过举例以及与列表的对比，看到了字典和集合操作的高效性。不过，字典和集合为什么能够如此高效，特别是查找、插入和删除操作？</p><p>这当然和字典、集合内部的数据结构密不可分。不同于其他数据结构，字典和集合的内部结构都是一张哈希表。</p><ul><li><p>对于字典而言，这张表存储了哈希值（hash）、键和值这3个元素。</p></li><li><p>而对集合来说，区别就是哈希表内没有键和值的配对，只有单一的元素了。</p></li></ul><p>我们来看，老版本Python的哈希表结构如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">--+-------------------------------+</span></div><div class="token-line"><span class="token plain">      | 哈希值(hash)  键(key)  值(value)</span></div><div class="token-line"><span class="token plain">    --+-------------------------------+</span></div><div class="token-line"><span class="token plain">    0 |    hash0      key0    value0</span></div><div class="token-line"><span class="token plain">    --+-------------------------------+</span></div><div class="token-line"><span class="token plain">    1 |    hash1      key1    value1</span></div><div class="token-line"><span class="token plain">    --+-------------------------------+</span></div><div class="token-line"><span class="token plain">    2 |    hash2      key2    value2</span></div><div class="token-line"><span class="token plain">    --+-------------------------------+</span></div><div class="token-line"><span class="token plain">    . |           ...</span></div><div class="token-line"><span class="token plain">    __+_______________________________+</span></div></pre></div><p>不难想象，随着哈希表的扩张，它会变得越来越稀疏。举个例子，比如我有这样一个字典：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">{&#x27;name&#x27;: &#x27;mike&#x27;, &#x27;dob&#x27;: &#x27;1999-01-01&#x27;, &#x27;gender&#x27;: &#x27;male&#x27;}</span></div></pre></div><p>那么它会存储为类似下面的形式：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">entries = [</span></div><div class="token-line"><span class="token plain">    [&#x27;--&#x27;, &#x27;--&#x27;, &#x27;--&#x27;]</span></div><div class="token-line"><span class="token plain">    [-230273521, &#x27;dob&#x27;, &#x27;1999-01-01&#x27;],</span></div><div class="token-line"><span class="token plain">    [&#x27;--&#x27;, &#x27;--&#x27;, &#x27;--&#x27;],</span></div><div class="token-line"><span class="token plain">    [&#x27;--&#x27;, &#x27;--&#x27;, &#x27;--&#x27;],</span></div><div class="token-line"><span class="token plain">    [1231236123, &#x27;name&#x27;, &#x27;mike&#x27;],</span></div><div class="token-line"><span class="token plain">    [&#x27;--&#x27;, &#x27;--&#x27;, &#x27;--&#x27;],</span></div><div class="token-line"><span class="token plain">    [9371539127, &#x27;gender&#x27;, &#x27;male&#x27;]</span></div><div class="token-line"><span class="token plain">    ]</span></div></pre></div><p>这样的设计结构显然非常浪费存储空间。为了提高存储空间的利用率，现在的哈希表除了字典本身的结构，会把索引和哈希值、键、值单独分开，也就是下面这样新的结构：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Indices</span></div><div class="token-line"><span class="token plain">    ----------------------------------------------------</span></div><div class="token-line"><span class="token plain">    None | index | None | None | index | None | index ...</span></div><div class="token-line"><span class="token plain">    ----------------------------------------------------</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Entries</span></div><div class="token-line"><span class="token plain">    --------------------</span></div><div class="token-line"><span class="token plain">    hash0   key0  value0</span></div><div class="token-line"><span class="token plain">    ---------------------</span></div><div class="token-line"><span class="token plain">    hash1   key1  value1</span></div><div class="token-line"><span class="token plain">    ---------------------</span></div><div class="token-line"><span class="token plain">    hash2   key2  value2</span></div><div class="token-line"><span class="token plain">    ---------------------</span></div><div class="token-line"><span class="token plain">            ...</span></div><div class="token-line"><span class="token plain">    ---------------------</span></div></pre></div><p>那么，刚刚的这个例子，在新的哈希表结构下的存储形式，就会变成下面这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">indices = [None, 1, None, None, 0, None, 2]</span></div><div class="token-line"><span class="token plain">    entries = [</span></div><div class="token-line"><span class="token plain">    [1231236123, &#x27;name&#x27;, &#x27;mike&#x27;],</span></div><div class="token-line"><span class="token plain">    [-230273521, &#x27;dob&#x27;, &#x27;1999-01-01&#x27;],</span></div><div class="token-line"><span class="token plain">    [9371539127, &#x27;gender&#x27;, &#x27;male&#x27;]</span></div><div class="token-line"><span class="token plain">    ]</span></div></pre></div><p>我们可以很清晰地看到，空间利用率得到很大的提高。</p><p>清楚了具体的设计结构，我们接着来看这几个操作的工作原理。</p><h3 id="插入操作"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/04#插入操作"><span class="icon icon-link"></span></a>插入操作</h3><p>每次向字典或集合插入一个元素时，Python会首先计算键的哈希值（hash(key)），再和 mask = PyDicMinSize - 1做与操作，计算这个元素应该插入哈希表的位置index = hash(key) &amp; mask。如果哈希表中此位置是空的，那么这个元素就会被插入其中。</p><p>而如果此位置已被占用，Python便会比较两个元素的哈希值和键是否相等。</p><ul><li><p>若两者都相等，则表明这个元素已经存在，如果值不同，则更新值。</p></li><li><p>若两者中有一个不相等，这种情况我们通常称为哈希冲突（hash collision），意思是两个元素的键不相等，但是哈希值相等。这种情况下，Python便会继续寻找表中空余的位置，直到找到位置为止。</p></li></ul><p>值得一提的是，通常来说，遇到这种情况，最简单的方式是线性寻找，即从这个位置开始，挨个往后寻找空位。当然，Python内部对此进行了优化（这一点无需深入了解，你有兴趣可以查看源码，我就不再赘述），让这个步骤更加高效。</p><h3 id="查找操作"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/04#查找操作"><span class="icon icon-link"></span></a>查找操作</h3><p>和前面的插入操作类似，Python会根据哈希值，找到其应该处于的位置；然后，比较哈希表这个位置中元素的哈希值和键，与需要查找的元素是否相等。如果相等，则直接返回；如果不等，则继续查找，直到找到空位或者抛出异常为止。</p><h3 id="删除操作"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/04#删除操作"><span class="icon icon-link"></span></a>删除操作</h3><p>对于删除操作，Python会暂时对这个位置的元素，赋于一个特殊的值，等到重新调整哈希表的大小时，再将其删除。</p><p>不难理解，哈希冲突的发生，往往会降低字典和集合操作的速度。因此，为了保证其高效性，字典和集合内的哈希表，通常会保证其至少留有1/3的剩余空间。随着元素的不停插入，当剩余空间小于1/3时，Python会重新获取更大的内存空间，扩充哈希表。不过，这种情况下，表内所有的元素位置都会被重新排放。</p><p>虽然哈希冲突和哈希表大小的调整，都会导致速度减缓，但是这种情况发生的次数极少。所以，平均情况下，这仍能保证插入、查找和删除的时间复杂度为O(1)。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/04#总结"><span class="icon icon-link"></span></a>总结</h2><p>这节课，我们一起学习了字典和集合的基本操作，并对它们的高性能和内部存储结构进行了讲解。</p><p>字典在Python3.7+是有序的数据结构，而集合是无序的，其内部的哈希表存储结构，保证了其查找、插入、删除操作的高效性。所以，字典和集合通常运用在对元素的高效查找、去重等场景。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/04#思考题"><span class="icon icon-link"></span></a>思考题</h2><p><strong>1.</strong> 下面初始化字典的方式，哪一种更高效？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># Option A</span></div><div class="token-line"><span class="token plain">    d = {&#x27;name&#x27;: &#x27;jason&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # Option B</span></div><div class="token-line"><span class="token plain">    d = dict({&#x27;name&#x27;: &#x27;jason&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;})</span></div></pre></div><p><strong>2.</strong> 字典的键可以是一个列表吗？下面这段代码中，字典的初始化是否正确呢？如果不正确，可以说出你的原因吗？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">d = {&#x27;name&#x27;: &#x27;jason&#x27;, [&#x27;education&#x27;]: [&#x27;Tsinghua University&#x27;, &#x27;Stanford University&#x27;]}</span></div></pre></div><p>欢迎留言和我分享，也欢迎你把这篇文章分享给你的同事、朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/python核心技术与实战/02.基础篇/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
