<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>06 | Python “黑箱”：输入与输出 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/python核心技术与实战/02.基础篇/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a aria-current="page" class="active" href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a aria-current="page" class="active" href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/python核心技术与实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-backend/python核心技术与实战/01.开篇词/01"><span>开篇词 | 从工程的角度深入理解Python</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/python核心技术与实战/02.基础篇">02.基础篇</a><ul><li><a href="/blog-backend/python核心技术与实战/02.基础篇/01"><span>01 | 如何逐步突破，成为Python高手？</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/02"><span>02 | Jupyter Notebook为什么是现代Python的必学技术？</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/03"><span>03 | 列表和元组，到底用哪一个？</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/04"><span>04 | 字典、集合，你真的了解吗？</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/05"><span>05 | 深入浅出字符串</span></a></li><li><a aria-current="page" class="active" href="/blog-backend/python核心技术与实战/02.基础篇/06"><span>06 | Python “黑箱”：输入与输出</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/07"><span>07 | 修炼基本功：条件与循环</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/08"><span>08 | 异常处理：如何提高程序的稳定性？</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/09"><span>09 | 不可或缺的自定义函数</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/10"><span>10 | 简约不简单的匿名函数</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/11"><span>11 | 面向对象（上）：从生活中的类比说起</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/12"><span>12 | 面向对象（下）：如何实现一个搜索引擎？</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/13"><span>13 | 搭建积木：Python 模块化</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/14"><span>14 | 答疑（一）：列表和元组的内部实现是怎样的？</span></a></li></ul></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇">03.进阶篇</a><ul><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/01"><span>15 | Python对象的比较、拷贝</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/02"><span>16 | 值传递，引用传递or其他，Python里参数是如何传递的？</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/03"><span>17 | 强大的装饰器</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/04"><span>18 | metaclass，是潘多拉魔盒还是阿拉丁神灯？</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/05"><span>19 | 深入理解迭代器和生成器</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/06"><span>20 | 揭秘 Python 协程</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/07"><span>21 | Python并发编程之Futures</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/08"><span>22 | 并发编程之Asyncio</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/09"><span>23 | 你真的懂Python GIL（全局解释器锁）吗？</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/10"><span>24 | 带你解析 Python 垃圾回收机制</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/11"><span>25 | 答疑（二）：GIL与多线程是什么关系呢？</span></a></li></ul></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇">04.规范篇</a><ul><li><a href="/blog-backend/python核心技术与实战/04.规范篇/01"><span>26 | 活都来不及干了，还有空注意代码风格？！</span></a></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇/02"><span>27 | 学会合理分解代码，提高代码可读性</span></a></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇/03"><span>28 | 如何合理利用assert？</span></a></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇/04"><span>29 | 巧用上下文管理器和With语句精简代码</span></a></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇/05"><span>30 | 真的有必要写单元测试吗？</span></a></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇/06"><span>31 | pdb &amp; cProfile：调试和性能分析的法宝</span></a></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇/07"><span>32 | 答疑（三）：如何选择合适的异常处理方式？</span></a></li></ul></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇">05.量化交易实战篇</a><ul><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/01"><span>33 | 带你初探量化世界</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/02"><span>34 | RESTful &amp; Socket：搭建交易执行层核心</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/03"><span>35 | RESTful &amp; Socket：行情数据对接和抓取</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/04"><span>36 | Pandas &amp; Numpy：策略与回测系统</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/05"><span>37 | Kafka &amp; ZMQ：自动化交易流水线</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/06"><span>38 | MySQL：日志和数据存储系统</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/07"><span>39 | Django：搭建监控平台</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/08"><span>40 | 总结：Python中的数据结构与算法全景</span></a></li></ul></li><li><a href="/blog-backend/python核心技术与实战/06.技术见闻与分享">06.技术见闻与分享</a><ul><li><a href="/blog-backend/python核心技术与实战/06.技术见闻与分享/01"><span>41 | 硅谷一线互联网公司的工作体验</span></a></li><li><a href="/blog-backend/python核心技术与实战/06.技术见闻与分享/02"><span>42 | 细数技术研发的注意事项</span></a></li><li><a href="/blog-backend/python核心技术与实战/06.技术见闻与分享/03"><span>加餐 | 带你上手SWIG：一份清晰好用的SWIG编程实践指南</span></a></li><li><a href="/blog-backend/python核心技术与实战/06.技术见闻与分享/04"><span>43 | Q&amp;A：聊一聊职业发展和选择</span></a></li></ul></li><li><a href="/blog-backend/python核心技术与实战/07.结束语">07.结束语</a><ul><li><a href="/blog-backend/python核心技术与实战/07.结束语/01"><span>结束语 | 技术之外的几点成长建议</span></a></li><li><a href="/blog-backend/python核心技术与实战/07.结束语/02"><span>结课测试 | 关于Python的这些知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-backend/python核心技术与实战/summary">python核心技术与实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="输入输出基础" data-depth="2"><a href="/blog-backend/python核心技术与实战/02.基础篇/06#输入输出基础"><span>输入输出基础</span></a></li><li title="文件输入输出" data-depth="2"><a href="/blog-backend/python核心技术与实战/02.基础篇/06#文件输入输出"><span>文件输入输出</span></a></li><li title="JSON 序列化与实战" data-depth="2"><a href="/blog-backend/python核心技术与实战/02.基础篇/06#json-序列化与实战"><span>JSON 序列化与实战</span></a></li><li title="总结" data-depth="2"><a href="/blog-backend/python核心技术与实战/02.基础篇/06#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-backend/python核心技术与实战/02.基础篇/06#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="06--python-黑箱输入与输出"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/06#06--python-黑箱输入与输出"><span class="icon icon-link"></span></a>06 | Python “黑箱”：输入与输出</h1><p>你好，我是景霄。</p><p>世纪之交的论坛上曾有一句流行语：在互联网上，没人知道你是一条狗。互联网刚刚兴起时，一根网线链接到你家，信息通过这条高速线缆直达你的屏幕，你通过键盘飞速回应朋友的消息，信息再次通过网线飞入错综复杂的虚拟世界，再进入朋友家。抽象来看，一台台的电脑就是一个个黑箱，黑箱有了输入和输出，就拥有了图灵机运作的必要条件。</p><p>Python 程序也是一个黑箱：通过输入流将数据送达，通过输出流将处理后的数据送出，可能 Python 解释器后面藏了一个人，还是一个史莱哲林？No one cares。</p><p>好了废话不多说，今天我们就由浅及深讲讲 Python 的输入和输出。</p><h2 id="输入输出基础"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/06#输入输出基础"><span class="icon icon-link"></span></a>输入输出基础</h2><p>最简单直接的输入来自键盘操作，比如下面这个例子。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">name = input(&#x27;your name:&#x27;)</span></div><div class="token-line"><span class="token plain">    gender = input(&#x27;you are a boy?(y/n)&#x27;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ###### 输入 ######</span></div><div class="token-line"><span class="token plain">    your name:Jack</span></div><div class="token-line"><span class="token plain">    you are a boy?</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    welcome_str = &#x27;Welcome to the matrix {prefix} {name}.&#x27;</span></div><div class="token-line"><span class="token plain">    welcome_dic = {</span></div><div class="token-line"><span class="token plain">        &#x27;prefix&#x27;: &#x27;Mr.&#x27; if gender == &#x27;y&#x27; else &#x27;Mrs&#x27;,</span></div><div class="token-line"><span class="token plain">        &#x27;name&#x27;: name</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    print(&#x27;authorizing...&#x27;)</span></div><div class="token-line"><span class="token plain">    print(welcome_str.format(**welcome_dic))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ########## 输出 ##########</span></div><div class="token-line"><span class="token plain">    authorizing...</span></div><div class="token-line"><span class="token plain">    Welcome to the matrix Mr. Jack.</span></div></pre></div><p>input() 函数暂停程序运行，同时等待键盘输入；直到回车被按下，函数的参数即为提示语，输入的类型永远是字符串型（str）。注意，初学者在这里很容易犯错，下面的例子我会讲到。print() 函数则接受字符串、数字、字典、列表甚至一些自定义类的输出。</p><p>我们再来看下面这个例子。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">a = input()</span></div><div class="token-line"><span class="token plain">    1</span></div><div class="token-line"><span class="token plain">    b = input()</span></div><div class="token-line"><span class="token plain">    2</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    print(&#x27;a + b = {}&#x27;.format(a + b))</span></div><div class="token-line"><span class="token plain">    ########## 输出 ##############</span></div><div class="token-line"><span class="token plain">    a + b = 12</span></div><div class="token-line"><span class="token plain">    print(&#x27;type of a is {}, type of b is {}&#x27;.format(type(a), type(b)))</span></div><div class="token-line"><span class="token plain">    ########## 输出 ##############</span></div><div class="token-line"><span class="token plain">    type of a is &lt;class &#x27;str&#x27;&gt;, type of b is &lt;class &#x27;str&#x27;&gt;</span></div><div class="token-line"><span class="token plain">    print(&#x27;a + b = {}&#x27;.format(int(a) + int(b)))</span></div><div class="token-line"><span class="token plain">    ########## 输出 ##############</span></div><div class="token-line"><span class="token plain">    a + b = 3</span></div></pre></div><p>这里注意，把 str 强制转换为 int 请用 int()，转为浮点数请用 float()。而在生产环境中使用强制转换时，请记得加上 try except（即错误和异常处理，专栏后面文章会讲到）。</p><p>Python 对 int 类型没有最大限制（相比之下， C加加 的 int 最大为 2147483647，超过这个数字会产生溢出），但是对 float 类型依然有精度限制。这些特点，除了在一些算法竞赛中要注意，在生产环境中也要时刻提防，避免因为对边界条件判断不清而造成 bug 甚至 0day（危重安全漏洞）。</p><p>我们回望一下币圈。2018年4月23日中午11点30分左右，BEC 代币智能合约被黑客攻击。黑客利用数据溢出的漏洞，攻击与美图合作的公司美链 BEC 的智能合约，成功地向两个地址转出了天量级别的 BEC 代币，导致市场上的海量 BEC 被抛售，该数字货币的价值也几近归零，给 BEC 市场交易带来了毁灭性的打击。</p><p>由此可见，虽然输入输出和类型处理事情简单，但我们一定要慎之又慎。毕竟相当比例的安全漏洞，都来自随意的 I/O 处理。</p><h2 id="文件输入输出"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/06#文件输入输出"><span class="icon icon-link"></span></a>文件输入输出</h2><p>命令行的输入输出，只是 Python 交互的最基本方式，适用一些简单小程序的交互。而生产级别的 Python 代码，大部分 I/O 则来自于文件、网络、其他进程的消息等等。</p><p>接下来，我们来详细分析一个文本文件读写。假设我们有一个文本文件in.txt，内容如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">I have a dream that my four little children will one day live in a nation where they will not be judged by the color of their skin but by the content of their character. I have a dream today.</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    I have a dream that one day down in Alabama, with its vicious racists, . . . one day right there in Alabama little black boys and black girls will be able to join hands with little white boys and white girls as sisters and brothers. I have a dream today.</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    I have a dream that one day every valley shall be exalted, every hill and mountain shall be made low, the rough places will be made plain, and the crooked places will be made straight, and the glory of the Lord shall be revealed, and all flesh shall see it together.</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    This is our hope. . . With this faith we will be able to hew out of the mountain of despair a stone of hope. With this faith we will be able to transform the jangling discords of our nation into a beautiful symphony of brotherhood. With this faith we will be able to work together, to pray together, to struggle together, to go to jail together, to stand up for freedom together, knowing that we will be free one day. . . .</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    And when this happens, and when we allow freedom ring, when we let it ring from every village and every hamlet, from every state and every city, we will be able to speed up that day when all of God&#x27;s children, black men and white men, Jews and Gentiles, Protestants and Catholics, will be able to join hands and sing in the words of the old Negro spiritual: &quot;Free at last! Free at last! Thank God Almighty, we are free at last!&quot;</span></div></pre></div><p>好，让我们来做一个简单的 NLP（自然语言处理）任务。如果你对此不太了解也没有影响，我会带你一步步完成这个任务。</p><p>首先，我们要清楚NLP任务的基本步骤，也就是下面的四步：</p><ol><li><p>读取文件；</p></li><li><p>去除所有标点符号和换行符，并把所有大写变成小写；</p></li><li><p>合并相同的词，统计每个词出现的频率，并按照词频从大到小排序；</p></li><li><p>将结果按行输出到文件 out.txt。</p></li></ol><p>你可以自己先思考一下，用Python如何解决这个问题。这里，我也给出了我的代码，并附有详细的注释。我们一起来看下这段代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import re</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 你不用太关心这个函数</span></div><div class="token-line"><span class="token plain">    def parse(text):</span></div><div class="token-line"><span class="token plain">        # 使用正则表达式去除标点符号和换行符</span></div><div class="token-line"><span class="token plain">        text = re.sub(r&#x27;[^\w ]&#x27;, &#x27; &#x27;, text)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        # 转为小写</span></div><div class="token-line"><span class="token plain">        text = text.lower()</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        # 生成所有单词的列表</span></div><div class="token-line"><span class="token plain">        word_list = text.split(&#x27; &#x27;)</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        # 去除空白单词</span></div><div class="token-line"><span class="token plain">        word_list = filter(None, word_list)</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        # 生成单词和词频的字典</span></div><div class="token-line"><span class="token plain">        word_cnt = {}</span></div><div class="token-line"><span class="token plain">        for word in word_list:</span></div><div class="token-line"><span class="token plain">            if word not in word_cnt:</span></div><div class="token-line"><span class="token plain">                word_cnt[word] = 0</span></div><div class="token-line"><span class="token plain">            word_cnt[word] += 1</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        # 按照词频排序</span></div><div class="token-line"><span class="token plain">        sorted_word_cnt = sorted(word_cnt.items(), key=lambda kv: kv[1], reverse=True)</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        return sorted_word_cnt</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    with open(&#x27;in.txt&#x27;, &#x27;r&#x27;) as fin:</span></div><div class="token-line"><span class="token plain">        text = fin.read()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    word_and_freq = parse(text)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    with open(&#x27;out.txt&#x27;, &#x27;w&#x27;) as fout:</span></div><div class="token-line"><span class="token plain">        for word, freq in word_and_freq:</span></div><div class="token-line"><span class="token plain">            fout.write(&#x27;{} {}\n&#x27;.format(word, freq))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ########## 输出(省略较长的中间结果) ##########</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    and 15</span></div><div class="token-line"><span class="token plain">    be 13</span></div><div class="token-line"><span class="token plain">    will 11</span></div><div class="token-line"><span class="token plain">    to 11</span></div><div class="token-line"><span class="token plain">    the 10</span></div><div class="token-line"><span class="token plain">    of 10</span></div><div class="token-line"><span class="token plain">    a 8</span></div><div class="token-line"><span class="token plain">    we 8</span></div><div class="token-line"><span class="token plain">    day 6</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    old 1</span></div><div class="token-line"><span class="token plain">    negro 1</span></div><div class="token-line"><span class="token plain">    spiritual 1</span></div><div class="token-line"><span class="token plain">    thank 1</span></div><div class="token-line"><span class="token plain">    god 1</span></div><div class="token-line"><span class="token plain">    almighty 1</span></div><div class="token-line"><span class="token plain">    are 1</span></div></pre></div><p>你不用太关心 parse() 函数的具体实现，你只需要知道，它做的事情是把输入的 text 字符串，转化为我们需要的排序后的词频统计。而 sorted_word_cnt 则是一个二元组的列表（list of tuples）。</p><p>首先我们需要先了解一下，计算机中文件访问的基础知识。事实上，计算机内核（kernel）对文件的处理相对比较复杂，涉及到内核模式、虚拟文件系统、锁和指针等一系列概念，这些内容我不会深入讲解，我只说一些基础但足够使用的知识。</p><p>我们先要用open() 函数拿到文件的指针。其中，第一个参数指定文件位置（相对位置或者绝对位置）；第二个参数，如果是 <code>&#x27;r&#x27;</code>表示读取，如果是<code>&#x27;w&#x27;</code> 则表示写入，当然也可以用 <code>&#x27;rw&#x27;</code> ，表示读写都要。a 则是一个不太常用（但也很有用）的参数，表示追加（append），这样打开的文件，如果需要写入，会从原始文件的最末尾开始写入。</p><p>这里我插一句，在 Facebook 的工作中，代码权限管理非常重要。如果你只需要读取文件，就不要请求写入权限。这样在某种程度上可以降低 bug 对整个系统带来的风险。</p><p>好，回到我们的话题。在拿到指针后，我们可以通过 read() 函数，来读取文件的全部内容。代码 text = fin.read() ，即表示把文件所有内容读取到内存中，并赋值给变量 text。这么做自然也是有利有弊：</p><ul><li><p>优点是方便，接下来我们可以很方便地调用 parse 函数进行分析；</p></li><li><p>缺点是如果文件过大，一次性读取可能造成内存崩溃。</p></li></ul><p>这时，我们可以给 read 指定参数 size ，用来表示读取的最大长度。还可以通过 readline() 函数，每次读取一行，这种做法常用于数据挖掘（Data Mining）中的数据清洗，在写一些小的程序时非常轻便。如果每行之间没有关联，这种做法也可以降低内存的压力。而write() 函数，可以把参数中的字符串输出到文件中，也很容易理解。</p><p>这里我需要简单提一下 with 语句（后文会详细讲到）。open() 函数对应于 close() 函数，也就是说，如果你打开了文件，在完成读取任务后，就应该立刻关掉它。而如果你使用了 with 语句，就不需要显式调用 close()。在 with 的语境下任务执行完毕后，close() 函数会被自动调用，代码也简洁很多。</p><p>最后需要注意的是，所有 I/O 都应该进行错误处理。因为 I/O 操作可能会有各种各样的情况出现，而一个健壮（robust）的程序，需要能应对各种情况的发生，而不应该崩溃（故意设计的情况除外）。</p><h2 id="json-序列化与实战"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/06#json-序列化与实战"><span class="icon icon-link"></span></a>JSON 序列化与实战</h2><p>最后，我来讲一个和实际应用很贴近的知识点。</p><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，它的设计意图是把所有事情都用设计的字符串来表示，这样既方便在互联网上传递信息，也方便人进行阅读（相比一些 binary 的协议）。JSON 在当今互联网中应用非常广泛，也是每一个用 Python程序员应当熟练掌握的技能点。</p><p>设想一个情景，你要向交易所购买一定数额的股票。那么，你需要提交股票代码、方向（买入/卖出）、订单类型（市价/限价）、价格（如果是限价单）、数量等一系列参数，而这些数据里，有字符串，有整数，有浮点数，甚至还有布尔型变量，全部混在一起并不方便交易所解包。</p><p>那该怎么办呢？</p><p>其实，我们要讲的JSON ，正能解决这个场景。你可以把它简单地理解为两种黑箱：</p><ul><li><p>第一种，输入这些杂七杂八的信息，比如Python 字典，输出一个字符串；</p></li><li><p>第二种，输入这个字符串，可以输出包含原始信息的 Python 字典。</p></li></ul><p>具体代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import json</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    params = {</span></div><div class="token-line"><span class="token plain">        &#x27;symbol&#x27;: &#x27;123456&#x27;,</span></div><div class="token-line"><span class="token plain">        &#x27;type&#x27;: &#x27;limit&#x27;,</span></div><div class="token-line"><span class="token plain">        &#x27;price&#x27;: 123.4,</span></div><div class="token-line"><span class="token plain">        &#x27;amount&#x27;: 23</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    params_str = json.dumps(params)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    print(&#x27;after json serialization&#x27;)</span></div><div class="token-line"><span class="token plain">    print(&#x27;type of params_str = {}, params_str = {}&#x27;.format(type(params_str), params))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    original_params = json.loads(params_str)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    print(&#x27;after json deserialization&#x27;)</span></div><div class="token-line"><span class="token plain">    print(&#x27;type of original_params = {}, original_params = {}&#x27;.format(type(original_params), original_params))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ########## 输出 ##########</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    after json serialization</span></div><div class="token-line"><span class="token plain">    type of params_str = &lt;class &#x27;str&#x27;&gt;, params_str = {&#x27;symbol&#x27;: &#x27;123456&#x27;, &#x27;type&#x27;: &#x27;limit&#x27;, &#x27;price&#x27;: 123.4, &#x27;amount&#x27;: 23}</span></div><div class="token-line"><span class="token plain">    after json deserialization</span></div><div class="token-line"><span class="token plain">    type of original_params = &lt;class &#x27;dict&#x27;&gt;, original_params = {&#x27;symbol&#x27;: &#x27;123456&#x27;, &#x27;type&#x27;: &#x27;limit&#x27;, &#x27;price&#x27;: 123.4, &#x27;amount&#x27;: 23}</span></div></pre></div><p>其中，</p><ul><li><p>json.dumps() 这个函数，接受 Python 的基本数据类型，然后将其序列化为 string；</p></li><li><p>而json.loads() 这个函数，接受一个合法字符串，然后将其反序列化为 Python 的基本数据类型。</p></li></ul><p>是不是很简单呢？</p><p>不过还是那句话，请记得加上错误处理。不然，哪怕只是给 json.loads() 发送了一个非法字符串，而你没有 catch 到，程序就会崩溃了。</p><p>到这一步，你可能会想，如果我要输出字符串到文件，或者从文件中读取JSON字符串，又该怎么办呢？</p><p>是的，你仍然可以使用上面提到的 open() 和 read()/write() ，先将字符串读取/输出到内存，再进行JSON编码/解码，当然这有点麻烦。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import json</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    params = {</span></div><div class="token-line"><span class="token plain">        &#x27;symbol&#x27;: &#x27;123456&#x27;,</span></div><div class="token-line"><span class="token plain">        &#x27;type&#x27;: &#x27;limit&#x27;,</span></div><div class="token-line"><span class="token plain">        &#x27;price&#x27;: 123.4,</span></div><div class="token-line"><span class="token plain">        &#x27;amount&#x27;: 23</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    with open(&#x27;params.json&#x27;, &#x27;w&#x27;) as fout:</span></div><div class="token-line"><span class="token plain">        params_str = json.dump(params, fout)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    with open(&#x27;params.json&#x27;, &#x27;r&#x27;) as fin:</span></div><div class="token-line"><span class="token plain">        original_params = json.load(fin)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    print(&#x27;after json deserialization&#x27;)</span></div><div class="token-line"><span class="token plain">    print(&#x27;type of original_params = {}, original_params = {}&#x27;.format(type(original_params), original_params))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ########## 输出 ##########</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    after json deserialization</span></div><div class="token-line"><span class="token plain">    type of original_params = &lt;class &#x27;dict&#x27;&gt;, original_params = {&#x27;symbol&#x27;: &#x27;123456&#x27;, &#x27;type&#x27;: &#x27;limit&#x27;, &#x27;price&#x27;: 123.4, &#x27;amount&#x27;: 23}</span></div></pre></div><p>这样，我们就简单清晰地实现了读写 JSON 字符串的过程。当开发一个第三方应用程序时，你可以通过 JSON 将用户的个人配置输出到文件，方便下次程序启动时自动读取。这也是现在普遍运用的成熟做法。</p><p>那么 JSON 是唯一的选择吗？显然不是，它只是轻量级应用中最方便的选择之一。据我所知，在 Google，有类似的工具叫做Protocol Buffer，当然，Google 已经完全开源了这个工具，你可以自己了解一下使用方法。</p><p>相比于 JSON，它的优点是生成优化后的二进制文件，因此性能更好。但与此同时，生成的二进制序列，是不能直接阅读的。它在 TensorFlow 等很多对性能有要求的系统中都有广泛的应用。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/06#总结"><span class="icon icon-link"></span></a>总结</h2><p>这节课，我们主要学习了 Python 的普通 I/O和文件 I/O，同时了解了 JSON 序列化的基本知识，并通过具体的例子进一步掌握。再次强调一下需要注意的几点：</p><ul><li><p>I/O 操作需谨慎，一定要进行充分的错误处理，并细心编码，防止出现编码漏洞；</p></li><li><p>编码时，对内存占用和磁盘占用要有充分的估计，这样在出错时可以更容易找到原因；</p></li><li><p>JSON序列化是很方便的工具，要结合实战多多练习；</p></li><li><p>代码尽量简洁、清晰，哪怕是初学阶段，也要有一颗当元帅的心。</p></li></ul><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/06#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>最后，我给你留了两道思考题。</p><p>第一问：你能否把NLP例子中的 word count 实现一遍？不过这次，in.txt 可能非常非常大（意味着你不能一次读取到内存中），而 output.txt 不会很大（意味着重复的单词数量很多）。</p><p>提示：你可能需要每次读取一定长度的字符串，进行处理，然后再读取下一次的。但是如果单纯按照长度划分，你可能会把一个单词隔断开，所以需要细心处理这种边界情况。</p><p>第二问：你应该使用过类似百度网盘、Dropbox等网盘，但是它们可能空间有限（比如 5GB）。如果有一天，你计划把家里的 100GB 数据传送到公司，可惜你没带 U 盘，于是你想了一个主意：</p><p>每次从家里向 Dropbox 网盘写入不超过 5GB 的数据，而公司电脑一旦侦测到新数据，就立即拷贝到本地，然后删除网盘上的数据。等家里电脑侦测到本次数据全部传入公司电脑后，再进行下一次写入，直到所有数据都传输过去。</p><p>根据这个想法，你计划在家写一个 server.py，在公司写一个 client.py 来实现这个需求。</p><p>提示：我们假设每个文件都不超过 5GB。</p><ul><li><p>你可以通过写入一个控制文件（config.json）来同步状态。不过，要小心设计状态，这里有可能产生 race condition。</p></li><li><p>你也可以通过直接侦测文件是否产生，或者是否被删除来同步状态，这是最简单的做法。</p></li></ul><p>不要担心难度问题，尽情写下你的思考，最终代码我也会为你准备好。</p><p>欢迎在留言区写下你的答案，也欢迎你把这篇文章转给你的同事、朋友，一起在思考中学习。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/python核心技术与实战/02.基础篇/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
