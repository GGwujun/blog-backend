<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>12 | 面向对象（下）：如何实现一个搜索引擎？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/python核心技术与实战/02.基础篇/12" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a aria-current="page" class="active" href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a aria-current="page" class="active" href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/python核心技术与实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-backend/python核心技术与实战/01.开篇词/01"><span>开篇词 | 从工程的角度深入理解Python</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/python核心技术与实战/02.基础篇">02.基础篇</a><ul><li><a href="/blog-backend/python核心技术与实战/02.基础篇/01"><span>01 | 如何逐步突破，成为Python高手？</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/02"><span>02 | Jupyter Notebook为什么是现代Python的必学技术？</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/03"><span>03 | 列表和元组，到底用哪一个？</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/04"><span>04 | 字典、集合，你真的了解吗？</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/05"><span>05 | 深入浅出字符串</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/06"><span>06 | Python “黑箱”：输入与输出</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/07"><span>07 | 修炼基本功：条件与循环</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/08"><span>08 | 异常处理：如何提高程序的稳定性？</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/09"><span>09 | 不可或缺的自定义函数</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/10"><span>10 | 简约不简单的匿名函数</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/11"><span>11 | 面向对象（上）：从生活中的类比说起</span></a></li><li><a aria-current="page" class="active" href="/blog-backend/python核心技术与实战/02.基础篇/12"><span>12 | 面向对象（下）：如何实现一个搜索引擎？</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/13"><span>13 | 搭建积木：Python 模块化</span></a></li><li><a href="/blog-backend/python核心技术与实战/02.基础篇/14"><span>14 | 答疑（一）：列表和元组的内部实现是怎样的？</span></a></li></ul></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇">03.进阶篇</a><ul><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/01"><span>15 | Python对象的比较、拷贝</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/02"><span>16 | 值传递，引用传递or其他，Python里参数是如何传递的？</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/03"><span>17 | 强大的装饰器</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/04"><span>18 | metaclass，是潘多拉魔盒还是阿拉丁神灯？</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/05"><span>19 | 深入理解迭代器和生成器</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/06"><span>20 | 揭秘 Python 协程</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/07"><span>21 | Python并发编程之Futures</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/08"><span>22 | 并发编程之Asyncio</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/09"><span>23 | 你真的懂Python GIL（全局解释器锁）吗？</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/10"><span>24 | 带你解析 Python 垃圾回收机制</span></a></li><li><a href="/blog-backend/python核心技术与实战/03.进阶篇/11"><span>25 | 答疑（二）：GIL与多线程是什么关系呢？</span></a></li></ul></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇">04.规范篇</a><ul><li><a href="/blog-backend/python核心技术与实战/04.规范篇/01"><span>26 | 活都来不及干了，还有空注意代码风格？！</span></a></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇/02"><span>27 | 学会合理分解代码，提高代码可读性</span></a></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇/03"><span>28 | 如何合理利用assert？</span></a></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇/04"><span>29 | 巧用上下文管理器和With语句精简代码</span></a></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇/05"><span>30 | 真的有必要写单元测试吗？</span></a></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇/06"><span>31 | pdb &amp; cProfile：调试和性能分析的法宝</span></a></li><li><a href="/blog-backend/python核心技术与实战/04.规范篇/07"><span>32 | 答疑（三）：如何选择合适的异常处理方式？</span></a></li></ul></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇">05.量化交易实战篇</a><ul><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/01"><span>33 | 带你初探量化世界</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/02"><span>34 | RESTful &amp; Socket：搭建交易执行层核心</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/03"><span>35 | RESTful &amp; Socket：行情数据对接和抓取</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/04"><span>36 | Pandas &amp; Numpy：策略与回测系统</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/05"><span>37 | Kafka &amp; ZMQ：自动化交易流水线</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/06"><span>38 | MySQL：日志和数据存储系统</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/07"><span>39 | Django：搭建监控平台</span></a></li><li><a href="/blog-backend/python核心技术与实战/05.量化交易实战篇/08"><span>40 | 总结：Python中的数据结构与算法全景</span></a></li></ul></li><li><a href="/blog-backend/python核心技术与实战/06.技术见闻与分享">06.技术见闻与分享</a><ul><li><a href="/blog-backend/python核心技术与实战/06.技术见闻与分享/01"><span>41 | 硅谷一线互联网公司的工作体验</span></a></li><li><a href="/blog-backend/python核心技术与实战/06.技术见闻与分享/02"><span>42 | 细数技术研发的注意事项</span></a></li><li><a href="/blog-backend/python核心技术与实战/06.技术见闻与分享/03"><span>加餐 | 带你上手SWIG：一份清晰好用的SWIG编程实践指南</span></a></li><li><a href="/blog-backend/python核心技术与实战/06.技术见闻与分享/04"><span>43 | Q&amp;A：聊一聊职业发展和选择</span></a></li></ul></li><li><a href="/blog-backend/python核心技术与实战/07.结束语">07.结束语</a><ul><li><a href="/blog-backend/python核心技术与实战/07.结束语/01"><span>结束语 | 技术之外的几点成长建议</span></a></li><li><a href="/blog-backend/python核心技术与实战/07.结束语/02"><span>结课测试 | 关于Python的这些知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-backend/python核心技术与实战/summary">python核心技术与实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="“高大上”的搜索引擎" data-depth="2"><a href="/blog-backend/python核心技术与实战/02.基础篇/12#高大上的搜索引擎"><span>“高大上”的搜索引擎</span></a></li><li title="Bag of Words 和 Inverted Index" data-depth="2"><a href="/blog-backend/python核心技术与实战/02.基础篇/12#bag-of-words-和-inverted-index"><span>Bag of Words 和 Inverted Index</span></a></li><li title="LRU 和多重继承" data-depth="2"><a href="/blog-backend/python核心技术与实战/02.基础篇/12#lru-和多重继承"><span>LRU 和多重继承</span></a></li><li title="总结" data-depth="2"><a href="/blog-backend/python核心技术与实战/02.基础篇/12#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-backend/python核心技术与实战/02.基础篇/12#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="12--面向对象下如何实现一个搜索引擎"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/12#12--面向对象下如何实现一个搜索引擎"><span class="icon icon-link"></span></a>12 | 面向对象（下）：如何实现一个搜索引擎？</h1><p>你好，我是景霄。这节课，我们来实现一个 Python 的搜索引擎（search engine）。</p><p>承接上文，今天这节课的主要目的是，带你模拟敏捷开发过程中的迭代开发流程，巩固面向对象的程序设计思想。</p><p>我们将从最简单最直接的搜索做起，一步步优化，这其中，我不会涉及到过多的超纲算法，但不可避免会介绍一些现代搜索引擎中的基础概念，例如语料（corpus）、倒序索引（inverted index）等。</p><p>如果你对这方面本身有些了解，自然可以轻松理解；即使你之前完全没接触过搜索引擎，也不用过分担心，我会力求简洁清晰，降低学习难度。同时，我希望你把更多的精力放在面向对象的建模思路上。</p><h2 id="高大上的搜索引擎"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/12#高大上的搜索引擎"><span class="icon icon-link"></span></a>“高大上”的搜索引擎</h2><p>引擎一词尤如其名，听起来非常酷炫。搜索引擎，则是新世纪初期互联网发展最重要的入口之一，依托搜索引擎，中国和美国分别诞生了百度、谷歌等巨型公司。</p><p>搜索引擎极大地方便了互联网生活，也成为上网必不可少的刚需工具。依托搜索引擎发展起来的互联网广告，则成了硅谷和中国巨头的核心商业模式；而搜索本身，也在持续进步着， Facebook 和微信也一直有意向在自家社交产品架设搜索平台。</p><p>关于搜索引擎的价值我不必多说了，今天我们主要来看一下搜索引擎的核心构成。</p><p>听Google的朋友说，他们入职培训的时候，有一门课程叫做 The life of a query，内容是讲用户在浏览器中键入一串文字，按下回车后发生了什么。今天我也按照这个思路，来简单介绍下。</p><p>我们知道，<strong>一个搜索引擎由搜索器、索引器、检索器和用户接口四个部分组成</strong>。</p><p>搜索器，通俗来讲就是我们常提到的爬虫（scrawler），它能在互联网上大量爬取各类网站的内容，送给索引器。索引器拿到网页和内容后，会对内容进行处理，形成索引（index），存储于内部的数据库等待检索。</p><p>最后的用户接口很好理解，是指网页和 App 前端界面，例如百度和谷歌的搜索页面。用户通过用户接口，向搜索引擎发出询问（query），询问解析后送达检索器；检索器高效检索后，再将结果返回给用户。</p><p>爬虫知识不是我们今天学习的重点，这里我就不做深入介绍了。我们假设搜索样本存在于本地磁盘上。</p><p>为了方便，我们只提供五个文件的检索，内容我放在了下面这段代码中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 1.txt</span></div><div class="token-line"><span class="token plain">    I have a dream that my four little children will one day live in a nation where they will not be judged by the color of their skin but by the content of their character. I have a dream today.</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 2.txt</span></div><div class="token-line"><span class="token plain">    I have a dream that one day down in Alabama, with its vicious racists, . . . one day right there in Alabama little black boys and black girls will be able to join hands with little white boys and white girls as sisters and brothers. I have a dream today.</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 3.txt</span></div><div class="token-line"><span class="token plain">    I have a dream that one day every valley shall be exalted, every hill and mountain shall be made low, the rough places will be made plain, and the crooked places will be made straight, and the glory of the Lord shall be revealed, and all flesh shall see it together.</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 4.txt</span></div><div class="token-line"><span class="token plain">    This is our hope. . . With this faith we will be able to hew out of the mountain of despair a stone of hope. With this faith we will be able to transform the jangling discords of our nation into a beautiful symphony of brotherhood. With this faith we will be able to work together, to pray together, to struggle together, to go to jail together, to stand up for freedom together, knowing that we will be free one day. . . .</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 5.txt</span></div><div class="token-line"><span class="token plain">    And when this happens, and when we allow freedom ring, when we let it ring from every village and every hamlet, from every state and every city, we will be able to speed up that day when all of God&#x27;s children, black men and white men, Jews and Gentiles, Protestants and Catholics, will be able to join hands and sing in the words of the old Negro spiritual: &quot;Free at last! Free at last! Thank God Almighty, we are free at last!&quot;</span></div></pre></div><p>我们先来定义 SearchEngineBase 基类。这里我先给出了具体的代码，你不必着急操作，还是那句话，跟着节奏慢慢学，再难的东西也可以啃得下来。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class SearchEngineBase(object):</span></div><div class="token-line"><span class="token plain">        def __init__(self):</span></div><div class="token-line"><span class="token plain">            pass</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        def add_corpus(self, file_path):</span></div><div class="token-line"><span class="token plain">            with open(file_path, &#x27;r&#x27;) as fin:</span></div><div class="token-line"><span class="token plain">                text = fin.read()</span></div><div class="token-line"><span class="token plain">            self.process_corpus(file_path, text)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        def process_corpus(self, id, text):</span></div><div class="token-line"><span class="token plain">            raise Exception(&#x27;process_corpus not implemented.&#x27;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        def search(self, query):</span></div><div class="token-line"><span class="token plain">            raise Exception(&#x27;search not implemented.&#x27;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    def main(search_engine):</span></div><div class="token-line"><span class="token plain">        for file_path in [&#x27;1.txt&#x27;, &#x27;2.txt&#x27;, &#x27;3.txt&#x27;, &#x27;4.txt&#x27;, &#x27;5.txt&#x27;]:</span></div><div class="token-line"><span class="token plain">            search_engine.add_corpus(file_path)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        while True:</span></div><div class="token-line"><span class="token plain">            query = input()</span></div><div class="token-line"><span class="token plain">            results = search_engine.search(query)</span></div><div class="token-line"><span class="token plain">            print(&#x27;found {} result(s):&#x27;.format(len(results)))</span></div><div class="token-line"><span class="token plain">            for result in results:</span></div><div class="token-line"><span class="token plain">                print(result)</span></div></pre></div><p>SearchEngineBase 可以被继承，继承的类分别代表不同的算法引擎。每一个引擎都应该实现 process_corpus()和search()两个函数，对应我们刚刚提到的索引器和检索器。main()函数提供搜索器和用户接口，于是一个简单的包装界面就有了。</p><p>具体来看这段代码，其中，</p><ul><li>add_corpus() 函数负责读取文件内容，将文件路径作为 ID，连同内容一起送到 process_corpus 中。</li><li>process_corpus 需要对内容进行处理，然后文件路径为 ID ，将处理后的内容存下来。处理后的内容，就叫做索引（index）。</li><li>search 则给定一个询问，处理询问，再通过索引检索，然后返回。</li></ul><p>好，理解这些概念后，接下来，我们实现一个最基本的可以工作的搜索引擎，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class SimpleEngine(SearchEngineBase):</span></div><div class="token-line"><span class="token plain">        def __init__(self):</span></div><div class="token-line"><span class="token plain">            super(SimpleEngine, self).__init__()</span></div><div class="token-line"><span class="token plain">            self.__id_to_texts = {}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        def process_corpus(self, id, text):</span></div><div class="token-line"><span class="token plain">            self.__id_to_texts[id] = text</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        def search(self, query):</span></div><div class="token-line"><span class="token plain">            results = []</span></div><div class="token-line"><span class="token plain">            for id, text in self.__id_to_texts.items():</span></div><div class="token-line"><span class="token plain">                if query in text:</span></div><div class="token-line"><span class="token plain">                    results.append(id)</span></div><div class="token-line"><span class="token plain">            return results</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    search_engine = SimpleEngine()</span></div><div class="token-line"><span class="token plain">    main(search_engine)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ########## 输出 ##########</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    simple</span></div><div class="token-line"><span class="token plain">    found 0 result(s):</span></div><div class="token-line"><span class="token plain">    little</span></div><div class="token-line"><span class="token plain">    found 2 result(s):</span></div><div class="token-line"><span class="token plain">    1.txt</span></div><div class="token-line"><span class="token plain">    2.txt</span></div></pre></div><p>你可能很惊讶，只需要短短十来行代码居然就可以了吗？</p><p>没错，正是如此，这段代码我们拆开来看一下：</p><p>SimpleEngine 实现了一个继承 SearchEngineBase 的子类，继承并实现了 process_corpus 和 search 接口，同时，也顺手继承了 add_corpus 函数（当然你想重写也是可行的），因此我们可以在 main() 函数中直接调取。</p><p>在我们新的构造函数中，<code>self.__id_to_texts = <!-- -->{<!-- -->}</code> 初始化了自己的私有变量，也就是这个用来存储文件名到文件内容的字典。</p><p>process_corpus() 函数则非常直白地将文件内容插入到字典中。这里注意，ID 需要是唯一的，不然相同ID的新内容会覆盖掉旧的内容。</p><p>search 直接枚举字典，从中找到要搜索的字符串。如果能够找到，则将 ID 放到结果列表中，最后返回。</p><p>你看，是不是非常简单呢？这个过程始终贯穿着面向对象的思想，这里我为你梳理成了几个问题，你可以自己思考一下，当成是一个小复习。</p><ul><li>现在你对父类子类的构造函数调用顺序和方法应该更清楚了吧？</li><li>继承的时候，函数是如何重写的？</li><li>基类是如何充当接口作用的（你可以自行删掉子类中的重写函数，抑或是修改一下函数的参数，看一下会报什么错）？</li><li>方法和变量之间又如何衔接起来的呢？</li></ul><p>好的，我们重新回到搜索引擎这个话题。</p><p>相信你也能看得出来，这种实现方式简单，但显然是一种很低效的方式：每次索引后需要占用大量空间，因为索引函数并没有做任何事情；每次检索需要占用大量时间，因为所有索引库的文件都要被重新搜索一遍。如果把语料的信息量视为 n，那么这里的时间复杂度和空间复杂度都应该是 O(n) 级别的。</p><p>而且，还有一个问题：这里的 query 只能是一个词，或者是连起来的几个词。如果你想要搜索多个词，它们又分散在文章的不同位置，我们的简单引擎就无能为力了。</p><p>这时应该怎么优化呢？</p><p>最直接的一个想法，就是把语料分词，看成一个个的词汇，这样就只需要对每篇文章存储它所有词汇的 set 即可。根据齐夫定律（Zipf’s law，<a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Zipf%27s_law">https://en.wikipedia.org/wiki/Zipf%27s_law<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），在自然语言的语料库里，一个单词出现的频率与它在频率表里的排名成反比，呈现幂律分布。因此，语料分词的做法可以大大提升我们的存储和搜索效率。</p><p>那具体该如何实现呢？</p><h2 id="bag-of-words-和-inverted-index"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/12#bag-of-words-和-inverted-index"><span class="icon icon-link"></span></a>Bag of Words 和 Inverted Index</h2><p>我们先来实现一个名叫 Bag of Words 的搜索模型。请看下面的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import re</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    class BOWEngine(SearchEngineBase):</span></div><div class="token-line"><span class="token plain">        def __init__(self):</span></div><div class="token-line"><span class="token plain">            super(BOWEngine, self).__init__()</span></div><div class="token-line"><span class="token plain">            self.__id_to_words = {}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        def process_corpus(self, id, text):</span></div><div class="token-line"><span class="token plain">            self.__id_to_words[id] = self.parse_text_to_words(text)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        def search(self, query):</span></div><div class="token-line"><span class="token plain">            query_words = self.parse_text_to_words(query)</span></div><div class="token-line"><span class="token plain">            results = []</span></div><div class="token-line"><span class="token plain">            for id, words in self.__id_to_words.items():</span></div><div class="token-line"><span class="token plain">                if self.query_match(query_words, words):</span></div><div class="token-line"><span class="token plain">                    results.append(id)</span></div><div class="token-line"><span class="token plain">            return results</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @staticmethod</span></div><div class="token-line"><span class="token plain">        def query_match(query_words, words):</span></div><div class="token-line"><span class="token plain">            for query_word in query_words:</span></div><div class="token-line"><span class="token plain">                if query_word not in words:</span></div><div class="token-line"><span class="token plain">                    return False</span></div><div class="token-line"><span class="token plain">            return True</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @staticmethod</span></div><div class="token-line"><span class="token plain">        def parse_text_to_words(text):</span></div><div class="token-line"><span class="token plain">            # 使用正则表达式去除标点符号和换行符</span></div><div class="token-line"><span class="token plain">            text = re.sub(r&#x27;[^\w ]&#x27;, &#x27; &#x27;, text)</span></div><div class="token-line"><span class="token plain">            # 转为小写</span></div><div class="token-line"><span class="token plain">            text = text.lower()</span></div><div class="token-line"><span class="token plain">            # 生成所有单词的列表</span></div><div class="token-line"><span class="token plain">            word_list = text.split(&#x27; &#x27;)</span></div><div class="token-line"><span class="token plain">            # 去除空白单词</span></div><div class="token-line"><span class="token plain">            word_list = filter(None, word_list)</span></div><div class="token-line"><span class="token plain">            # 返回单词的 set</span></div><div class="token-line"><span class="token plain">            return set(word_list)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    search_engine = BOWEngine()</span></div><div class="token-line"><span class="token plain">    main(search_engine)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ########## 输出 ##########</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    i have a dream</span></div><div class="token-line"><span class="token plain">    found 3 result(s):</span></div><div class="token-line"><span class="token plain">    1.txt</span></div><div class="token-line"><span class="token plain">    2.txt</span></div><div class="token-line"><span class="token plain">    3.txt</span></div><div class="token-line"><span class="token plain">    freedom children</span></div><div class="token-line"><span class="token plain">    found 1 result(s):</span></div><div class="token-line"><span class="token plain">    5.txt</span></div></pre></div><p>你应该发现，代码开始变得稍微复杂些了。</p><p>这里我们先来理解一个概念，BOW Model，即 <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Bag-of-words_model">Bag of Words Model<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，中文叫做词袋模型。这是 NLP 领域最常见最简单的模型之一。</p><p>假设一个文本，不考虑语法、句法、段落，也不考虑词汇出现的顺序，只将这个文本看成这些词汇的集合。于是相应的，我们把 id_to_texts 替换成 id_to_words，这样就只需要存这些单词，而不是全部文章，也不需要考虑顺序。</p><p>其中，process_corpus() 函数调用类静态函数 parse_text_to_words，将文章打碎形成词袋，放入 set 之后再放到字典中。</p><p>search() 函数则稍微复杂一些。这里我们假设，想得到的结果，是所有的搜索关键词都要出现在同一篇文章中。那么，我们需要同样打碎 query 得到一个 set，然后把 set 中的每一个词，和我们的索引中每一篇文章进行核对，看一下要找的词是否在其中。而这个过程由静态函数 query_match 负责。</p><p>你可以回顾一下上节课学到的静态函数，我们看到，这两个函数都是没有状态的，它们不涉及对象的私有变量（没有 self 作为参数），相同的输入能够得到完全相同的输出结果。因此设置为静态，可以方便其他的类来使用。</p><p>可是，即使这样做，每次查询时依然需要遍历所有ID，虽然比起 Simple 模型已经节约了大量时间，但是互联网上有上亿个页面，每次都全部遍历的代价还是太大了。到这时，又该如何优化呢？</p><p>你可能想到了，我们每次查询的 query 的单词量不会很多，一般也就几个、最多十几个的样子。那可不可以从这里下手呢？</p><p>再有，词袋模型并不考虑单词间的顺序，但有些人希望单词按顺序出现，或者希望搜索的单词在文中离得近一些，这种情况下词袋模型现任就无能为力了。</p><p>针对这两点，我们还能做得更好吗？显然是可以的，请看接下来的这段代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import re</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    class BOWInvertedIndexEngine(SearchEngineBase):</span></div><div class="token-line"><span class="token plain">        def __init__(self):</span></div><div class="token-line"><span class="token plain">            super(BOWInvertedIndexEngine, self).__init__()</span></div><div class="token-line"><span class="token plain">            self.inverted_index = {}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        def process_corpus(self, id, text):</span></div><div class="token-line"><span class="token plain">            words = self.parse_text_to_words(text)</span></div><div class="token-line"><span class="token plain">            for word in words:</span></div><div class="token-line"><span class="token plain">                if word not in self.inverted_index:</span></div><div class="token-line"><span class="token plain">                    self.inverted_index[word] = []</span></div><div class="token-line"><span class="token plain">                self.inverted_index[word].append(id)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        def search(self, query):</span></div><div class="token-line"><span class="token plain">            query_words = list(self.parse_text_to_words(query))</span></div><div class="token-line"><span class="token plain">            query_words_index = list()</span></div><div class="token-line"><span class="token plain">            for query_word in query_words:</span></div><div class="token-line"><span class="token plain">                query_words_index.append(0)</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            # 如果某一个查询单词的倒序索引为空，我们就立刻返回</span></div><div class="token-line"><span class="token plain">            for query_word in query_words:</span></div><div class="token-line"><span class="token plain">                if query_word not in self.inverted_index:</span></div><div class="token-line"><span class="token plain">                    return []</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            result = []</span></div><div class="token-line"><span class="token plain">            while True:</span></div><div class="token-line"><span class="token plain">                </span></div><div class="token-line"><span class="token plain">                # 首先，获得当前状态下所有倒序索引的 index</span></div><div class="token-line"><span class="token plain">                current_ids = []</span></div><div class="token-line"><span class="token plain">                </span></div><div class="token-line"><span class="token plain">                for idx, query_word in enumerate(query_words):</span></div><div class="token-line"><span class="token plain">                    current_index = query_words_index[idx]</span></div><div class="token-line"><span class="token plain">                    current_inverted_list = self.inverted_index[query_word]</span></div><div class="token-line"><span class="token plain">                    </span></div><div class="token-line"><span class="token plain">                    # 已经遍历到了某一个倒序索引的末尾，结束 search</span></div><div class="token-line"><span class="token plain">                    if current_index &gt;= len(current_inverted_list):</span></div><div class="token-line"><span class="token plain">                        return result</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                    current_ids.append(current_inverted_list[current_index])</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                # 然后，如果 current_ids 的所有元素都一样，那么表明这个单词在这个元素对应的文档中都出现了</span></div><div class="token-line"><span class="token plain">                if all(x == current_ids[0] for x in current_ids):</span></div><div class="token-line"><span class="token plain">                    result.append(current_ids[0])</span></div><div class="token-line"><span class="token plain">                    query_words_index = [x + 1 for x in query_words_index]</span></div><div class="token-line"><span class="token plain">                    continue</span></div><div class="token-line"><span class="token plain">                </span></div><div class="token-line"><span class="token plain">                # 如果不是，我们就把最小的元素加一</span></div><div class="token-line"><span class="token plain">                min_val = min(current_ids)</span></div><div class="token-line"><span class="token plain">                min_val_pos = current_ids.index(min_val)</span></div><div class="token-line"><span class="token plain">                query_words_index[min_val_pos] += 1</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @staticmethod</span></div><div class="token-line"><span class="token plain">        def parse_text_to_words(text):</span></div><div class="token-line"><span class="token plain">            # 使用正则表达式去除标点符号和换行符</span></div><div class="token-line"><span class="token plain">            text = re.sub(r&#x27;[^\w ]&#x27;, &#x27; &#x27;, text)</span></div><div class="token-line"><span class="token plain">            # 转为小写</span></div><div class="token-line"><span class="token plain">            text = text.lower()</span></div><div class="token-line"><span class="token plain">            # 生成所有单词的列表</span></div><div class="token-line"><span class="token plain">            word_list = text.split(&#x27; &#x27;)</span></div><div class="token-line"><span class="token plain">            # 去除空白单词</span></div><div class="token-line"><span class="token plain">            word_list = filter(None, word_list)</span></div><div class="token-line"><span class="token plain">            # 返回单词的 set</span></div><div class="token-line"><span class="token plain">            return set(word_list)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    search_engine = BOWInvertedIndexEngine()</span></div><div class="token-line"><span class="token plain">    main(search_engine)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ########## 输出 ##########</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    little</span></div><div class="token-line"><span class="token plain">    found 2 result(s):</span></div><div class="token-line"><span class="token plain">    1.txt</span></div><div class="token-line"><span class="token plain">    2.txt</span></div><div class="token-line"><span class="token plain">    little vicious</span></div><div class="token-line"><span class="token plain">    found 1 result(s):</span></div><div class="token-line"><span class="token plain">    2.txt</span></div></pre></div><p>首先我要强调一下，<strong>这次的算法并不需要你完全理解</strong>，这里的实现有一些超出了本章知识点。但希望你不要因此退缩，这个例子会告诉你，面向对象编程是如何把算法复杂性隔离开来，而保留接口和其他的代码不变。</p><p>我们接着来看这段代码。你可以看到，新模型继续使用之前的接口，仍然只在 <code>__init__()</code>、<code>process_corpus()</code>和<code>search()</code>三个函数进行修改。</p><p>这其实也是大公司里团队协作的一种方式，<strong>在合理的分层设计后，每一层的逻辑只需要处理好分内的事情即可</strong>。在迭代升级我们的搜索引擎内核时， main 函数、用户接口没有任何改变。当然，如果公司招了新的前端工程师，要对用户接口部分进行修改，新人也不需要过分担心后台的事情，只要做好数据交互就可以了。</p><p>继续看代码，你可能注意到了开头的Inverted Index。Inverted Index Model，即倒序索引，是非常有名的搜索引擎方法，接下来我简单介绍一下。</p><p>倒序索引，一如其名，也就是说这次反过来，我们保留的是 word -&gt; id 的字典。于是情况就豁然开朗了，在 search 时，我们只需要把想要的 query_word 的几个倒序索引单独拎出来，然后从这几个列表中找共有的元素，那些共有的元素，即 ID，就是我们想要的查询结果。这样，我们就避免了将所有的 index 过一遍的尴尬。</p><p>process_corpus 建立倒序索引。注意，这里的代码都是非常精简的。在工业界领域，需要一个 unique ID 生成器，来对每一篇文章标记上不同的 ID，倒序索引也应该按照这个 unique_id 来进行排序。</p><p>至于search() 函数，你大概了解它做的事情即可。它会根据 query_words 拿到所有的倒序索引，如果拿不到，就表示有的 query word 不存在于任何文章中，直接返回空；拿到之后，运行一个“合并K个有序数组”的算法，从中拿到我们想要的 ID，并返回。</p><blockquote><p>注意，这里用到的算法并不是最优的，最优的写法需要用最小堆来存储 index。这是一道有名的 leetcode hard 题，有兴趣请参考：<a target="_blank" rel="noopener noreferrer" href="https://blog.csdn.net/qqxx6661/article/details/77814794">https://blog.csdn.net/qqxx6661/article/details/77814794<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）</p></blockquote><p>遍历的问题解决了，那第二个问题，如果我们想要实现搜索单词按顺序出现，或者希望搜索的单词在文中离得近一些呢？</p><p>我们需要在 Inverted Index 上，对于每篇文章也保留单词的位置信息，这样一来，在合并操作的时候处理一下就可以了。</p><p>倒序索引我就介绍到这里了，如果你感兴趣可以自行查阅资料。还是那句话，我们的重点是面向对象的抽象，别忘了体会这一思想。</p><h2 id="lru-和多重继承"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/12#lru-和多重继承"><span class="icon icon-link"></span></a>LRU 和多重继承</h2><p>到这一步，终于，你的搜索引擎上线了，有了越来越多的访问量（QPS）。欣喜骄傲的同时，你却发现服务器有些“不堪重负”了。经过一段时间的调研，你发现大量重复性搜索占据了 90% 以上的流量，于是，你想到了一个大杀器——给搜索引擎加一个缓存。</p><p>所以，最后这部分，我就来讲讲缓存和多重继承的内容。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import pylru</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    class LRUCache(object):</span></div><div class="token-line"><span class="token plain">        def __init__(self, size=32):</span></div><div class="token-line"><span class="token plain">            self.cache = pylru.lrucache(size)</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        def has(self, key):</span></div><div class="token-line"><span class="token plain">            return key in self.cache</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        def get(self, key):</span></div><div class="token-line"><span class="token plain">            return self.cache[key]</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        def set(self, key, value):</span></div><div class="token-line"><span class="token plain">            self.cache[key] = value</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    class BOWInvertedIndexEngineWithCache(BOWInvertedIndexEngine, LRUCache):</span></div><div class="token-line"><span class="token plain">        def __init__(self):</span></div><div class="token-line"><span class="token plain">            super(BOWInvertedIndexEngineWithCache, self).__init__()</span></div><div class="token-line"><span class="token plain">            LRUCache.__init__(self)</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        def search(self, query):</span></div><div class="token-line"><span class="token plain">            if self.has(query):</span></div><div class="token-line"><span class="token plain">                print(&#x27;cache hit!&#x27;)</span></div><div class="token-line"><span class="token plain">                return self.get(query)</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            result = super(BOWInvertedIndexEngineWithCache, self).search(query)</span></div><div class="token-line"><span class="token plain">            self.set(query, result)</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            return result</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    search_engine = BOWInvertedIndexEngineWithCache()</span></div><div class="token-line"><span class="token plain">    main(search_engine)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ########## 输出 ##########</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    little</span></div><div class="token-line"><span class="token plain">    found 2 result(s):</span></div><div class="token-line"><span class="token plain">    1.txt</span></div><div class="token-line"><span class="token plain">    2.txt</span></div><div class="token-line"><span class="token plain">    little</span></div><div class="token-line"><span class="token plain">    cache hit!</span></div><div class="token-line"><span class="token plain">    found 2 result(s):</span></div><div class="token-line"><span class="token plain">    1.txt</span></div><div class="token-line"><span class="token plain">    2.txt</span></div></pre></div><p>它的代码很简单，LRUCache 定义了一个缓存类，你可以通过继承这个类来调用其方法。LRU 缓存是一种很经典的缓存（同时，LRU的实现也是硅谷大厂常考的算法面试题，这里为了简单，我直接使用 pylru 这个包），它符合自然界的局部性原理，可以保留最近使用过的对象，而逐渐淘汰掉很久没有被用过的对象。</p><p>因此，这里的缓存使用起来也很简单，调用 has() 函数判断是否在缓存中，如果在，调用 get 函数直接返回结果；如果不在，送入后台计算结果，然后再塞入缓存。</p><p>我们可以看到，BOWInvertedIndexEngineWithCache 类，多重继承了两个类。首先，你需要注意的是构造函数（上节课的思考题，你思考了吗？）。多重继承有两种初始化方法，我们分别来看一下。</p><p>第一种方法，用下面这行代码，直接初始化该类的第一个父类：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">super(BOWInvertedIndexEngineWithCache, self).__init__()</span></div></pre></div><p>不过使用这种方法时，要求继承链的最顶层父类必须要继承 object。</p><p>第二种方法，对于多重继承，如果有多个构造函数需要调用， 我们必须用传统的方法<code>LRUCache.__init__(self)</code> 。</p><p>其次，你应该注意，search() 函数被子类 BOWInvertedIndexEngineWithCache 再次重载，但是我还需要调用 BOWInvertedIndexEngine 的 search() 函数，这时该怎么办呢？请看下面这行代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">super(BOWInvertedIndexEngineWithCache, self).search(query)</span></div></pre></div><p>我们可以强行调用被覆盖的父类的函数。</p><p>这样一来，我们就简洁地实现了缓存，而且还是在不影响 BOWInvertedIndexEngine 代码的情况下。这部分内容希望你多读几遍，自己揣摩清楚，通过这个例子多多体会继承的优势。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/12#总结"><span class="icon icon-link"></span></a>总结</h2><p>今天这节课是面向对象的实战应用，相比起前面的理论知识，内容其实不那么友好。不过，若你能静下心来，仔细学习，理清楚整个过程的要点，对你理解面向对象必将有所裨益。比如，你可以根据下面两个问题，来检验今天这节课的收获。</p><ul><li>你能把这节课所有的类的属性和函数抽取出来，自己在纸上画一遍继承关系吗？</li><li>迭代开发流程是怎样的？</li></ul><p>其实于我而言，通过构造搜索引擎这么一个例子来讲面向对象，也是颇费了一番功夫。这其中虽然涉及一些搜索引擎的专业知识和算法，但篇幅有限，也只能算是抛砖引玉，你若有所收获，我便欣然满足。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-backend/python核心技术与实战/02.基础篇/12#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>最后给你留一道思考题。私有变量能被继承吗？如果不能，你想继承应该怎么去做呢？欢迎留言与我分享、讨论，也欢迎你把这篇文章分享给你的同事、朋友，一起交流与进步。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/python核心技术与实战/02.基础篇/12.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
