<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>27 | 关于高水位和Leader Epoch的讨论 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/kafka核心技术与实战/05.深入kafka内核/05" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a aria-current="page" class="active" href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a aria-current="page" class="active" href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心技术与实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-backend/kafka核心技术与实战/01.开篇词/01"><span>开篇词 | 为什么要学习Kafka？</span></a></li></ul></li><li><a href="/blog-backend/kafka核心技术与实战/02.kafka入门">02.Kafka入门</a><ul><li><a href="/blog-backend/kafka核心技术与实战/02.kafka入门/01"><span>01 |  消息引擎系统ABC</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/02.kafka入门/02"><span>02 | 一篇文章带你快速搞定Kafka术语</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/02.kafka入门/03"><span>03 | Kafka只是消息引擎系统吗？</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/02.kafka入门/04"><span>04 | 我应该选择哪种Kafka？</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/02.kafka入门/05"><span>05 | 聊聊Kafka的版本号</span></a></li></ul></li><li><a href="/blog-backend/kafka核心技术与实战/03.kafka的基本使用">03.Kafka的基本使用</a><ul><li><a href="/blog-backend/kafka核心技术与实战/03.kafka的基本使用/01"><span>06 | Kafka线上集群部署方案怎么做？</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/03.kafka的基本使用/02"><span>07 | 最最最重要的集群参数配置（上）</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/03.kafka的基本使用/03"><span>08 | 最最最重要的集群参数配置（下）</span></a></li></ul></li><li><a href="/blog-backend/kafka核心技术与实战/04.客户端实践及原理剖析">04.客户端实践及原理剖析</a><ul><li><a href="/blog-backend/kafka核心技术与实战/04.客户端实践及原理剖析/01"><span>09 |  生产者消息分区机制原理剖析</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/04.客户端实践及原理剖析/02"><span>10 | 生产者压缩算法面面观</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/04.客户端实践及原理剖析/03"><span>11 | 无消息丢失配置怎么实现？</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/04.客户端实践及原理剖析/04"><span>12 | 客户端都有哪些不常见但是很高级的功能？</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/04.客户端实践及原理剖析/05"><span>13 |  Java生产者是如何管理TCP连接的？</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/04.客户端实践及原理剖析/06"><span>14 | 幂等生产者和事务生产者是一回事吗？</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/04.客户端实践及原理剖析/07"><span>15 | 消费者组到底是什么？</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/04.客户端实践及原理剖析/08"><span>16 | 揭开神秘的“位移主题”面纱</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/04.客户端实践及原理剖析/09"><span>17 | 消费者组重平衡能避免吗？</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/04.客户端实践及原理剖析/10"><span>18 | Kafka中位移提交那些事儿</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/04.客户端实践及原理剖析/11"><span>19 | CommitFailedException异常怎么处理？</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/04.客户端实践及原理剖析/12"><span>20 | 多线程开发消费者实例</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/04.客户端实践及原理剖析/13"><span>21 | Java 消费者是如何管理TCP连接的?</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/04.客户端实践及原理剖析/14"><span>22 | 消费者组消费进度监控都怎么实现？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/kafka核心技术与实战/05.深入kafka内核">05.深入Kafka内核</a><ul><li><a href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/01"><span>23 | Kafka副本机制详解</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/02"><span>24 | 请求是怎么被处理的？</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/03"><span>25 | 消费者组重平衡全流程解析</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/04"><span>26 | 你一定不能错过的Kafka控制器</span></a></li><li><a aria-current="page" class="active" href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/05"><span>27 | 关于高水位和Leader Epoch的讨论</span></a></li></ul></li><li><a href="/blog-backend/kafka核心技术与实战/06.管理与监控">06.管理与监控</a><ul><li><a href="/blog-backend/kafka核心技术与实战/06.管理与监控/01"><span>28 | 主题管理知多少?</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/06.管理与监控/02"><span>29 | Kafka动态配置了解下？</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/06.管理与监控/03"><span>30 | 怎么重设消费者组位移？</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/06.管理与监控/04"><span>31 | 常见工具脚本大汇总</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/06.管理与监控/05"><span>32 | KafkaAdminClient：Kafka的运维利器</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/06.管理与监控/06"><span>33 | Kafka认证机制用哪家？</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/06.管理与监控/07"><span>34 | 云环境下的授权该怎么做？</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/06.管理与监控/08"><span>35 | 跨集群备份解决方案MirrorMaker</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/06.管理与监控/09"><span>36 | 你应该怎么监控Kafka？</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/06.管理与监控/10"><span>37 | 主流的Kafka监控框架</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/06.管理与监控/11"><span>38 | 调优Kafka，你做到了吗？</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/06.管理与监控/12"><span>39 | 从0搭建基于Kafka的企业级实时日志流处理平台</span></a></li></ul></li><li><a href="/blog-backend/kafka核心技术与实战/07.高级kafka应用之流处理">07.高级Kafka应用之流处理</a><ul><li><a href="/blog-backend/kafka核心技术与实战/07.高级kafka应用之流处理/01"><span>40 | Kafka Streams与其他流处理平台的差异在哪里？</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/07.高级kafka应用之流处理/02"><span>41 | Kafka Streams DSL开发实例</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/07.高级kafka应用之流处理/03"><span>42 | Kafka Streams在金融领域的应用</span></a></li></ul></li><li><a href="/blog-backend/kafka核心技术与实战/08.特别放送">08.特别放送</a><ul><li><a href="/blog-backend/kafka核心技术与实战/08.特别放送/01"><span>加餐 | 搭建开发环境、阅读源码方法、经典学习资料大揭秘</span></a></li><li><a href="/blog-backend/kafka核心技术与实战/08.特别放送/02"><span>用户故事 | 黄云：行百里者半九十</span></a></li></ul></li><li><a href="/blog-backend/kafka核心技术与实战/09.结束语">09.结束语</a><ul><li><a href="/blog-backend/kafka核心技术与实战/09.结束语/01"><span>结束语 | 以梦为马，莫负韶华！</span></a></li></ul></li><li><a href="/blog-backend/kafka核心技术与实战/10.结课测试">10.结课测试</a><ul><li><a href="/blog-backend/kafka核心技术与实战/10.结课测试/01"><span>期末测试 | 这些Kafka核心要点，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-backend/kafka核心技术与实战/summary">kafka核心技术与实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="什么是高水位？" data-depth="2"><a href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/05#什么是高水位"><span>什么是高水位？</span></a></li><li title="高水位的作用" data-depth="2"><a href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/05#高水位的作用"><span>高水位的作用</span></a></li><li title="高水位更新机制" data-depth="2"><a href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/05#高水位更新机制"><span>高水位更新机制</span></a></li><li title="副本同步机制解析" data-depth="2"><a href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/05#副本同步机制解析"><span>副本同步机制解析</span></a></li><li title="Leader Epoch登场" data-depth="2"><a href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/05#leader-epoch登场"><span>Leader Epoch登场</span></a></li><li title="小结" data-depth="2"><a href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/05#小结"><span>小结</span></a></li><li title="开放讨论" data-depth="2"><a href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/05#开放讨论"><span>开放讨论</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="27--关于高水位和leader-epoch的讨论"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/05#27--关于高水位和leader-epoch的讨论"><span class="icon icon-link"></span></a>27 | 关于高水位和Leader Epoch的讨论</h1><p>你好，我是胡夕。今天我要和你分享的主题是：Kafka中的高水位和Leader Epoch机制。</p><p>你可能听说过高水位（High Watermark），但不一定耳闻过Leader Epoch。前者是Kafka中非常重要的概念，而后者是社区在0.11版本中新推出的，主要是为了弥补高水位机制的一些缺陷。鉴于高水位机制在Kafka中举足轻重，而且深受各路面试官的喜爱，今天我们就来重点说说高水位。当然，我们也会花一部分时间来讨论Leader Epoch以及它的角色定位。</p><h2 id="什么是高水位"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/05#什么是高水位"><span class="icon icon-link"></span></a>什么是高水位？</h2><p>首先，我们要明确一下基本的定义：什么是高水位？或者说什么是水位？水位一词多用于流式处理领域，比如，Spark Streaming或Flink框架中都有水位的概念。教科书中关于水位的经典定义通常是这样的：</p><blockquote><p>在时刻T，任意创建时间（Event Time）为T’，且T’≤T的所有事件都已经到达或被观测到，那么T就被定义为水位。</p></blockquote><p>“Streaming System”一书则是这样表述水位的：</p><blockquote><p>水位是一个单调增加且表征最早未完成工作（oldest work not yet completed）的时间戳。</p></blockquote><p>为了帮助你更好地理解水位，我借助这本书里的一张图来说明一下。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage84778426888d04e1e9917619829b7e3de877.5eef58fa.png" alt=""/></p><p>图中标注“Completed”的蓝色部分代表已完成的工作，标注“In-Flight”的红色部分代表正在进行中的工作，两者的边界就是水位线。</p><p>在Kafka的世界中，水位的概念有一点不同。Kafka的水位不是时间戳，更与时间无关。它是和位置信息绑定的，具体来说，它是用消息位移来表征的。另外，Kafka源码使用的表述是高水位，因此，今天我也会统一使用“高水位”或它的缩写HW来进行讨论。值得注意的是，Kafka中也有低水位（Low Watermark），它是与Kafka删除消息相关联的概念，与今天我们要讨论的内容没有太多联系，我就不展开讲了。</p><h2 id="高水位的作用"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/05#高水位的作用"><span class="icon icon-link"></span></a>高水位的作用</h2><p>在Kafka中，高水位的作用主要有2个。</p><ol><li>定义消息可见性，即用来标识分区下的哪些消息是可以被消费者消费的。</li><li>帮助Kafka完成副本同步。</li></ol><p>下面这张图展示了多个与高水位相关的Kafka术语。我来详细解释一下图中的内容，同时澄清一些常见的误区。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage45db453ff803a31aa030feedba27aed17ddb.42cdd9d9.jpg" alt=""/></p><p>我们假设这是某个分区Leader副本的高水位图。首先，请你注意图中的“已提交消息”和“未提交消息”。我们之前在专栏<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/102931">第11讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>谈到Kafka持久性保障的时候，特意对两者进行了区分。现在，我借用高水位再次强调一下。在分区高水位以下的消息被认为是已提交消息，反之就是未提交消息。消费者只能消费已提交消息，即图中位移小于8的所有消息。注意，这里我们不讨论Kafka事务，因为事务机制会影响消费者所能看到的消息的范围，它不只是简单依赖高水位来判断。它依靠一个名为LSO（Log Stable Offset）的位移值来判断事务型消费者的可见性。</p><p>另外，需要关注的是，<strong>位移值等于高水位的消息也属于未提交消息。也就是说，高水位上的消息是不能被消费者消费的</strong>。</p><p>图中还有一个日志末端位移的概念，即Log End Offset，简写是LEO。它表示副本写入下一条消息的位移值。注意，数字15所在的方框是虚线，这就说明，这个副本当前只有15条消息，位移值是从0到14，下一条新消息的位移是15。显然，介于高水位和LEO之间的消息就属于未提交消息。这也从侧面告诉了我们一个重要的事实，那就是：<strong>同一个副本对象，其高水位值不会大于LEO值</strong>。</p><p><strong>高水位和LEO是副本对象的两个重要属性</strong>。Kafka所有副本都有对应的高水位和LEO值，而不仅仅是Leader副本。只不过Leader副本比较特殊，Kafka使用Leader副本的高水位来定义所在分区的高水位。换句话说，<strong>分区的高水位就是其Leader副本的高水位</strong>。</p><h2 id="高水位更新机制"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/05#高水位更新机制"><span class="icon icon-link"></span></a>高水位更新机制</h2><p>现在，我们知道了每个副本对象都保存了一组高水位值和LEO值，但实际上，在Leader副本所在的Broker上，还保存了其他Follower副本的LEO值。我们一起来看看下面这张图。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage8bde8b1b8474a568e2ae40bf36bb03ca81de.c3274ecc.jpg" alt=""/></p><p>在这张图中，我们可以看到，Broker 0上保存了某分区的Leader副本和所有Follower副本的LEO值，而Broker 1上仅仅保存了该分区的某个Follower副本。Kafka把Broker 0上保存的这些Follower副本又称为<strong>远程副本</strong>（Remote Replica）。Kafka副本机制在运行过程中，会更新Broker 1上Follower副本的高水位和LEO值，同时也会更新Broker 0上Leader副本的高水位和LEO以及所有远程副本的LEO，但它不会更新远程副本的高水位值，也就是我在图中标记为灰色的部分。</p><p>为什么要在Broker 0上保存这些远程副本呢？其实，它们的主要作用是，<strong>帮助Leader副本确定其高水位，也就是分区高水位</strong>。</p><p>为了帮助你更好地记忆这些值被更新的时机，我做了一张表格。只有搞清楚了更新机制，我们才能开始讨论Kafka副本机制的原理，以及它是如何使用高水位来执行副本消息同步的。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimaged641d6d2f98c611e06ffb85f01031ca79b41.7264f54e.jpg" alt=""/></p><p>在这里，我稍微解释一下，什么叫与Leader副本保持同步。判断的条件有两个。</p><ol><li>该远程Follower副本在ISR中。</li><li>该远程Follower副本LEO值落后于Leader副本LEO值的时间，不超过Broker端参数replica.lag.time.max.ms的值。如果使用默认值的话，就是不超过10秒。</li></ol><p>乍一看，这两个条件好像是一回事，因为目前某个副本能否进入ISR就是靠第2个条件判断的。但有些时候，会发生这样的情况：即Follower副本已经“追上”了Leader的进度，却不在ISR中，比如某个刚刚重启回来的副本。如果Kafka只判断第1个条件的话，就可能出现某些副本具备了“进入ISR”的资格，但却尚未进入到ISR中的情况。此时，分区高水位值就可能超过ISR中副本LEO，而高水位 &gt; LEO的情形是不被允许的。</p><p>下面，我们分别从Leader副本和Follower副本两个维度，来总结一下高水位和LEO的更新机制。</p><p><strong>Leader副本</strong></p><p>处理生产者请求的逻辑如下：</p><ol><li>写入消息到本地磁盘。</li><li>更新分区高水位值。<br/>i. 获取Leader副本所在Broker端保存的所有远程副本LEO值（LEO-1，LEO-2，……，LEO-n）。<br/>ii. 获取Leader副本高水位值：currentHW。<br/>iii. 更新 currentHW = max<!-- -->{<!-- -->currentHW, min（LEO-1, LEO-2, ……，LEO-n）<!-- -->}<!-- -->。</li></ol><p>处理Follower副本拉取消息的逻辑如下：</p><ol><li>读取磁盘（或页缓存）中的消息数据。</li><li>使用Follower副本发送请求中的位移值更新远程副本LEO值。</li><li>更新分区高水位值（具体步骤与处理生产者请求的步骤相同）。</li></ol><p><strong>Follower副本</strong></p><p>从Leader拉取消息的处理逻辑如下：</p><ol><li>写入消息到本地磁盘。</li><li>更新LEO值。</li><li>更新高水位值。<br/>i. 获取Leader发送的高水位值：currentHW。<br/>ii. 获取步骤2中更新过的LEO值：currentLEO。<br/>iii. 更新高水位为min(currentHW, currentLEO)。</li></ol><h2 id="副本同步机制解析"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/05#副本同步机制解析"><span class="icon icon-link"></span></a>副本同步机制解析</h2><p>搞清楚了这些值的更新机制之后，我来举一个实际的例子，说明一下Kafka副本同步的全流程。该例子使用一个单分区且有两个副本的主题。</p><p>当生产者发送一条消息时，Leader和Follower副本对应的高水位是怎么被更新的呢？我给出了一些图片，我们一一来看。</p><p>首先是初始状态。下面这张图中的remote LEO就是刚才的远程副本的LEO值。在初始状态时，所有值都是0。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage1e361ee643ce819a503f72df3d9b4ab04536.cf94b74a.jpg" alt=""/></p><p>当生产者给主题分区发送一条消息后，状态变更为：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage730b7317242d7068dbf618866d5974a2d80b.2b94939c.jpg" alt=""/></p><p>此时，Leader副本成功将消息写入了本地磁盘，故LEO值被更新为1。</p><p>Follower再次尝试从Leader拉取消息。和之前不同的是，这次有消息可以拉取了，因此状态进一步变更为：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage910d910e114abe40f1f9e4a13f6e6083320d.496d6743.jpg" alt=""/></p><p>这时，Follower副本也成功地更新LEO为1。此时，Leader和Follower副本的LEO都是1，但各自的高水位依然是0，还没有被更新。<strong>它们需要在下一轮的拉取中被更新</strong>，如下图所示：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage80cb8066e72733f14d2732a054ed56e373cb.7ed8f733.jpg" alt=""/></p><p>在新一轮的拉取请求中，由于位移值是0的消息已经拉取成功，因此Follower副本这次请求拉取的是位移值=1的消息。Leader副本接收到此请求后，更新远程副本LEO为1，然后更新Leader高水位为1。做完这些之后，它会将当前已更新过的高水位值1发送给Follower副本。Follower副本接收到以后，也将自己的高水位值更新成1。至此，一次完整的消息同步周期就结束了。事实上，Kafka就是利用这样的机制，实现了Leader和Follower副本之间的同步。</p><h2 id="leader-epoch登场"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/05#leader-epoch登场"><span class="icon icon-link"></span></a>Leader Epoch登场</h2><p>故事讲到这里似乎很完美，依托于高水位，Kafka既界定了消息的对外可见性，又实现了异步的副本同步机制。不过，我们还是要思考一下这里面存在的问题。</p><p>从刚才的分析中，我们知道，Follower副本的高水位更新需要一轮额外的拉取请求才能实现。如果把上面那个例子扩展到多个Follower副本，情况可能更糟，也许需要多轮拉取请求。也就是说，Leader副本高水位更新和Follower副本高水位更新在时间上是存在错配的。这种错配是很多“数据丢失”或“数据不一致”问题的根源。基于此，社区在0.11版本正式引入了Leader Epoch概念，来规避因高水位更新错配导致的各种不一致问题。</p><p>所谓Leader Epoch，我们大致可以认为是Leader版本。它由两部分数据组成。</p><ol><li>Epoch。一个单调增加的版本号。每当副本领导权发生变更时，都会增加该版本号。小版本号的Leader被认为是过期Leader，不能再行使Leader权力。</li><li>起始位移（Start Offset）。Leader副本在该Epoch值上写入的首条消息的位移。</li></ol><p>我举个例子来说明一下Leader Epoch。假设现在有两个Leader Epoch&lt;0, 0&gt;和&lt;1, 120&gt;，那么，第一个Leader Epoch表示版本号是0，这个版本的Leader从位移0开始保存消息，一共保存了120条消息。之后，Leader发生了变更，版本号增加到1，新版本的起始位移是120。</p><p>Kafka Broker会在内存中为每个分区都缓存Leader Epoch数据，同时它还会定期地将这些信息持久化到一个checkpoint文件中。当Leader副本写入消息到磁盘时，Broker会尝试更新这部分缓存。如果该Leader是首次写入消息，那么Broker会向缓存中增加一个Leader Epoch条目，否则就不做更新。这样，每次有Leader变更时，新的Leader副本会查询这部分缓存，取出对应的Leader Epoch的起始位移，以避免数据丢失和不一致的情况。</p><p>接下来，我们来看一个实际的例子，它展示的是Leader Epoch是如何防止数据丢失的。请先看下图。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage4df54d97a873fc1bfaf89b5cc8259838f0f5.ef1a5a9f.jpg" alt=""/></p><p>我稍微解释一下，单纯依赖高水位是怎么造成数据丢失的。开始时，副本A和副本B都处于正常状态，A是Leader副本。某个使用了默认acks设置的生产者程序向A发送了两条消息，A全部写入成功，此时Kafka会通知生产者说两条消息全部发送成功。</p><p>现在我们假设Leader和Follower都写入了这两条消息，而且Leader副本的高水位也已经更新了，但Follower副本高水位还未更新——这是可能出现的。还记得吧，Follower端高水位的更新与Leader端有时间错配。倘若此时副本B所在的Broker宕机，当它重启回来后，副本B会执行日志截断操作，将LEO值调整为之前的高水位值，也就是1。这就是说，位移值为1的那条消息被副本B从磁盘中删除，此时副本B的底层磁盘文件中只保存有1条消息，即位移值为0的那条消息。</p><p>当执行完截断操作后，副本B开始从A拉取消息，执行正常的消息同步。如果就在这个节骨眼上，副本A所在的Broker宕机了，那么Kafka就别无选择，只能让副本B成为新的Leader，此时，当A回来后，需要执行相同的日志截断操作，即将高水位调整为与B相同的值，也就是1。这样操作之后，位移值为1的那条消息就从这两个副本中被永远地抹掉了。这就是这张图要展示的数据丢失场景。</p><p>严格来说，这个场景发生的前提是<strong>Broker端参数min.insync.replicas设置为1</strong>。此时一旦消息被写入到Leader副本的磁盘，就会被认为是“已提交状态”，但现有的时间错配问题导致Follower端的高水位更新是有滞后的。如果在这个短暂的滞后时间窗口内，接连发生Broker宕机，那么这类数据的丢失就是不可避免的。</p><p>现在，我们来看下如何利用Leader Epoch机制来规避这种数据丢失。我依然用图的方式来说明。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage3a8c3a2e1131e8244233c076de906c174f8c.88c4e376.jpg" alt=""/></p><p>场景和之前大致是类似的，只不过引用Leader Epoch机制后，Follower副本B重启回来后，需要向A发送一个特殊的请求去获取Leader的LEO值。在这个例子中，该值为2。当获知到Leader LEO=2后，B发现该LEO值不比它自己的LEO值小，而且缓存中也没有保存任何起始位移值 &gt; 2的Epoch条目，因此B无需执行任何日志截断操作。这是对高水位机制的一个明显改进，即副本是否执行日志截断不再依赖于高水位进行判断。</p><p>现在，副本A宕机了，B成为Leader。同样地，当A重启回来后，执行与B相同的逻辑判断，发现也不用执行日志截断，至此位移值为1的那条消息在两个副本中均得到保留。后面当生产者程序向B写入新消息时，副本B所在的Broker缓存中，会生成新的Leader Epoch条目：[Epoch=1, Offset=2]。之后，副本B会使用这个条目帮助判断后续是否执行日志截断操作。这样，通过Leader Epoch机制，Kafka完美地规避了这种数据丢失场景。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/05#小结"><span class="icon icon-link"></span></a>小结</h2><p>今天，我向你详细地介绍了Kafka的高水位机制以及Leader Epoch机制。高水位在界定Kafka消息对外可见性以及实现副本机制等方面起到了非常重要的作用，但其设计上的缺陷给Kafka留下了很多数据丢失或数据不一致的潜在风险。为此，社区引入了Leader Epoch机制，尝试规避掉这类风险。事实证明，它的效果不错，在0.11版本之后，关于副本数据不一致性方面的Bug的确减少了很多。如果你想深入学习Kafka的内部原理，今天的这些内容是非常值得你好好琢磨并熟练掌握的。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage983f989d13e4bc4f44618a10b5b7bd6f523f.f22563d0.jpg" alt=""/></p><h2 id="开放讨论"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心技术与实战/05.深入kafka内核/05#开放讨论"><span class="icon icon-link"></span></a>开放讨论</h2><p>在讲述高水位时，我是拿2个副本举的例子。不过，你应该很容易地扩展到多个副本。现在，请你尝试用3个副本来说明一下副本同步全流程，以及分区高水位被更新的过程。</p><p>欢迎写下你的思考和答案，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/kafka核心技术与实战/05.深入Kafka内核/05.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
