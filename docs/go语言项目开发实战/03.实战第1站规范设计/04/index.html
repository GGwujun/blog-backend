<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>07 | 工作流设计：如何设计合理的多人开发模式？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/go语言项目开发实战/03.实战第1站规范设计/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/go语言项目开发实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-backend/go语言项目开发实战/01.开篇词/01"><span>开篇词 | 从 0 开始搭建一个企业级 Go 应用</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/02.课前必学">02.课前必学</a><ul><li><a href="/blog-backend/go语言项目开发实战/02.课前必学/01"><span>01 | IAM系统概述：我们要实现什么样的 Go 项目？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/02.课前必学/02"><span>02 | 环境准备：如何安装和配置一个基本的 Go 开发环境？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/02.课前必学/03"><span>03 | 项目部署：如何快速部署 IAM 系统？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计">03.实战第1站规范设计</a><ul><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/01"><span>04 | 规范设计（上）：项目开发杂乱无章，如何规范？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/02"><span>05 | 规范设计（下）：commit 信息风格迥异、难以阅读，如何规范？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/03"><span>06 | 目录结构设计：如何组织一个可维护、可扩展的代码目录？</span></a></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04"><span>07 | 工作流设计：如何设计合理的多人开发模式？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/05"><span>08 | 研发流程设计（上）：如何设计 Go 项目的开发流程？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/06"><span>09 | 研发流程设计（下）：如何管理应用的生命周期？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/07"><span>10 | 设计方法：怎么写出优雅的 Go 项目？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/08"><span>11 | 设计模式：Go常用设计模式概述</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发">04.实战第2站基础功能设计或开发</a><ul><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/01"><span>12 | API 风格（上）：如何设计RESTful API？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/02"><span>13 | API 风格（下）：RPC API介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/03"><span>14 | 项目管理：如何编写高质量的Makefile？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/04"><span>15 | 研发流程实战：IAM项目是如何进行研发流程管理的？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/05"><span>16 | 代码检查：如何进行静态代码检查？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/06"><span>17 | API 文档：如何生成 Swagger API 文档 ？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/07"><span>18 | 错误处理（上）：如何设计一套科学的错误码？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/08"><span>19 | 错误处理（下）：如何设计错误包？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/09"><span>20 | 日志处理（上）：如何设计日志包并记录日志？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/10"><span>21 | 日志处理（下）：手把手教你从 0 编写一个日志包</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/11"><span>22 | 应用构建三剑客：Pflag、Viper、Cobra 核心功能介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/12"><span>23 | 应用构建实战：如何构建一个优秀的企业应用框架？</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发">05.实战第3站服务开发</a><ul><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/01"><span>24 | Web 服务：Web 服务核心功能有哪些，如何实现？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/02"><span>25 | 认证机制：应用程序如何进行访问认证？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/03"><span>26 | IAM项目是如何设计和实现访问认证功能的？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/04"><span>27 | 权限模型：5大权限模型是如何进行资源授权的？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/05"><span>28 | 控制流（上）：通过iam-apiserver设计，看Web服务的构建</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/06"><span>29｜控制流（下）：iam-apiserver服务核心功能实现讲解</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/07"><span>30 | ORM：CURD 神器 GORM 包介绍及实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/08"><span>31 | 数据流：通过iam-authz-server设计，看数据流服务的设计</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/09"><span>32 | 数据处理：如何高效处理应用程序产生的数据？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/10"><span>33 |  SDK 设计（上）：如何设计出一个优秀的 Go SDK？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11"><span>34 | SDK 设计（下）：IAM项目Go SDK设计和实现</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/12"><span>35 | 效率神器：如何设计和实现一个命令行客户端工具？</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试">06.实战第4站服务测试</a><ul><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/01"><span>36 | 代码测试（上）：如何编写 Go 语言单元测试和性能测试用例？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/02"><span>37 | 代码测试（下）：Go 语言其他测试类型及 IAM 测试介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/03"><span>38｜性能分析（上）：如何分析 Go 语言代码的性能？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/04"><span>39｜性能分析（下）：API Server性能测试和调优实战</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署">07.实战第5站服务部署</a><ul><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/01"><span>40 | 软件部署实战（上）：部署方案及负载均衡、高可用组件介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/02"><span>41 | 软件部署实战（中）：IAM 系统生产环境部署实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/03"><span>42 | 软件部署实战（下）：IAM系统安全加固、水平扩缩容实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/04"><span>43｜技术演进（上）：虚拟化技术演进之路</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/05"><span>44｜技术演进（下）：软件架构和应用生命周期技术演进之路</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06"><span>45｜基于Kubernetes的云原生架构设计</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/07"><span>46 | 如何制作Docker镜像？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/08"><span>47 | 如何编写Kubernetes资源定义文件？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/09"><span>48 | 基于腾讯云 EKS 的容器化部署实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/10"><span>49 | 服务编排（上）：Helm服务编排基础知识</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/11"><span>50 | 服务编排（下）：基于Helm的服务编排部署实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/12"><span>51 | 基于 GitHub Actions 的 CI 实战</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送">08.特别放送</a><ul><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/01"><span>特别放送 | 给你一份清晰、可直接套用的Go编码规范</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/02"><span>特别放送 | 给你一份Go项目中最常用的Makefile核心语法</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/03"><span>特别放送 | Go Modules依赖包管理全讲</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/04"><span>特别放送 | IAM排障指南</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/05"><span>特别放送 | Go Modules实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/06"><span>特别放送 | 分布式作业系统设计和实现</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/07"><span>直播加餐｜如何从小白进阶成 Go 语言专家？</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/09.结束语">09.结束语</a><ul><li><a href="/blog-backend/go语言项目开发实战/09.结束语/01"><span>结束语 | 如何让自己的 Go 研发之路走得更远？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/09.结束语/02"><span>期末考试｜《Go语言项目开发实战》满分试卷，等你来挑战！</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/summary">go语言项目开发实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="集中式工作流" data-depth="2"><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04#集中式工作流"><span>集中式工作流</span></a></li><li title="功能分支工作流" data-depth="2"><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04#功能分支工作流"><span>功能分支工作流</span></a></li><li title="Git Flow 工作流" data-depth="2"><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04#git-flow-工作流"><span>Git Flow 工作流</span></a></li><li title="Git Flow 的5种分支" data-depth="3"><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04#git-flow-的5种分支"><span>Git Flow 的5种分支</span></a></li><li title="Git Flow 开发流程" data-depth="3"><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04#git-flow-开发流程"><span>Git Flow 开发流程</span></a></li><li title="Forking 工作流" data-depth="2"><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04#forking-工作流"><span>Forking 工作流</span></a></li><li title="总结" data-depth="2"><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04#总结"><span>总结</span></a></li><li title="课后练习" data-depth="2"><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04#课后练习"><span>课后练习</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="07--工作流设计如何设计合理的多人开发模式"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04#07--工作流设计如何设计合理的多人开发模式"><span class="icon icon-link"></span></a>07 | 工作流设计：如何设计合理的多人开发模式？</h1><p>你好，我是孔令飞。今天我们来聊聊如何设计合理的开发模式。</p><p>一个企业级项目是由多人合作完成的，不同开发者在本地开发完代码之后，可能提交到同一个代码仓库，同一个开发者也可能同时开发几个功能特性。这种多人合作开发、多功能并行开发的特性如果处理不好，就会带来诸如丢失代码、合错代码、代码冲突等问题。</p><p>所以，在编码之前，我们需要设计一个合理的开发模式。又因为目前开发者基本都是基于 Git 进行开发的，所以本节课，我会教你怎么基于 Git 设计出一个合理的开发模式。</p><p>那么如何设计工作流呢？你可以根据需要，自己设计工作流，也可以采用业界沉淀下来的、设计好的、受欢迎的工作流。一方面，这些工作流经过长时间的实践，被证明是合理的；另一方面，采用一种被大家熟知且业界通用的工作流，会减少团队内部磨合的时间。在这一讲中，我会为你介绍4种受欢迎的工作流，你可以选择其中一种作为你的工作流设计。</p><p>在使用 Git 开发时，有4种常用的工作流，也叫开发模式，按演进顺序分为集中式工作流、功能分支工作流、Git Flow 工作流和Forking 工作流。接下来，我会按演进顺序分别介绍这 4 种工作流。</p><h2 id="集中式工作流"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04#集中式工作流"><span class="icon icon-link"></span></a>集中式工作流</h2><p>我们先来看看集中式工作流，它是最简单的一种开发方式。集中式工作流的工作模式如下图所示：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage31eb3174a9e1373ed2d6d14471164dcb13eb.82215b0c.png" alt=""/></p><p>A、B、C 为 3 位开发者，每位开发者都在本地有一份远程仓库的拷贝：本地仓库。A、B、C 在本地的 master 分支开发完代码之后，将修改后的代码commit到远程仓库，如果有冲突就先解决本地的冲突再提交。在进行了一段时间的开发之后，远程仓库 master 分支的日志可能如下图所示：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimagefbc7fbcc75ba5b91223f6bf243f0bc08bac7.3aff037e.png" alt=""/></p><p>集中式工作流是最简单的开发模式，但它的缺点也很明显：不同开发人员的提交日志混杂在一起，难以定位问题。如果同时开发多个功能，不同功能同时往 master 分支合并，代码之间也会相互影响，从而产生代码冲突。</p><p>和其他工作流相比，集中式工作流程的代码管理较混乱，容易出问题，因此适合用在<strong>团队人数少、开发不频繁、不需要同时维护多个版本的小项目</strong>中。当我们想要并行开发多个功能时，这种工作流就不适用了，这时候怎么办呢？我们接下来看功能分支工作流。</p><h2 id="功能分支工作流"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04#功能分支工作流"><span class="icon icon-link"></span></a>功能分支工作流</h2><p>功能分支工作流基于集中式工作流演进而来。在开发新功能时，基于 master 分支新建一个功能分支，在功能分支上进行开发，而不是直接在本地的 master 分支开发，开发完成之后合并到 master 分支，如下图所示：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage1c0b1c0b08a1c9032c87c35b85de6ca6820b.a34be1fe.png" alt=""/></p><p>相较于集中式工作流，这种工作流让不同功能在不同的分支进行开发，只在最后一步合并到master分支，不仅可以避免不同功能之间的相互影响，还可以使提交历史看起来更加简洁。</p><p>还有，在合并到 master 分支时，需要提交 PR（pull request），而不是直接将代码 merge 到 master 分支。PR 流程不仅可以把分支代码提供给团队其他开发人员进行 CR（Code Review），还可以在 PR 页面讨论代码。通过 CR ，我们可以确保合并到 master 的代码是健壮的；通过 PR 页面的讨论，可以使开发者充分参与到代码的讨论中，有助于提高代码的质量，并且提供了一个代码变更的历史回顾途径。</p><p>那么，功能分支工作流具体的开发流程是什么呢？我们一起来看下。</p><ol><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">基于 master 分支新建一个功能分支，功能分支可以取一些有意义的名字，便于理解，例如feature/rate-limiting。</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git checkout -b feature/rate-limiting</span></div></pre></div><ol start="2"><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">在功能分支上进行代码开发，开发完成后 commit 到功能分支。</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git add limit.go</span></div><div class="token-line"><span class="token plain">    $ git commit -m &quot;add rate limiting&quot;</span></div></pre></div><ol start="3"><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">将本地功能分支代码 push 到远程仓库。</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git push origin feature/rate-limiting</span></div></pre></div><ol start="4"><li>在远程仓库上创建 PR（例如：GitHub）。</li></ol><p>进入 GitHub 平台上的项目主页，点击 <strong>Compare &amp; pull request</strong> 提交 PR，如下图所示。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimagedbacdbcd25542515788c7f4f2f592d0029ac.b1efe9e9.png" alt=""/></p><p>点击 <strong>Compare &amp; pull request</strong> 后会进入 PR 页面，在该页面中可以根据需要填写评论，最后点击 <strong>Create pull request</strong> 提交 PR。</p><ol start="5"><li>代码管理员收到 PR 后，可以 CR 代码，CR 通过后，再点击 <strong>Merge pull request</strong> 将 PR 合并到 master，如下图所示。</li></ol><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage48c648aaa3a94108de765cb07bd34d899fc6.0a645b0f.png" alt=""/></p><p>图中的“Merge pull request” 提供了 3 种 merge 方法：</p><ul><li>**Create a merge commit：**GitHub 的底层操作是 <code>git merge --no-ff</code>。feature 分支上所有的 commit 都会加到 master 分支上，并且会生成一个 merge commit。这种方式可以让我们清晰地知道是谁做了提交，做了哪些提交，回溯历史的时候也会更加方便。</li><li><strong>Squash and merge</strong>：GitHub 的底层操作是 <code>git merge --squash</code>。<strong>Squash and merge</strong>会使该 pull request 上的所有 commit 都合并成一个commit ，然后加到master分支上，但原来的 commit 历史会丢失。如果开发人员在 feature 分支上提交的 commit 非常随意，没有规范，那么我们可以选择这种方法来丢弃无意义的 commit。但是在大型项目中，每个开发人员都应该是遵循 commit 规范的，因此我不建议你在团队开发中使用 Squash and merge。</li><li>**Rebase and merge：**GitHub 的底层操作是 <code>git rebase</code>。这种方式会将 pull request 上的所有提交历史按照原有顺序依次添加到 master 分支的头部（HEAD）。因为git rebase 有风险，在你不完全熟悉 Git 工作流时，我不建议merge时选择这个。</li></ul><p>通过分析每个方法的优缺点，在实际的项目开发中，我比较推荐你使用 <strong>Create a merge commit</strong> 方式。</p><p>从刚才讲完的具体开发流程中，我们可以感受到，功能分支工作流上手比较简单，不仅能使你并行开发多个功能，还可以添加code review，从而保障代码质量。当然它也有缺点，就是无法给分支分配明确的目的，不利于团队配合。它适合用在<strong>开发团队相对固定、规模较小的项目</strong>中。接下来我们要讲的Git Flow 工作流以功能分支工作流为基础，较好地解决了上述问题。</p><h2 id="git-flow-工作流"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04#git-flow-工作流"><span class="icon icon-link"></span></a>Git Flow 工作流</h2><p>Git Flow 工作流是一个非常成熟的方案，也是非开源项目中最常用到的工作流。它定义了一个围绕项目发布的严格分支模型，通过为代码开发、发布和维护分配独立的分支来让项目的迭代流程更加顺畅，**比较适合大型的项目或者迭代速度快的项目。**接下来，我会通过介绍Git Flow的5种分支和工作流程，来给你讲解GIt Flow是如何工作的。</p><h3 id="git-flow-的5种分支"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04#git-flow-的5种分支"><span class="icon icon-link"></span></a>Git Flow 的5种分支</h3><p>Git Flow 中定义了 5 种分支，分别是 master、develop、feature、release和 hotfix。其中，master 和 develop 为常驻分支，其他为非常驻分支，不同的研发阶段会用到不同的分支。这5种分支的详细介绍见下表：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimagefad9fa611f83053afd77cf3ddf83561ba1d9.3f77b5e7.png" alt=""/></p><h3 id="git-flow-开发流程"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04#git-flow-开发流程"><span class="icon icon-link"></span></a>Git Flow 开发流程</h3><p>这里我们用一个实际的例子来演示下Git Flow 的开发流程。场景如下：</p><p>a. 当前版本为：0.9.0。</p><p>b. 需要新开发一个功能，使程序执行时向标准输出输出“hello world”字符串。</p><p>c. 在开发阶段，线上代码有 Bug 需要紧急修复。</p><p>假设我们的 Git 项目名为 gitflow-demo，项目目录下有 2 个文件，分别是 README.md 和 main.go，内容如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import &quot;fmt&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">    	fmt.Println(&quot;callmainfunction&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>具体的开发流程有 12 步，你可以跟着以下步骤操作练习。</p><ol><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">创建一个常驻的分支：develop。</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git checkout -b develop master</span></div></pre></div><ol start="2"><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">基于 develop 分支，新建一个功能分支：feature/print-hello-world。</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git checkout -b feature/print-hello-world develop</span></div></pre></div><ol start="3"><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">feature/print-hello-world 分支中，在 main.go 文件中添加一行代码`fmt.Println(&quot;Hello&quot;)`，添加后的代码如下。</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import &quot;fmt&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">    	fmt.Println(&quot;callmainfunction&quot;)</span></div><div class="token-line"><span class="token plain">    	fmt.Println(&quot;Hello&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><ol start="4"><li>紧急修复 Bug。</li></ol><p>我们正处在新功能的开发中（只完成了 <code>fmt.Println(&quot;Hello&quot;)</code>而非 <code>fmt.Println(&quot;Hello World&quot;)</code>）突然线上代码发现了一个 Bug，我们要立即停止手上的工作，修复线上的 Bug，步骤如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git stash # 1. 开发工作只完成了一半，还不想提交，可以临时保存修改至堆栈区</span></div><div class="token-line"><span class="token plain">    $ git checkout -b hotfix/print-error master # 2. 从 master 建立 hotfix 分支</span></div><div class="token-line"><span class="token plain">    $ vi main.go # 3. 修复 bug，callmainfunction -&gt; call main function</span></div><div class="token-line"><span class="token plain">    $ git commit -a -m &#x27;fix print message error bug&#x27; # 4. 提交修复</span></div><div class="token-line"><span class="token plain">    $ git checkout develop # 5. 切换到 develop 分支</span></div><div class="token-line"><span class="token plain">    $ git merge --no-ff hotfix/print-error # 6. 把 hotfix 分支合并到 develop 分支</span></div><div class="token-line"><span class="token plain">    $ git checkout master # 7. 切换到 master 分支</span></div><div class="token-line"><span class="token plain">    $ git merge --no-ff hotfix/print-error # 8. 把 hotfix 分支合并到 master</span></div><div class="token-line"><span class="token plain">    $ git tag -a v0.9.1 -m &quot;fix log bug&quot; # 9. master 分支打 tag</span></div><div class="token-line"><span class="token plain">    $ go build -v . # 10. 编译代码，并将编译好的二进制更新到生产环境</span></div><div class="token-line"><span class="token plain">    $ git branch -d hotfix/print-error # 11. 修复好后，删除 hotfix/xxx 分支</span></div><div class="token-line"><span class="token plain">    $ git checkout feature/print-hello-world # 12. 切换到开发分支下</span></div><div class="token-line"><span class="token plain">    $ git merge --no-ff develop # 13. 因为 develop 有更新，这里最好同步更新下</span></div><div class="token-line"><span class="token plain">    $ git stash pop # 14. 恢复到修复前的工作状态</span></div></pre></div><ol start="5"><li>继续开发。</li></ol><p>在 main.go 中加入 <code>fmt.Println(&quot;Hello World&quot;)</code>。</p><ol start="6"><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">提交代码到 feature/print-hello-world 分支。</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git commit -a -m &quot;print &#x27;hello world&#x27;&quot;</span></div></pre></div><ol start="7"><li>在 feature/print-hello-world 分支上做 code review。</li></ol><p>首先，我们需要将 feature/print-hello-world push 到代码托管平台，例如 GitHub 上。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git push origin feature/print-hello-world</span></div></pre></div><p>然后，我们在 GitHub 上，基于 feature/print-hello-world 创建 pull request，如下图所示。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimageaceaac70d5ab86887e47f78c48d1df42f2ea.d582170d.png" alt=""/></p><p>创建完 pull request 之后，我们就可以指定 Reviewers 进行 code review，如下图所示。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimagebc50bc5168fe73abc257ba35342764647250.97eaa5dd.png" alt=""/></p><ol start="8"><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">code review 通过后，由代码仓库 matainer 将功能分支合并到 develop 分支。</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git checkout develop</span></div><div class="token-line"><span class="token plain">    $ git merge --no-ff feature/print-hello-world</span></div></pre></div><ol start="9"><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">基于 develop 分支，创建 release 分支，测试代码。</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git checkout -b release/1.0.0 develop</span></div><div class="token-line"><span class="token plain">    $ go build -v . # 构建后，部署二进制文件，并测试</span></div></pre></div><ol start="10"><li>测试失败，因为我们要求打印“hello world”，但打印的是“Hello World”，修复的时候，</li></ol><p>我们直接在 release/1.0.0 分支修改代码，修改完成后，提交并编译部署。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git commit -a -m &quot;fix bug&quot;</span></div><div class="token-line"><span class="token plain">    $ go build -v .</span></div></pre></div><ol start="11"><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">测试通过后，将功能分支合并到 master 分支和 develop 分支。</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git checkout develop</span></div><div class="token-line"><span class="token plain">    $ git merge --no-ff release/1.0.0</span></div><div class="token-line"><span class="token plain">    $ git checkout master</span></div><div class="token-line"><span class="token plain">    $ git merge --no-ff release/1.0.0</span></div><div class="token-line"><span class="token plain">    $ git tag -a v1.0.0 -m &quot;add print hello world&quot; # master 分支打 tag</span></div></pre></div><ol start="12"><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">删除 feature/print-hello-world 分支，也可以选择性删除 release/1.0.0 分支。</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git branch -d feature/print-hello-world</span></div></pre></div><p>亲自操作一遍之后，你应该会更了解这种模式的优缺点。它的缺点，就是你刚才已经体会到的，它有一定的上手难度。不过Git Flow工作流还是有很多优点的：Git Flow工作流的每个分支分工明确，这可以最大程度减少它们之间的相互影响。因为可以创建多个分支，所以也可以并行开发多个功能。另外，和功能分支工作流一样，它也可以添加code review，保障代码质量。</p><p>因此，Git Flow工作流比较<strong>适合开发团队相对固定，规模较大的项目</strong>。</p><h2 id="forking-工作流"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04#forking-工作流"><span class="icon icon-link"></span></a>Forking 工作流</h2><p>上面讲的Git Flow 是非开源项目中最常用的，而在开源项目中，最常用到的是Forking 工作流，例如 Kubernetes、Docker 等项目用的就是这种工作流。这里，我们先来了解下 fork 操作。</p><p>fork 操作是在个人远程仓库新建一份目标远程仓库的副本，比如在 GitHub 上操作时，在项目的主页点击 fork 按钮（页面右上角），即可拷贝该目标远程仓库。Forking 工作流的流程如下图所示。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage63ea63419f767c61c9580861b59445b90fea.ad726173.png" alt=""/></p><p>假设开发者 A 拥有一个远程仓库，如果开发者 B 也想参与 A 项目的开发，B 可以 fork 一份 A 的远程仓库到自己的 GitHub 账号下。后续 B 可以在自己的项目进行开发，开发完成后，B 可以给 A 提交一个 PR。这时候 A 会收到通知，得知有新的 PR 被提交，A 会去查看 PR 并 code review。如果有问题，A 会直接在 PR 页面提交评论，B 看到评论后会做进一步的修改。最后 A 通过 B 的 PR 请求，将代码合并进了 A 的仓库。这样就完成了 A 代码仓库新特性的开发。如果有其他开发者想给 A 贡献代码，也会执行相同的操作。</p><p>GitHub中的 Forking 工作流详细步骤共有6步（假设目标仓库为 gitflow-demo），你可以跟着以下步骤操作练习。</p><ol><li>Fork 远程仓库到自己的账号下。</li></ol><p>访问<a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/gitflow-demo">https://github.com/marmotedu/gitflow-demo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，点击<strong>fork</strong>按钮。fork 后的仓库地址为：<a target="_blank" rel="noopener noreferrer" href="https://github.com/colin404fork/gitflow-demo">https://github.com/colin404fork/gitflow-demo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。<br/>2) 克隆 fork 的仓库到本地。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git clone https://github.com/colin404fork/gitflow-demo</span></div><div class="token-line"><span class="token plain">    $ cd gitflow-demo</span></div><div class="token-line"><span class="token plain">    $ git remote add upstream https://github.com/marmotedu/gitflow-demo</span></div><div class="token-line"><span class="token plain">    $ git remote set-url --push upstream no_push # Never push to upstream master</span></div><div class="token-line"><span class="token plain">    $ git remote -v # Confirm that your remotes make sense</span></div><div class="token-line"><span class="token plain">    origin	https://github.com/colin404fork/gitflow-demo (fetch)</span></div><div class="token-line"><span class="token plain">    origin	https://github.com/colin404fork/gitflow-demo (push)</span></div><div class="token-line"><span class="token plain">    upstream	https://github.com/marmotedu/gitflow-demo (fetch)</span></div><div class="token-line"><span class="token plain">    upstream	https://github.com/marmotedu/gitflow-demo (push)</span></div></pre></div><ol start="3"><li>创建功能分支。</li></ol><p>首先，要同步本地仓库的 master 分支为最新的状态（跟 upstream master 分支一致）。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git fetch upstream</span></div><div class="token-line"><span class="token plain">    $ git checkout master</span></div><div class="token-line"><span class="token plain">    $ git rebase upstream/master</span></div></pre></div><p>然后，创建功能分支。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git checkout -b feature/add-function</span></div></pre></div><ol start="4"><li>提交 commit。</li></ol><p>在 feature/add-function 分支上开发代码，开发完代码后，提交 commit。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git fetch upstream # commit 前需要再次同步 feature 跟 upstream/master</span></div><div class="token-line"><span class="token plain">    $ git rebase upstream/master</span></div><div class="token-line"><span class="token plain">    $ git add &lt;file&gt;</span></div><div class="token-line"><span class="token plain">    $ git status</span></div><div class="token-line"><span class="token plain">    $ git commit</span></div></pre></div><p>分支开发完成后，可能会有一堆 commit，但是合并到主干时，我们往往希望只有一个（或最多两三个）commit，这可以使功能修改都放在一个或几个commit中，便于后面的阅读和维护。这个时候，我们可以用 git rebase 来合并和修改我们的 commit，操作如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git rebase -i origin/master</span></div></pre></div><p>第5讲已经介绍过了<code>git rebase \-i</code> 的使用方法 ，如果你有疑问可以再去看看，这里不再说明。</p><p>还有另外一种合并 commit 的简便方法，就是先撤销过去 5 个 commit，然后再建一个新的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git reset HEAD~5</span></div><div class="token-line"><span class="token plain">    $ git add .</span></div><div class="token-line"><span class="token plain">    $ git commit -am &quot;Here&#x27;s the bug fix that closes #28&quot;</span></div><div class="token-line"><span class="token plain">    $ git push --force</span></div></pre></div><p>squash 和 fixup 命令，还可以当作命令行参数使用，自动合并 commit。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git commit --fixup</span></div><div class="token-line"><span class="token plain">    $ git rebase -i --autosquash</span></div></pre></div><ol start="5"><li>push 功能分支到个人远程仓库。</li></ol><p>在完成了开发，并 commit 后，需要将功能分支 push 到个人远程代码仓库，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git push -f origin feature/add-function</span></div></pre></div><ol start="6"><li>在个人远程仓库页面创建 pull request。</li></ol><p>提交到远程仓库以后，我们就可以创建 pull request，然后请求reviewers进行代码 review，确认后合并到 master。这里要注意，创建pull request时，base通常选择目标远程仓库的master分支。</p><p>我们已经讲完了 Forking 工作流的具体步骤，你觉得它有什么优缺点呢？</p><p>结合操作特点，我们来看看它的优点：Forking工作流中，项目远程仓库和开发者远程仓库完全独立，开发者通过提交 Pull Request 的方式给远程仓库贡献代码，项目维护者选择性地接受任何开发者的提交，通过这种方式，可以避免授予开发者项目远程仓库的权限，从而提高项目远程仓库的安全性，这也使得任意开发者都可以参与项目的开发。</p><p>但Forking工作流也有局限性，就是对于职能分工明确且不对外开源的项目优势不大。</p><p>Forking工作流比较适用于以下三种场景：（1）开源项目中；（2）开发者有衍生出自己的衍生版的需求；（3）开发者不固定，可能是任意一个能访问到项目的开发者。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04#总结"><span class="icon icon-link"></span></a>总结</h2><p>这一讲中，我基于 Git 向你介绍了 4 种开发模式，现在跟我回顾一下吧。</p><ul><li>集中式工作流：开发者直接在本地 master 分支开发代码，开发完成后 push 到远端仓库 master 分支。</li><li>功能分支工作流：开发者基于 master 分支创建一个新分支，在新分支进行开发，开发完成后合并到远端仓库 master 分支。</li><li>Git Flow 工作流：Git Flow 工作流为不同的分支分配一个明确的角色，并定义分支之间什么时候、如何进行交互，比较适合大型项目的开发。</li><li>Forking 工作流：开发者先 fork 项目到个人仓库，在个人仓库完成开发后，提交 pull request 到目标远程仓库，远程仓库 review 后，合并 pull request 到 master 分支。</li></ul><p>集中式工作流是最早的Git工作流，功能分支工作流以集中式工作流为基础，Git Flow 工作流又是以功能分支工作流为基础，Forking工作流在Git Flow 工作流基础上，解耦了个人远端仓库和项目远端仓库。</p><p>每种开发模式各有优缺点，适用于不同的场景，我总结在下表中：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage55075503ce60f7c2ae5d7628222a4d87cc07.a3f58407.png" alt=""/></p><p>总的来说，在选择工作流时，我的推荐如下：</p><ul><li>非开源项目采用 Git Flow 工作流。</li><li>开源项目采用 Forking 工作流。</li></ul><p>因为这门课的实战项目对于项目开发者来说是一个偏大型的非开源项目，所以采用了Git Flow工作流。</p><h2 id="课后练习"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04#课后练习"><span class="icon icon-link"></span></a>课后练习</h2><ol><li>请你新建立一个项目，并参考<strong>Git Flow开发流程</strong>，自己操作一遍，观察每一步的操作结果。</li><li>请你思考下，在 Git Flow 工作流中，如果要临时解决一个 Bug，该如何操作代码仓库。</li></ol><p>期待在留言区看到你的思考和分享，我们下一讲见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/go语言项目开发实战/03.实战第1站规范设计/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
