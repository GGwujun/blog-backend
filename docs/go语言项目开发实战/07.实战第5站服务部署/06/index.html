<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>45｜基于Kubernetes的云原生架构设计 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/go语言项目开发实战/07.实战第5站服务部署/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/go语言项目开发实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-backend/go语言项目开发实战/01.开篇词/01"><span>开篇词 | 从 0 开始搭建一个企业级 Go 应用</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/02.课前必学">02.课前必学</a><ul><li><a href="/blog-backend/go语言项目开发实战/02.课前必学/01"><span>01 | IAM系统概述：我们要实现什么样的 Go 项目？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/02.课前必学/02"><span>02 | 环境准备：如何安装和配置一个基本的 Go 开发环境？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/02.课前必学/03"><span>03 | 项目部署：如何快速部署 IAM 系统？</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计">03.实战第1站规范设计</a><ul><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/01"><span>04 | 规范设计（上）：项目开发杂乱无章，如何规范？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/02"><span>05 | 规范设计（下）：commit 信息风格迥异、难以阅读，如何规范？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/03"><span>06 | 目录结构设计：如何组织一个可维护、可扩展的代码目录？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04"><span>07 | 工作流设计：如何设计合理的多人开发模式？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/05"><span>08 | 研发流程设计（上）：如何设计 Go 项目的开发流程？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/06"><span>09 | 研发流程设计（下）：如何管理应用的生命周期？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/07"><span>10 | 设计方法：怎么写出优雅的 Go 项目？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/08"><span>11 | 设计模式：Go常用设计模式概述</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发">04.实战第2站基础功能设计或开发</a><ul><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/01"><span>12 | API 风格（上）：如何设计RESTful API？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/02"><span>13 | API 风格（下）：RPC API介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/03"><span>14 | 项目管理：如何编写高质量的Makefile？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/04"><span>15 | 研发流程实战：IAM项目是如何进行研发流程管理的？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/05"><span>16 | 代码检查：如何进行静态代码检查？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/06"><span>17 | API 文档：如何生成 Swagger API 文档 ？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/07"><span>18 | 错误处理（上）：如何设计一套科学的错误码？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/08"><span>19 | 错误处理（下）：如何设计错误包？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/09"><span>20 | 日志处理（上）：如何设计日志包并记录日志？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/10"><span>21 | 日志处理（下）：手把手教你从 0 编写一个日志包</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/11"><span>22 | 应用构建三剑客：Pflag、Viper、Cobra 核心功能介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/12"><span>23 | 应用构建实战：如何构建一个优秀的企业应用框架？</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发">05.实战第3站服务开发</a><ul><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/01"><span>24 | Web 服务：Web 服务核心功能有哪些，如何实现？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/02"><span>25 | 认证机制：应用程序如何进行访问认证？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/03"><span>26 | IAM项目是如何设计和实现访问认证功能的？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/04"><span>27 | 权限模型：5大权限模型是如何进行资源授权的？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/05"><span>28 | 控制流（上）：通过iam-apiserver设计，看Web服务的构建</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/06"><span>29｜控制流（下）：iam-apiserver服务核心功能实现讲解</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/07"><span>30 | ORM：CURD 神器 GORM 包介绍及实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/08"><span>31 | 数据流：通过iam-authz-server设计，看数据流服务的设计</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/09"><span>32 | 数据处理：如何高效处理应用程序产生的数据？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/10"><span>33 |  SDK 设计（上）：如何设计出一个优秀的 Go SDK？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11"><span>34 | SDK 设计（下）：IAM项目Go SDK设计和实现</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/12"><span>35 | 效率神器：如何设计和实现一个命令行客户端工具？</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试">06.实战第4站服务测试</a><ul><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/01"><span>36 | 代码测试（上）：如何编写 Go 语言单元测试和性能测试用例？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/02"><span>37 | 代码测试（下）：Go 语言其他测试类型及 IAM 测试介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/03"><span>38｜性能分析（上）：如何分析 Go 语言代码的性能？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/04"><span>39｜性能分析（下）：API Server性能测试和调优实战</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署">07.实战第5站服务部署</a><ul><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/01"><span>40 | 软件部署实战（上）：部署方案及负载均衡、高可用组件介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/02"><span>41 | 软件部署实战（中）：IAM 系统生产环境部署实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/03"><span>42 | 软件部署实战（下）：IAM系统安全加固、水平扩缩容实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/04"><span>43｜技术演进（上）：虚拟化技术演进之路</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/05"><span>44｜技术演进（下）：软件架构和应用生命周期技术演进之路</span></a></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06"><span>45｜基于Kubernetes的云原生架构设计</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/07"><span>46 | 如何制作Docker镜像？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/08"><span>47 | 如何编写Kubernetes资源定义文件？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/09"><span>48 | 基于腾讯云 EKS 的容器化部署实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/10"><span>49 | 服务编排（上）：Helm服务编排基础知识</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/11"><span>50 | 服务编排（下）：基于Helm的服务编排部署实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/12"><span>51 | 基于 GitHub Actions 的 CI 实战</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送">08.特别放送</a><ul><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/01"><span>特别放送 | 给你一份清晰、可直接套用的Go编码规范</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/02"><span>特别放送 | 给你一份Go项目中最常用的Makefile核心语法</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/03"><span>特别放送 | Go Modules依赖包管理全讲</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/04"><span>特别放送 | IAM排障指南</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/05"><span>特别放送 | Go Modules实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/06"><span>特别放送 | 分布式作业系统设计和实现</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/07"><span>直播加餐｜如何从小白进阶成 Go 语言专家？</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/09.结束语">09.结束语</a><ul><li><a href="/blog-backend/go语言项目开发实战/09.结束语/01"><span>结束语 | 如何让自己的 Go 研发之路走得更远？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/09.结束语/02"><span>期末考试｜《Go语言项目开发实战》满分试卷，等你来挑战！</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/summary">go语言项目开发实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="云原生简介" data-depth="2"><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#云原生简介"><span>云原生简介</span></a></li><li title="CNCF（云原生计算基金会）简介" data-depth="3"><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#cncf云原生计算基金会简介"><span>CNCF（云原生计算基金会）简介</span></a></li><li title="什么是云原生？" data-depth="3"><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#什么是云原生"><span>什么是云原生？</span></a></li><li title="什么是云原生应用？" data-depth="3"><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#什么是云原生应用"><span>什么是云原生应用？</span></a></li><li title="云原生架构包含很多内容，如何学习？" data-depth="2"><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#云原生架构包含很多内容如何学习"><span>云原生架构包含很多内容，如何学习？</span></a></li><li title="系统资源层的云原生架构设计" data-depth="2"><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#系统资源层的云原生架构设计"><span>系统资源层的云原生架构设计</span></a></li><li title="Kubernetes集群高可用方案设计" data-depth="3"><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#kubernetes集群高可用方案设计"><span>Kubernetes集群高可用方案设计</span></a></li><li title="Kubernetes应用的高可用" data-depth="3"><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#kubernetes应用的高可用"><span>Kubernetes应用的高可用</span></a></li><li title="应用层的云原生架构设计" data-depth="2"><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#应用层的云原生架构设计"><span>应用层的云原生架构设计</span></a></li><li title="微服务实现" data-depth="3"><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#微服务实现"><span>微服务实现</span></a></li><li title="微服务架构设计" data-depth="3"><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#微服务架构设计"><span>微服务架构设计</span></a></li><li title="微服务高可用架构设计" data-depth="3"><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#微服务高可用架构设计"><span>微服务高可用架构设计</span></a></li><li title="云原生架构鸟瞰图" data-depth="2"><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#云原生架构鸟瞰图"><span>云原生架构鸟瞰图</span></a></li><li title="公有云版云原生架构" data-depth="2"><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#公有云版云原生架构"><span>公有云版云原生架构</span></a></li><li title="总结" data-depth="2"><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#总结"><span>总结</span></a></li><li title="课后练习" data-depth="2"><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#课后练习"><span>课后练习</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="45基于kubernetes的云原生架构设计"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#45基于kubernetes的云原生架构设计"><span class="icon icon-link"></span></a>45｜基于Kubernetes的云原生架构设计</h1><p>你好，我是孔令飞。</p><p>前面两讲，我们一起看了云技术的演进之路。软件架构已经进入了云原生时代，云原生架构是当下最流行的软件部署架构。那么这一讲，我就和你聊聊什么是云原生，以及如何设计一种基于Kubernetes的云原生部署架构。</p><h2 id="云原生简介"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#云原生简介"><span class="icon icon-link"></span></a>云原生简介</h2><p>云原生包含的概念很多，对于一个应用开发者来说，主要关注点是如何开发应用，以及如何部署应用。所以，这里我在介绍云原生架构的时候，会主要介绍应用层的云原生架构设计和系统资源层的云原生架构设计。</p><p>在设计云原生架构时，应用生命周期管理层的云原生技术，我们主要侧重在使用层面，所以这里我就不详细介绍应用生命周期管理层的云原生架构了。后面的云原生架构鸟瞰图中会提到它，你可以看看。</p><p>另外，在介绍云原生时，也总是绕不开云原生计算基金会。接下来，我们就先来简单了解下CNCF基金会。</p><h3 id="cncf云原生计算基金会简介"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#cncf云原生计算基金会简介"><span class="icon icon-link"></span></a>CNCF（云原生计算基金会）简介</h3><p><a target="_blank" rel="noopener noreferrer" href="https://www.cncf.io/">CNCF<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（Cloud Native Computing Foundation，云原生计算基金会），2015年由谷歌牵头成立，目前已有一百多个企业与机构作为成员，包括亚马逊、微软、思科、红帽等巨头。CNCF致力于培育和维护一个厂商中立的开源社区生态，用以推广云原生技术。</p><p>CNCF目前托管了非常多的开源项目，其中有很多我们耳熟能详的项目，例如 Kubernetes、Prometheus、Envoy、Istio、etcd等。更多的项目，你可以参考CNCF公布的<a target="_blank" rel="noopener noreferrer" href="https://landscape.cncf.io/images/landscape.png">Cloud Native Landscape<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它给出了云原生生态的参考体系，如下图所示：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage5e325ef7aa9e514ac27b6474165c745dfe32.a6a5dad0.jpg" alt=""/></p><h3 id="什么是云原生"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#什么是云原生"><span class="icon icon-link"></span></a>什么是云原生？</h3><p>CNCF官方在2018年发布了云原生v1.0，并给出了定义：</p><blockquote><p>“云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。 这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。”</p></blockquote><p>简单点说，云原生（Cloud Native）是一种构建和运行应用程序的方法，是一套技术体系和方法论。云原生中包含了3个概念，分别是技术体系、方法论和云原生应用。整个云原生技术栈是围绕着Kubernetes来构建的，具体包括了以下核心技术栈：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage8f668fc9dc16d99e7f2949813fe109986266.978afbe4.jpg" alt=""/></p><p>这里来介绍下这些核心技术栈的基本内容。</p><ul><li><strong>容器</strong>：Kubernetes的底层计算引擎，提供容器化的计算资源。</li><li><strong>微服务</strong>：一种软件架构思想，用来构建云原生应用。</li><li><strong>服务网格</strong>：建立在Kubernetes之上，作为服务间通信的底座，提供强大的服务治理功能。</li><li><strong>声明式 API</strong> ：一种新的软件开发模式，通过描述期望的应用状态，来使系统更加健壮。</li><li><strong>不可变基础设施</strong>：一种新的软件部署模式，应用实例一旦被创建，便只能重建不能更新，是现代运维的基础。</li></ul><p>在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/414159">43讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/414856">44讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中，我介绍了容器、服务网格和微服务，这里再补充介绍下不可变基础设施和声明式API。</p><p><strong>不可变基础设施</strong>（Immutable Infrastructure）的构想，是由Chad Fowler 于 2013 年提出的。具体来说就是：一个应用程序的实例，一旦被创建，就会进入只读的状态，后面如果想变更这个应用程序的实例，只能重新创建一个新的实例。通过这种模式，可以确保应用程序实例的一致性，这使得落地DevOps更加容易，并可以有效减少运维人员管理配置的负担。</p><p><strong>声明式API</strong>是指我们通过工具描述期望的应用状态，并由工具保障应用一直处在我们期望的状态。</p><p>Kubernetes的API设计，就是一种典型的声明式API。例如，我们在创建Deployment时，在Kubernetes YAML文件中声明应用的副本数为<code>2</code>，即设置<code>replicas: 2</code>，Deployment Controller就会确保应用的副本数一直为<code>2</code>。也就是说，如果当前副本数大于<code>2</code>，Deployment Controller会删除多余的副本；如果当前副本数小于<code>2</code>，会创建新的副本。</p><p>声明式设计是一种设计理念，同时也是一种工作模式，它使得你的系统更加健壮。分布式系统环境可能会出现各种不确定的故障，面对这些组件故障，如果使用声明式 API ，你只需要查看对应组件的 API 服务器状态，再确定需要执行的操作即可。</p><h3 id="什么是云原生应用"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#什么是云原生应用"><span class="icon icon-link"></span></a>什么是云原生应用？</h3><p>上面，我介绍了什么是云原生，接下来再介绍下什么是云原生应用。</p><p>整体来看，云原生应用是指生而为云的应用，应用程序从设计之初就考虑到了云的环境，可以在云上以最佳姿势运行，充分利用和发挥云平台提供的各种能力。具体来看，云原生应用具有以下三大特点：</p><ul><li>从应用生命周期管理维度来看，使用DevOps和CI/CD的方式，进行开发和交付。</li><li>从应用维度来看，以微服务原则进行划分设计。</li><li>从系统资源维度来看，采用Docker + Kubernetes的方式来部署。</li></ul><p>看完上面的介绍，你应该已经对云原生和云原生应用有了一定的理解，接下来我就介绍一种云原生架构实现。因为云原生内容很多，所以这里的介绍只是起到抛砖引玉的作用，让你对云原生架构有初步的理解。至于在具体业务中如何设计云原生架构，你还需要根据业务、团队和技术栈等因素综合考虑。</p><h2 id="云原生架构包含很多内容如何学习"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#云原生架构包含很多内容如何学习"><span class="icon icon-link"></span></a>云原生架构包含很多内容，如何学习？</h2><p>云原生架构中包含了很多概念、技术，那么我们到底如何学习呢？在前面的两讲中，我分别从系统资源层、应用层、应用生命周期管理层介绍了云技术。这3个层次基本上构成了整个云计算的技术栈。</p><p>今天，我仍然会从这三个层次入手，来对整个云原生架构设计进行相对完整的介绍。每个层次涉及到的技术很多，这一讲我只介绍每一层的核心技术，通过这些核心技术来看每一层的构建方法。</p><p>另外，因为应用生命周期管理层涉及到的技术栈非常多，所以今天不会详细讲解每种生命周期管理技术的实现原理，但会介绍它们提供的能力。</p><p>除了功能层面的架构设计之外，我们还要考虑部署层面的架构设计。对于云原生架构的部署，通常我们需要关注以下两点：</p><ul><li>容灾能力：容灾能力是指应用程序遇到故障时的恢复能力。在互联网时代，对应用的容灾能力有比较高的要求。理想情况是系统在出现故障时，能够无缝切换到另外一个可用的实例上，继续提供服务，并做到用户无感知。但在实际开发中，无缝切换在技术上比较难以实现，所以也可以退而求其次，允许系统在一定时间内不可用。通常这个时间需要控制在秒级，例如5s。容灾能力可以通过负载均衡、健康检查来实现。</li><li>扩缩容能力：扩缩容能力指的是系统能够根据需要扩缩容，可以手动扩缩容，也可以自动扩缩容。互联网时代对扩缩容能力的要求也比较高，需要实现自动扩缩容。我们可以基于一些自定义指标，例如CPU使用率、内存使用率等来自动扩缩容。扩容也意味着能够承载更多的请求，提高系统的吞吐量；缩容，意味着能够节省成本。扩缩容能力的实现，需要借助于负载均衡和监控告警能力。</li></ul><p>容灾能力和扩缩容能力都属于高可用能力。也就是说，在部署层面，需要我们的架构具备高可用能力。</p><p>接下来，我就重点介绍下系统资源层和应用层的云原生架构设计，并简单介绍下应用生命周期管理层的核心功能构建。在介绍完架构设计之后，我还会介绍下这些层面的高可用架构设计。</p><h2 id="系统资源层的云原生架构设计"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#系统资源层的云原生架构设计"><span class="icon icon-link"></span></a>系统资源层的云原生架构设计</h2><p>先来看系统资源层面的云原生架构设计。对于一个系统来说，系统资源的架构是需要优先考虑的。在云原生架构中，当前的业界标准是通过Docker提供系统资源（例如CPU、内存等），通过Kubernetes来编排Docker容器。Docker和Kubernetes的架构，我在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/414159">43讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中介绍过，这里我主要介绍下系统资源层面的高可用架构设计。</p><p>基于Docker+Kubernetes的方案，高可用架构是通过Kubernetes高可用架构来实现的。要实现整个Kubernetes集群的高可用，我们需要分别实现以下两类高可用：</p><ul><li>Kubernetes集群的高可用。</li><li>Kubernetes集群中所部署应用的高可用。</li></ul><p>我们来分别看下这两个高可用方案。</p><h3 id="kubernetes集群高可用方案设计"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#kubernetes集群高可用方案设计"><span class="icon icon-link"></span></a>Kubernetes集群高可用方案设计</h3><p>通过<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/414159">43讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的学习，我们知道Kubernetes由kube-apiserver、kube-controller-manager、kube-scheduler、cloud-controller-manager、etcd、kubelet、kube-proxy、container runtime 8大核心组件组成。</p><p>其中，kube-apiserver、kube-controller-manager、kube-scheduler、cloud-controller-manager、etcd通常部署在master节点，kubelet、kube-proxy、container runtime 部署在Node节点上。实现Kubernetes集群的高可用，需要分别实现这8大核心组件的高可用。</p><p>Kubernetes集群的高可用架构图如下：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage763f7667b9f5a88e61487fce2374400d823f.8ee70eb6.jpg" alt=""/></p><p>上面图片展示的方案中，所有管理节点都部署了kube-apiserver、kube-controller-manager、kube-scheduler、etcd等组件。kube-apiserver均与本地的etcd进行通信，etcd在三个节点间同步数据；而kube-controller-manager、kube-scheduler和cloud-controller-manager，也只与本地的kube-apiserver进行通信，或者通过负载均衡访问。</p><p>一个Kubernetes集群中有多个<strong>Node节点</strong>，当一个Node节点故障时，Kubernetes的调度组件kube-controller-manager会将Pod调度到其他节点上，并将故障节点的Pod在其他可用节点上重建。也就是说，只要集群中有两个以上的节点，当其中一个Node故障时，整个集群仍然能够正常提供服务。换句话说，集群的<strong>kubelet、kube-proxy、container runtime组件</strong>可以是单点的，不用实现这些组件的高可用。</p><p>接下来，我们来看下<strong>Master节点</strong>各组件是如何实现高可用的。先来说下<strong>kube-apiserver组件的高可用方案设计</strong>。</p><p>因为kube-apiserver是一个无状态的服务，所以可以通过部署多个kube-apiserver实例，其上挂载负载均衡的方式来实现。其他所有需要访问kube-apiserver的组件，都通过负载均衡来访问，以此实现kube-apiserver的高可用。</p><p>kube-controller-manager、cloud-controller-manager和kube-scheduler因为是有状态的服务，所以它们的高可用能力不能通过负载均衡来实现。kube-controller-manager/kube-scheduler/cloud-controller-manager通过–leader-elect=true参数开启分布式锁机制，来进行leader election。</p><p>你可以创建多个kube-controller-manager/kube-scheduler/cloud-controller-manager实例，同一时刻只有一个实例能够获取到锁，成为leader，提供服务。如果当前leader故障，其他实例感知到leader故障之后会自动抢锁，成为leader继续提供服务。通过这种方式，我们实现了kube-controller-manager/kube-scheduler/cloud-controller-manager组件的高可用。</p><p>当kube-apiserver、kube-controller-manager、kube-scheduler、cloud-controller-manager故障时，我们期望这些组件能够自动恢复，这时候可以将这些组件以Static Pod的方式进行部署，这样当Pod故障时，上述实例就能够自动被拉起。</p><p><strong>etcd的高可用方案</strong>有下面这3种思路：</p><ul><li>使用独立的etcd集群，独立的etcd集群自带高可用能力。</li><li>在每个Master节点上，使用Static Pod来部署etcd，多个节点上的etcd实例数据相互同步。每个kube-apiserver只与本Master节点的etcd通信。</li><li>使用CoreOS提出的self-hosted方案，将etcd集群部署在kubernetes集群中，通过kubernetes集群自身的容灾能力来实现etcd的高可用。</li></ul><p>这三种思路，需要你根据实际需要进行选择，在实际生产环境中，第二种思路用得最多。</p><p>到这里，我们就实现了整个Kubernetes集群的高可用。接下来，我们来看下Kubernetes集群中，应用的高可用是如何实现的。</p><h3 id="kubernetes应用的高可用"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#kubernetes应用的高可用"><span class="icon icon-link"></span></a>Kubernetes应用的高可用</h3><p>Kubernetes自带了应用高可用能力。在Kubernetes中，应用以Pod的形式运行。你可以通过Deployment/StatefulSet来创建应用，并在Deployment/StatefulSet中指定多副本和Pod的健康检查方式。当Pod健康检查失败时，Deployment/StatefulSet的控制器（ReplicaSet）会自动销毁故障Pod，并创建一个新的Pod，替换故障的Pod。</p><p>你可能会问：当Pod故障时，怎么才能避免请求被调度到已故障的Pod上，造成请求失败？这里我也详细介绍下。</p><p>在Kubernetes中，我们可以通过Kubernetes Service或者负载均衡来访问这些Pod。当通过负载均衡来访问Pod时，负载均衡后端的RS（Real Server）实例其实就是Pod。我们创建了多个Pod，负载均衡可以自动根据Pod的健康状况来进行负载。</p><p>接下来，我们主要看下这个问题：当通过Kubernetes Service访问Pod时，如何实现高可用？</p><p>高可用原理如下图所示：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage65cd65dab9a3f07d5afed29aa616db14bdcd.803a2ea3.jpg" alt=""/></p><p>在Kubernetes中，我们可以给每个Pod打上标签（Label），标签是一个key-value对，例如<code>label: app=Nginx</code>。当我们访问Service时，Service会根据它配置的Label Selector，匹配具有相同Label的Pod，并将这些Pod的endpoint地址作为其后端RS。</p><p>举个例子，你可以看看上面的图片：Service的Label Selector是Labels<code>app=Nginx</code>，这样就会选择我们创建的具有<code>label: app=Nginx</code>的3个Pod实例。这时候，Service会根据其负载均衡策略，选取一个Pod将请求流量转发过去。当其中一个Pod故障时，Kubernetes会自动将故障Pod的endpoint从Service后端对应的RS列表中剔除。</p><p>由Deployment创建的ReplicaSet，这时候也会发现有一个Pod故障，健康的Pod实例数变为<code>2</code>，这时候跟其期望的值<code>3</code>不匹配，就会自动创建一个新的健康Pod，替换掉故障的Pod。因为新Pod满足Service的Label Selector，所以新Pod的endpoint会被Kubernetes自动添加到Service对应的endpoint列表中。</p><p>通过上面这些操作，Service后端的RS中，故障的Pod IP被新的、健康的Pod IP所替换，通过Service访问的后端Pod就都是健康的。这样，就通过Service实现了应用的高可用。</p><p>从上面的原理分析中，我们也可以发现，Service本质上是一个负载均衡器。</p><p>Kubernetes还提供了滚动更新（RollingUpdate）机制，来确保在发布时服务正常可用。这个机制的大致原理是：在更新时，先创建一个Pod，再销毁一个Pod，依次循环，直到所有的Pod都更新完成。在更新时，我们还可以控制每次更新的Pod数，以及最小可用的Pod数。</p><p>接下来，我们再来看下应用层的云原生架构设计和高可用设计。</p><h2 id="应用层的云原生架构设计"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#应用层的云原生架构设计"><span class="icon icon-link"></span></a>应用层的云原生架构设计</h2><p>在云原生架构中，我们采用微服务架构来构建应用。所以，这里我主要围绕着微服务架构的构建方式来介绍。先和你谈谈我对微服务的理解。</p><p>从本质上来说，微服务是一个轻量级的Web服务，只不过在微服务场景下，我们通常考虑的不是单个微服务，而是更多地考虑由多个微服务组成的应用。也就是说，一个应用由多个微服务组成，多个微服务就带来了一些单个Web服务不会面临的问题，例如部署复杂、排障困难、服务依赖复杂、通信链路长，等等。</p><p>在微服务场景下，除了编写单个微服务（轻量级的Web服务）之外，我们更多是要专注于解决应用微服务化所带来的挑战。所以，在我看来，微服务架构设计包括两个重要内容：</p><ul><li>单个微服务的构建方式；</li><li>解决应用微服务化带来的挑战。</li></ul><h3 id="微服务实现"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#微服务实现"><span class="icon icon-link"></span></a>微服务实现</h3><p>我们可以通过两种方式来构建微服务：</p><ul><li>采用Gin、Echo等轻量级Web框架。</li><li>采用微服务框架，例如 <a target="_blank" rel="noopener noreferrer" href="https://github.com/go-chassis/go-chassis">go-chassis<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://github.com/asim/go-micro">go-micro<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://github.com/go-kit/kit">go-kit<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>等。</li></ul><p>如果要解决应用微服务化带来的挑战，我们需要采用多种技术和手段，每种技术和手段会解决一个或一部分挑战。</p><p>综上，在我看来，微服务本质上是一个轻量级的Web服务，但又包含一系列的技术和手段，用来解决应用微服务化带来的挑战。微服务的技术栈如下图所示：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage7a657a860825662bb93f93c51c00efbdeb65.75aa056f.jpg" alt=""/></p><p>不同的技术栈可以由不同的方式来实现，并解决不同的问题：</p><ul><li>监控告警、日志、CI/CD、分布式调度，可以由Kubernetes平台提供的能力来实现。</li><li>服务网关、权限验证、负载均衡、限流/熔断/降级，可以由网关来实现，例如Tyk网关。</li><li>进程间通信、REST/RPC序列化，可以借助Web框架来实现，例如Gin、Go Chassis、gRPC、Sprint Cloud。</li><li>分布式追踪可以由Jaeger来实现。</li><li>统一配置管理可以由Apollo配置中心来实现。</li><li>消息队列可以由NSQ、Kafka、RabbitMQ来实现。</li></ul><p>上面的服务注册/服务发现，有3种实现方式：</p><ul><li>通过Kubernetes Service来进行服务注册/服务发现，Kubernetes自带服务注册/服务发现功能。使用此方式，我们不需要额外的开发。</li><li>通过服务中心来实现服务注册/服务发现功能。采用这种方式，需要我们开发并部署服务中心，服务中心通常可以使用etcd/consul/mgmet来实现，使用etcd的较多。</li><li>通过网关，来进行服务注册/服务发现。这种情况下，可以将服务信息直接上报给网关服务，也可以将服务信息上报到一个服务中心，例如etcd中，再由网关从服务中心中获取。</li></ul><p>这里要注意，原生的Kubernetes集群是不支持监控告警、日志、CI/CD等功能的。我们在使用Kubernetes集群时，通常会使用一个基于Kubernetes开发而来的Kubernetes平台，例如腾讯云容器服务TKE。</p><p>在Kubernetes平台中，通常会基于一些优秀的开源项目，进行二次开发，来实现平台的监控告警、日志、CI/CD等功能。</p><ul><li>监控告警：基于Prometheus来实现。</li><li>日志：基于EFK日志解决方案来实现。</li><li>CI/CD：可以自己研发，也可以基于优秀的开源项目来实现，例如 drone。</li></ul><h3 id="微服务架构设计"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#微服务架构设计"><span class="icon icon-link"></span></a>微服务架构设计</h3><p>上面我介绍了如何实现微服务，这里我再来具体讲讲，上面提到的各个组件/功能是如何有机组合在一起，共同构建一个微服务应用的。下面是微服务的架构图：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage02yy020fa7eccc352d03b78b57a1dbfc75yy.ba7fd28f.jpg" alt=""/></p><p>在上图中，我们将微服务应用层部署在Kubernetes集群中，在Kubernetes集群之上，可以构建微服务需要的其他功能，例如监控告警、CI/CD、日志、调用链等。这些功能共同完成应用的生命周期管理。</p><p>我们在微服务的最上面挂载负载均衡。客户端，例如移动端应用、Web应用、API调用等，都通过负载均衡来访问微服务。</p><p>微服务在启动时会将自己的endpoint信息（通常是<code>ip:port</code>格式）上报到服务中心。微服务也会定时上报自己的心跳到服务中心。在服务中心中，我们可以监控微服务的状态，剔除不健康的微服务，获取微服务之间的访问数据，等等。如果要通过网关调用微服务，或者需要使用网关做负载均衡，那我们还需要网关从服务中心中获取微服务的endpoint信息。</p><h3 id="微服务高可用架构设计"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#微服务高可用架构设计"><span class="icon icon-link"></span></a>微服务高可用架构设计</h3><p>我们再来看下如何设计微服务应用的高可用能力。</p><p>我们可以把所有微服务组件以Deployment/StatefulSet的形式部署在Kubernetes集群中，副本数至少设置为两个，更新方式为滚动更新，设置服务的监控检查，并通过Kubernetes Service或者负载均衡的方式访问服务。这样，我们就可以不用做任何改造，直接使用Kubernetes自有的容灾能力，实现微服务架构的高可用。</p><h2 id="云原生架构鸟瞰图"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#云原生架构鸟瞰图"><span class="icon icon-link"></span></a>云原生架构鸟瞰图</h2><p>上面，我介绍了系统资源层和应用层的云原生架构设计，但还不能构成整个云原生架构设计。这里，我通过一张云原生架构鸟瞰图，来整体介绍下云原生架构的设计方案。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage05b505c7cb8fd6c524242229ab9ea6c9b1b5.74230196.jpg" alt=""/></p><p>上图的云原生架构分为4层，除了前面提到的系统资源层、应用层、应用生命周期管理层之外，又加了统一接入层。接下来，我来介绍下这些层在云原生架构中的作用。</p><p>在最下面的<strong>系统资源层</strong>，我们除了提供传统的计算资源（物理机、虚拟机）之外，还可以提供容器化的计算资源和高可用的存储服务。其中，容器化的计算资源是基于传统的物理机/虚拟机来构建的。</p><p>在云原生架构中，我们更应该使用容器化的计算资源，通过Docker容器技术来隔离并对外提供计算资源，通过Kubernetes来编排容器。Docker + Kubernetes的组合使用，可以构建出一个非常优秀的系统资源层。这个系统资源层，自带了资源管理、容器调度、自动伸缩、网络通信、服务发现、健康检查等企业应用需要的核心能力。</p><p>在云原生时代，这些系统资源除了具有容器化、轻量化的特点之外，还越来越倾向于朝着Serverless化的方向去构建：系统资源免申请、免运维，按需计费，具备极致的弹性伸缩能力，并能够缩容到0。Serverless化的系统资源，可以使开发者只聚焦在应用层的应用功能开发上，而不用再把时间浪费在系统层的运维工作上。</p><p>在系统资源层之上，就可以构建我们的<strong>应用层</strong>了。云原生架构中，应用的构建方式，基本上都是采用的微服务架构。开发一个微服务应用，我们可以使用微服务框架，也可以不使用。二者的区别是，微服务框架替我们完成了服务治理相关功能，让我们不需要再开发这些功能。</p><p>在我看来，这一点有利有弊。好处当然是节省了开发工作量。至于坏处，主要有两方面：一方面，在实现方式和实现思路上，微服务框架所集成的服务治理功能并不一定是最适合我们的方案。另一方面，使用微服务框架还意味着我们的应用会跟微服务框架耦合，不能自由选择服务治理技术和方式。所以，在实际开发中，你应该根据需要，自行选择微服务的构建方式。</p><p>一般来说，一个微服务框架中，至少集成了这些服务治理功能：配置中心、调用链追踪、日志系统、监控、服务注册/服务发现。</p><p>再往上，我们就实现了<strong>统一接入层</strong>。统一接入层中包含了负载均衡和网关两个组件，其中负载均衡作为服务的唯一入口，供API、Web浏览器、手机终端等客户端访问。通过负载均衡，可以使我们的应用在故障时，能够自动切换实例，在负载过高时能够水平扩容。负载均衡下面还对接了网关，网关提供了一些通用能力，例如安全策略、路由策略、流量策略、统计分析、API管理等能力。</p><p>最后，我们还可以构建一系列的应用生命周期管理技术，例如服务编排、配置管理、日志、存储、审计、监控告警、消息队列、分布式链路追踪。这些技术中，一些可以基于Kubernetes，集成在我们的Kubernetes平台中，另一些则可以单独构建，供所有产品接入。</p><h2 id="公有云版云原生架构"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#公有云版云原生架构"><span class="icon icon-link"></span></a>公有云版云原生架构</h2><p>上面我们提到，云原生架构涉及到很多的技术栈。如果公司有能力，可以选择自己开发；如果觉得人力不够、成本太高，也可以使用公有云厂商已经开发好的云原生基础设施。使用云厂商的云原生基础设施，好处很明显：这些基础设施专业、稳定、免开发、免运维。</p><p>为了补全云原生架构设计版图，这里我也介绍一个公用云版的云原生架构设计。那么，公有云厂商会提供哪些云原生基础设施呢？这里我介绍下腾讯云提供的云原生解决方案。解决方案全景如下图所示：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage44204473c11e51fa0976d91202fc7c836020.24c6ab4f.jpg" alt=""/></p><p>可以看到，<strong>腾讯云提供了全栈的云原生能力。</strong></p><p>腾讯云基于底层的云原生能力，提供了一系列的云原生解决方案。这些解决方案，是已经设计好的云原生架构构建方案，可以帮助企业快速落地云原生架构，例如混合云解决方案、AI解决方案、IoT解决方案等。</p><p>那么，腾讯云底层提供了哪些云原生能力呢？我们一起来看下。</p><p>在应用层，通过TSF微服务平台，我们可以实现微服务的构建，以及微服务的服务治理能力。另外，还提供了更多的应用构建架构，例如：</p><ul><li>Serverless Framework，可以构建Serverless应用。</li><li>CloudBase，云原生一体化应用开发平台，可以快速构建小程序、Web、移动应用。</li><li>…</li></ul><p>在系统资源层，腾讯云提供了多种计算资源提供形态。例如：通过TKE，可以创建原生的Kubernetes集群；通过EKS，可以创建Serverless化的Kubernetes集群；通过<a target="_blank" rel="noopener noreferrer" href="https://github.com/superedge/superedge">TKE-Edge<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，可以创建能够纳管边缘节点的Kubernetes集群。此外，还提供了开源容器服务平台<a target="_blank" rel="noopener noreferrer" href="https://github.com/tkestack/tke">TKEStack<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，TKEStack是一个非常优秀的容器云平台，在代码质量、稳定性、平台功能等方面，都在开源的容器云平台中处于龙头地位，也欢迎你Star。</p><p>在应用生命周期管理这一层，提供了云原生的etcd、Prometheus服务。此外，还提供了CLS日志系统，供你保存并查询应用日志；提供了云监控，供你监控自己的应用程序；提供了容器镜像服务（TCR），用来保存Docker镜像；提供了CODING DevOps平台，用来支持应用的CI/CD；提供了调用链跟踪服务（TDW），用来展示微服务的调用链。</p><p>在统一接入层，腾讯云提供了功能强大的API网关。此外，还提供了多种Serverless化的中间件服务，例如消息队列TDMQ、云原生数据库TDSQL等。</p><p>所有这些云原生基础设施，都有共同的特点，就是免部署、免运维。换句话说，在腾讯云，你可以只专注于使用编程语言编写你的业务逻辑，其他的一切都交给腾讯云来搞定。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#总结"><span class="icon icon-link"></span></a>总结</h2><p>云原生架构设计，包含了系统资源层、应用层、统一接入层和应用生命周期管理层4层。</p><p>在系统资源层，可以采用Docker + Kubernetes的方式来提供计算资源。我们所有的应用和应用生命周期管理相关的服务，都可以部署在Kubernetes集群中，利用Kubernetes集群的能力实现服务发现/服务注册、弹性伸缩、资源调度等核心能力。</p><p>在应用层，可以采用微服务架构，来构建我们的应用。具体构建时，我们可以根据需要，采用类似Gin这种轻量级的Web框架来构建应用，然后再实现旁路的服务治理功能；也可以采用集成了很多服务治理功能的微服务框架，例如 go-chassis、go-micro等。</p><p>因为我们采用了微服务架构，为了能够将微服务的一些功能，例如：认证授权、限流等功能最大化的复用，我们又提供了统一接入层。可以通过API网关、负载均衡、服务网格等技术来构建统一接入层。</p><p>在应用生命周期管理这一层，我们可以实现一些云原生的管理平台，例如 DevOps、监控告警、日志、配置中心等，并使我们的应用以云原生化的方式接入这些平台，使用这些平台提供的能力。</p><p>最后，我还介绍了腾讯云的云原生基础设施。通过腾讯云提供的云原生能力，你可以专注于使用编程语言编写你的业务逻辑，其他的各种云原生能力，都可以交给云厂商来帮你实现。</p><h2 id="课后练习"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06#课后练习"><span class="icon icon-link"></span></a>课后练习</h2><ol><li>思考下，服务注册/服务发现的3种实现方式中，哪种方法适用于你的项目，为什么？</li><li>思考下，在设计云原生架构时，还需要考虑哪些重要的点？欢迎你在留言区分享。</li></ol><p>欢迎你在留言区与我交流讨论，我们下一讲见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/go语言项目开发实战/07.实战第5站服务部署/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
