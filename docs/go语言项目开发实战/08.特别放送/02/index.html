<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>特别放送 | 给你一份Go项目中最常用的Makefile核心语法 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/go语言项目开发实战/08.特别放送/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/go语言项目开发实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-backend/go语言项目开发实战/01.开篇词/01"><span>开篇词 | 从 0 开始搭建一个企业级 Go 应用</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/02.课前必学">02.课前必学</a><ul><li><a href="/blog-backend/go语言项目开发实战/02.课前必学/01"><span>01 | IAM系统概述：我们要实现什么样的 Go 项目？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/02.课前必学/02"><span>02 | 环境准备：如何安装和配置一个基本的 Go 开发环境？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/02.课前必学/03"><span>03 | 项目部署：如何快速部署 IAM 系统？</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计">03.实战第1站规范设计</a><ul><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/01"><span>04 | 规范设计（上）：项目开发杂乱无章，如何规范？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/02"><span>05 | 规范设计（下）：commit 信息风格迥异、难以阅读，如何规范？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/03"><span>06 | 目录结构设计：如何组织一个可维护、可扩展的代码目录？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04"><span>07 | 工作流设计：如何设计合理的多人开发模式？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/05"><span>08 | 研发流程设计（上）：如何设计 Go 项目的开发流程？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/06"><span>09 | 研发流程设计（下）：如何管理应用的生命周期？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/07"><span>10 | 设计方法：怎么写出优雅的 Go 项目？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/08"><span>11 | 设计模式：Go常用设计模式概述</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发">04.实战第2站基础功能设计或开发</a><ul><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/01"><span>12 | API 风格（上）：如何设计RESTful API？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/02"><span>13 | API 风格（下）：RPC API介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/03"><span>14 | 项目管理：如何编写高质量的Makefile？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/04"><span>15 | 研发流程实战：IAM项目是如何进行研发流程管理的？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/05"><span>16 | 代码检查：如何进行静态代码检查？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/06"><span>17 | API 文档：如何生成 Swagger API 文档 ？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/07"><span>18 | 错误处理（上）：如何设计一套科学的错误码？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/08"><span>19 | 错误处理（下）：如何设计错误包？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/09"><span>20 | 日志处理（上）：如何设计日志包并记录日志？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/10"><span>21 | 日志处理（下）：手把手教你从 0 编写一个日志包</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/11"><span>22 | 应用构建三剑客：Pflag、Viper、Cobra 核心功能介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/12"><span>23 | 应用构建实战：如何构建一个优秀的企业应用框架？</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发">05.实战第3站服务开发</a><ul><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/01"><span>24 | Web 服务：Web 服务核心功能有哪些，如何实现？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/02"><span>25 | 认证机制：应用程序如何进行访问认证？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/03"><span>26 | IAM项目是如何设计和实现访问认证功能的？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/04"><span>27 | 权限模型：5大权限模型是如何进行资源授权的？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/05"><span>28 | 控制流（上）：通过iam-apiserver设计，看Web服务的构建</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/06"><span>29｜控制流（下）：iam-apiserver服务核心功能实现讲解</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/07"><span>30 | ORM：CURD 神器 GORM 包介绍及实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/08"><span>31 | 数据流：通过iam-authz-server设计，看数据流服务的设计</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/09"><span>32 | 数据处理：如何高效处理应用程序产生的数据？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/10"><span>33 |  SDK 设计（上）：如何设计出一个优秀的 Go SDK？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11"><span>34 | SDK 设计（下）：IAM项目Go SDK设计和实现</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/12"><span>35 | 效率神器：如何设计和实现一个命令行客户端工具？</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试">06.实战第4站服务测试</a><ul><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/01"><span>36 | 代码测试（上）：如何编写 Go 语言单元测试和性能测试用例？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/02"><span>37 | 代码测试（下）：Go 语言其他测试类型及 IAM 测试介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/03"><span>38｜性能分析（上）：如何分析 Go 语言代码的性能？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/04"><span>39｜性能分析（下）：API Server性能测试和调优实战</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署">07.实战第5站服务部署</a><ul><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/01"><span>40 | 软件部署实战（上）：部署方案及负载均衡、高可用组件介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/02"><span>41 | 软件部署实战（中）：IAM 系统生产环境部署实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/03"><span>42 | 软件部署实战（下）：IAM系统安全加固、水平扩缩容实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/04"><span>43｜技术演进（上）：虚拟化技术演进之路</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/05"><span>44｜技术演进（下）：软件架构和应用生命周期技术演进之路</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06"><span>45｜基于Kubernetes的云原生架构设计</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/07"><span>46 | 如何制作Docker镜像？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/08"><span>47 | 如何编写Kubernetes资源定义文件？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/09"><span>48 | 基于腾讯云 EKS 的容器化部署实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/10"><span>49 | 服务编排（上）：Helm服务编排基础知识</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/11"><span>50 | 服务编排（下）：基于Helm的服务编排部署实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/12"><span>51 | 基于 GitHub Actions 的 CI 实战</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战/08.特别放送">08.特别放送</a><ul><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/01"><span>特别放送 | 给你一份清晰、可直接套用的Go编码规范</span></a></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战/08.特别放送/02"><span>特别放送 | 给你一份Go项目中最常用的Makefile核心语法</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/03"><span>特别放送 | Go Modules依赖包管理全讲</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/04"><span>特别放送 | IAM排障指南</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/05"><span>特别放送 | Go Modules实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/06"><span>特别放送 | 分布式作业系统设计和实现</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/07"><span>直播加餐｜如何从小白进阶成 Go 语言专家？</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/09.结束语">09.结束语</a><ul><li><a href="/blog-backend/go语言项目开发实战/09.结束语/01"><span>结束语 | 如何让自己的 Go 研发之路走得更远？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/09.结束语/02"><span>期末考试｜《Go语言项目开发实战》满分试卷，等你来挑战！</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/summary">go语言项目开发实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="Makefile的使用方法" data-depth="2"><a href="/blog-backend/go语言项目开发实战/08.特别放送/02#makefile的使用方法"><span>Makefile的使用方法</span></a></li><li title="Makefile规则介绍" data-depth="2"><a href="/blog-backend/go语言项目开发实战/08.特别放送/02#makefile规则介绍"><span>Makefile规则介绍</span></a></li><li title="规则语法" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/02#规则语法"><span>规则语法</span></a></li><li title="伪目标" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/02#伪目标"><span>伪目标</span></a></li><li title="order-only依赖" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/02#order-only依赖"><span>order-only依赖</span></a></li><li title="Makefile语法概览" data-depth="2"><a href="/blog-backend/go语言项目开发实战/08.特别放送/02#makefile语法概览"><span>Makefile语法概览</span></a></li><li title="命令" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/02#命令"><span>命令</span></a></li><li title="变量" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/02#变量"><span>变量</span></a></li><li title="条件语句" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/02#条件语句"><span>条件语句</span></a></li><li title="函数" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/02#函数"><span>函数</span></a></li><li title="引入其他Makefile" data-depth="2"><a href="/blog-backend/go语言项目开发实战/08.特别放送/02#引入其他makefile"><span>引入其他Makefile</span></a></li><li title="总结" data-depth="2"><a href="/blog-backend/go语言项目开发实战/08.特别放送/02#总结"><span>总结</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="特别放送--给你一份go项目中最常用的makefile核心语法"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/02#特别放送--给你一份go项目中最常用的makefile核心语法"><span class="icon icon-link"></span></a>特别放送 | 给你一份Go项目中最常用的Makefile核心语法</h1><p>你好，我是孔令飞。今天，我们更新一期特别放送作为“加餐”，希望日常催更的朋友们食用愉快。</p><p>在第 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/388920"><strong>14讲</strong></a> 里**，**我强调了熟练掌握Makefile语法的重要性，还推荐你去学习陈皓老师编写的<a target="_blank" rel="noopener noreferrer" href="https://github.com/seisman/how-to-write-makefile">《跟我一起写 Makefile》 (PDF 重制版)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。也许你已经点开了链接，看到那么多Makefile语法，是不是有点被“劝退”的感觉？</p><p>其实在我看来，虽然Makefile有很多语法，但不是所有的语法都需要你熟练掌握，有些语法在Go项目中是很少用到的。要编写一个高质量的Makefile，首先应该掌握一些核心的、最常用的语法知识。这一讲我就来具体介绍下Go项目中常用的Makefile语法和规则，帮助你快速打好最重要的基础。</p><p>Makefile文件由三个部分组成，分别是Makefile规则、Makefile语法和Makefile命令（这些命令可以是Linux命令，也可以是可执行的脚本文件）。在这一讲里，我会介绍下Makefile规则和Makefile语法里的一些核心语法知识。在介绍这些语法知识之前，我们先来看下如何使用Makefile脚本。</p><h2 id="makefile的使用方法"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/02#makefile的使用方法"><span class="icon icon-link"></span></a>Makefile的使用方法</h2><p>在实际使用过程中，我们一般是先编写一个Makefile文件，指定整个项目的编译规则，然后通过Linux make命令来解析该Makefile文件，实现项目编译、管理的自动化。</p><p>默认情况下，make命令会在当前目录下，按照GNUmakefile、makefile、Makefile文件的顺序查找Makefile文件，一旦找到，就开始读取这个文件并执行。</p><p>大多数的make都支持“makefile”和“Makefile”这两种文件名，但<strong>我建议使用“Makefile”</strong>。因为这个文件名第一个字符大写，会很明显，容易辨别。make也支持 <code>-f</code> 和 <code>--file</code> 参数来指定其他文件名，比如 <code>make \-f golang.mk</code> 或者 <code>make \--file golang.mk</code> 。</p><h2 id="makefile规则介绍"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/02#makefile规则介绍"><span class="icon icon-link"></span></a>Makefile规则介绍</h2><p>学习Makefile，最核心的就是学习Makefile的规则。规则是Makefile中的重要概念，它一般由目标、依赖和命令组成，用来指定源文件编译的先后顺序。Makefile之所以受欢迎，核心原因就是Makefile规则，因为Makefile规则可以自动判断是否需要重新编译某个目标，从而确保目标仅在需要时编译。</p><p>这一讲我们主要来看Makefile规则里的规则语法、伪目标和order-only依赖。</p><h3 id="规则语法"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/02#规则语法"><span class="icon icon-link"></span></a>规则语法</h3><p>Makefile的规则语法，主要包括target、prerequisites和command，示例如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">target ...: prerequisites ...</span></div><div class="token-line"><span class="token plain">        command</span></div><div class="token-line"><span class="token plain">    	  ...</span></div><div class="token-line"><span class="token plain">    	  ...</span></div></pre></div><p>**target，**可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。target可使用通配符，当有多个目标时，目标之间用空格分隔。</p><p>**prerequisites，**代表生成该target所需要的依赖项。当有多个依赖项时，依赖项之间用空格分隔。</p><p><strong>command</strong>，代表该target要执行的命令（可以是任意的shell命令）。</p><ul><li>在执行command之前，默认会先打印出该命令，然后再输出命令的结果；如果不想打印出命令，可在各个command前加上<code>@</code>。</li><li>command可以为多条，也可以分行写，但每行都要以tab键开始。另外，如果后一条命令依赖前一条命令，则这两条命令需要写在同一行，并用分号进行分隔。</li><li>如果要忽略命令的出错，需要在各个command之前加上减号<code>-</code>。</li></ul><p><strong>只要targets不存在，或prerequisites中有一个以上的文件比targets文件新，那么command所定义的命令就会被执行，从而产生我们需要的文件，或执行我们期望的操作。</strong></p><p>我们直接通过一个例子来理解下Makefile的规则吧。</p><p>第一步，先编写一个hello.c文件。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;stdio.h&gt;</span></div><div class="token-line"><span class="token plain">    int main()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      printf(&quot;Hello World!\n&quot;);</span></div><div class="token-line"><span class="token plain">      return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>第二步，在当前目录下，编写Makefile文件。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">hello: hello.o</span></div><div class="token-line"><span class="token plain">    	gcc -o hello hello.o</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    hello.o: hello.c</span></div><div class="token-line"><span class="token plain">    	gcc -c hello.c</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    clean:</span></div><div class="token-line"><span class="token plain">    	rm hello.o</span></div></pre></div><p>第三步，执行make，产生可执行文件。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ make</span></div><div class="token-line"><span class="token plain">    gcc -c hello.c</span></div><div class="token-line"><span class="token plain">    gcc -o hello hello.o</span></div><div class="token-line"><span class="token plain">    $ ls</span></div><div class="token-line"><span class="token plain">    hello  hello.c  hello.o  Makefile</span></div></pre></div><p>上面的示例Makefile文件有两个target，分别是hello和hello.o，每个target都指定了构建command。当执行make命令时，发现hello、hello.o文件不存在，就会执行command命令生成target。</p><p>第四步，不更新任何文件，再次执行make。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ make</span></div><div class="token-line"><span class="token plain">    make: &#x27;hello&#x27; is up to date.</span></div></pre></div><p>当target存在，并且prerequisites都不比target新时，不会执行对应的command。</p><p>第五步，更新hello.c，并再次执行make。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ touch hello.c</span></div><div class="token-line"><span class="token plain">    $ make</span></div><div class="token-line"><span class="token plain">    gcc -c hello.c</span></div><div class="token-line"><span class="token plain">    gcc -o hello hello.o</span></div></pre></div><p>当target存在，但 prerequisites 比 target 新时，会重新执行对应的command。</p><p>第六步，清理编译中间文件。</p><p>Makefile一般都会有一个clean伪目标，用来清理编译中间产物，或者对源码目录做一些定制化的清理：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ make clean</span></div><div class="token-line"><span class="token plain">    rm hello.o</span></div></pre></div><p>我们可以在规则中使用通配符，make 支持三个通配符：*，?和~，例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">objects = *.o</span></div><div class="token-line"><span class="token plain">    print: *.c</span></div><div class="token-line"><span class="token plain">        rm *.c</span></div></pre></div><h3 id="伪目标"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/02#伪目标"><span class="icon icon-link"></span></a>伪目标</h3><p>接下来我们介绍下Makefile中的伪目标。Makefile的管理能力基本上都是通过伪目标来实现的。</p><p>在上面的Makefile示例中，我们定义了一个clean目标，这其实是一个伪目标，也就是说我们不会为该目标生成任何文件。因为伪目标不是文件，make 无法生成它的依赖关系，也无法决定是否要执行它。</p><p>通常情况下，我们需要显式地标识这个目标为伪目标。在Makefile中可以使用<code>.PHONY</code>来标识一个目标为伪目标：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">.PHONY: clean</span></div><div class="token-line"><span class="token plain">    clean:</span></div><div class="token-line"><span class="token plain">        rm hello.o</span></div></pre></div><p>伪目标可以有依赖文件，也可以作为“默认目标”，例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">.PHONY: all</span></div><div class="token-line"><span class="token plain">    all: lint test build</span></div></pre></div><p>因为伪目标总是会被执行，所以其依赖总是会被决议。通过这种方式，可以达到<strong>同时执行所有依赖项</strong>的目的。</p><h3 id="order-only依赖"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/02#order-only依赖"><span class="icon icon-link"></span></a>order-only依赖</h3><p>在上面介绍的规则中，只要prerequisites中有任何文件发生改变，就会重新构造target。但是有时候，我们希望**只有当prerequisites中的部分文件改变时，才重新构造target。**这时，你可以通过order-only prerequisites实现。</p><p>order-only prerequisites的形式如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">targets : normal-prerequisites | order-only-prerequisites</span></div><div class="token-line"><span class="token plain">        command</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">        ...</span></div></pre></div><p>在上面的规则中，只有第一次构造targets时，才会使用order-only-prerequisites。后面即使order-only-prerequisites发生改变，也不会重新构造targets。</p><p>只有normal-prerequisites中的文件发生改变时，才会重新构造targets。这里，符号“ | ”后面的prerequisites就是order-only-prerequisites。</p><p>到这里，我们就介绍了Makefile的规则。接下来，我们再来看下Makefile中的一些核心语法知识。</p><h2 id="makefile语法概览"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/02#makefile语法概览"><span class="icon icon-link"></span></a>Makefile语法概览</h2><p>因为Makefile的语法比较多，这一讲只介绍Makefile的核心语法，以及 IAM项目的Makefile用到的语法，包括命令、变量、条件语句和函数。因为Makefile没有太多复杂的语法，你掌握了这些知识点之后，再在实践中多加运用，融会贯通，就可以写出非常复杂、功能强大的Makefile文件了。</p><h3 id="命令"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/02#命令"><span class="icon icon-link"></span></a>命令</h3><p>Makefile支持Linux命令，调用方式跟在Linux系统下调用命令的方式基本一致。默认情况下，make会把正在执行的命令输出到当前屏幕上。但我们可以通过在命令前加<code>@</code>符号的方式，禁止make输出当前正在执行的命令。</p><p>我们看一个例子。现在有这么一个Makefile：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">.PHONY: test</span></div><div class="token-line"><span class="token plain">    test:</span></div><div class="token-line"><span class="token plain">        echo &quot;hello world&quot;</span></div></pre></div><p>执行make命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ make test</span></div><div class="token-line"><span class="token plain">    echo &quot;hello world&quot;</span></div><div class="token-line"><span class="token plain">    hello world</span></div></pre></div><p>可以看到，make输出了执行的命令。很多时候，我们不需要这样的提示，因为我们更想看的是命令产生的日志，而不是执行的命令。这时就可以在命令行前加<code>@</code>，禁止make输出所执行的命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">.PHONY: test</span></div><div class="token-line"><span class="token plain">    test:</span></div><div class="token-line"><span class="token plain">        @echo &quot;hello world&quot;</span></div></pre></div><p>再次执行make命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ make test</span></div><div class="token-line"><span class="token plain">    hello world</span></div></pre></div><p>可以看到，make只是执行了命令，而没有打印命令本身。这样make输出就清晰了很多。</p><p>这里，<strong>我建议在命令前都加</strong><code>@</code>符号，禁止打印命令本身，以保证你的Makefile输出易于阅读的、有用的信息。</p><p>默认情况下，每条命令执行完make就会检查其返回码。如果返回成功（返回码为0），make就执行下一条指令；如果返回失败（返回码非0），make就会终止当前命令。很多时候，命令出错（比如删除了一个不存在的文件）时，我们并不想终止，这时就可以在命令行前加 <code>-</code> 符号，来让make忽略命令的出错，以继续执行下一条命令，比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">clean:</span></div><div class="token-line"><span class="token plain">        -rm hello.o</span></div></pre></div><h3 id="变量"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/02#变量"><span class="icon icon-link"></span></a>变量</h3><p>变量，可能是Makefile中使用最频繁的语法了，Makefile支持变量赋值、多行变量和环境变量。另外，Makefile还内置了一些特殊变量和自动化变量。</p><p>我们先来看下最基本的<strong>变量赋值</strong>功能。</p><p>Makefile也可以像其他语言一样支持变量。在使用变量时，会像shell变量一样原地展开，然后再执行替换后的内容。</p><p>Makefile可以通过变量声明来声明一个变量，变量在声明时需要赋予一个初值，比如<code>ROOT_PACKAGE=github.com/marmotedu/iam</code>。</p><p>引用变量时可以通过<code>$()</code>或者<code>$<!-- -->{<!-- -->}</code>方式引用。我的建议是，用<code>$()</code>方式引用变量，例如<code>$(ROOT_PACKAGE)</code>，也建议整个makefile的变量引用方式保持一致。</p><p>变量会像bash变量一样，在使用它的地方展开。比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">GO=go</span></div><div class="token-line"><span class="token plain">    build:</span></div><div class="token-line"><span class="token plain">        $(GO) build -v .</span></div></pre></div><p>展开后为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">GO=go</span></div><div class="token-line"><span class="token plain">    build:</span></div><div class="token-line"><span class="token plain">        go build -v .</span></div></pre></div><p>接下来，我给你介绍下Makefile中的4种变量赋值方法。</p><ol><li><code>=</code> 最基本的赋值方法。</li></ol><p>例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">BASE_IMAGE = alpine:3.10</span></div></pre></div><p>使用 <code>=</code> 进行赋值时，要注意下面这样的情况：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">A = a</span></div><div class="token-line"><span class="token plain">    B = $(A) b</span></div><div class="token-line"><span class="token plain">    A = c</span></div></pre></div><p>B最后的值为 c b，而不是a b。也就是说，在用变量给变量赋值时，右边变量的取值，取的是最终的变量值。</p><ol start="2"><li><code>:=</code>直接赋值，赋予当前位置的值。</li></ol><p>例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">A = a</span></div><div class="token-line"><span class="token plain">    B := $(A) b</span></div><div class="token-line"><span class="token plain">    A = c</span></div></pre></div><p>B最后的值为 a b。通过 <code>:=</code> 的赋值方式，可以避免 <code>=</code> 赋值带来的潜在的不一致。</p><ol start="3"><li><code>?=</code> 表示如果该变量没有被赋值，则赋予等号后的值。</li></ol><p>例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">PLATFORMS ?= linux_amd64 linux_arm64</span></div></pre></div><ol start="4"><li><code>+=</code>表示将等号后面的值添加到前面的变量上。</li></ol><p>例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">MAKEFLAGS += --no-print-directory</span></div></pre></div><p>Makefile还支持<strong>多行变量</strong>。可以通过define关键字设置多行变量，变量中允许换行。定义方式为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">define 变量名</span></div><div class="token-line"><span class="token plain">    变量内容</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    endef</span></div></pre></div><p>变量的内容可以包含函数、命令、文字或是其他变量。例如，我们可以定义一个USAGE_OPTIONS变量：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">define USAGE_OPTIONS</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Options:</span></div><div class="token-line"><span class="token plain">      DEBUG        Whether to generate debug symbols. Default is 0.</span></div><div class="token-line"><span class="token plain">      BINS         The binaries to build. Default is all of cmd.</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">      V            Set to 1 enable verbose build. Default is 0.</span></div><div class="token-line"><span class="token plain">    endef</span></div></pre></div><p>Makefile还支持<strong>环境变量</strong>。在Makefile中，有两种环境变量，分别是Makefile预定义的环境变量和自定义的环境变量。</p><p>其中，自定义的环境变量可以覆盖Makefile预定义的环境变量。默认情况下，Makefile中定义的环境变量只在当前Makefile有效，如果想向下层传递（Makefile中调用另一个Makefile），需要使用export关键字来声明。</p><p>下面的例子声明了一个环境变量，并可以在下层Makefile中使用：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">...</span></div><div class="token-line"><span class="token plain">    export USAGE_OPTIONS</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><p>此外，Makefile还支持两种内置的变量：特殊变量和自动化变量。</p><p><strong>特殊变量</strong>是make提前定义好的，可以在makefile中直接引用。特殊变量列表如下：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimagec11dc1cba21aaed2eb0117yyb0470byy641d.58d1c604.png" alt=""/></p><p>Makefile还支持<strong>自动化变量</strong>。自动化变量可以提高我们编写Makefile的效率和质量。</p><p>在Makefile的模式规则中，目标和依赖文件都是一系列的文件，那么我们如何书写一个命令，来完成从不同的依赖文件生成相对应的目标呢？</p><p>这时就可以用到自动化变量。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，一直到所有符合模式的文件都取完为止。这种自动化变量只应出现在规则的命令中。Makefile中支持的自动化变量见下表。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage131213ec33008eaff973c0dd854a795ff712.8699f90a.png" alt=""/></p><p>上面这些自动化变量中，<code>$*</code>是用得最多的。<code>$*</code> 对于构造有关联的文件名是比较有效的。如果目标中没有模式的定义，那么 <code>$*</code> 也就不能被推导出。但是，如果目标文件的后缀是make所识别的，那么 <code>$*</code> 就是除了后缀的那一部分。例如：如果目标是foo.c ，因为.c是make所能识别的后缀名，所以 <code>$*</code> 的值就是foo。</p><h3 id="条件语句"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/02#条件语句"><span class="icon icon-link"></span></a>条件语句</h3><p>Makefile也支持条件语句。这里先看一个示例。</p><p>下面的例子判断变量<code>ROOT_PACKAGE</code>是否为空，如果为空，则输出错误信息，不为空则打印变量值：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ifeq ($(ROOT_PACKAGE),)</span></div><div class="token-line"><span class="token plain">    $(error the variable ROOT_PACKAGE must be set prior to including golang.mk)</span></div><div class="token-line"><span class="token plain">    else</span></div><div class="token-line"><span class="token plain">    $(info the value of ROOT_PACKAGE is $(ROOT_PACKAGE))</span></div><div class="token-line"><span class="token plain">    endif</span></div></pre></div><p>条件语句的语法为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># if ...</span></div><div class="token-line"><span class="token plain">    &lt;conditional-directive&gt;</span></div><div class="token-line"><span class="token plain">    &lt;text-if-true&gt;</span></div><div class="token-line"><span class="token plain">    endif</span></div><div class="token-line"><span class="token plain">    # if ... else ...</span></div><div class="token-line"><span class="token plain">    &lt;conditional-directive&gt;</span></div><div class="token-line"><span class="token plain">    &lt;text-if-true&gt;</span></div><div class="token-line"><span class="token plain">    else</span></div><div class="token-line"><span class="token plain">    &lt;text-if-false&gt;</span></div><div class="token-line"><span class="token plain">    endif</span></div></pre></div><p>例如，判断两个值是否相等：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ifeq 条件表达式</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    else</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    endif</span></div></pre></div><ul><li>ifeq表示条件语句的开始，并指定一个条件表达式。表达式包含两个参数，参数之间用逗号分隔，并且表达式用圆括号括起来。</li><li>else表示条件表达式为假的情况。</li><li>endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。</li><li>表示条件关键字，有4个关键字：ifeq、ifneq、ifdef、ifndef。</li></ul><p>为了加深你的理解，我们分别来看下这4个关键字的例子。</p><ol><li>ifeq：条件判断，判断是否相等。</li></ol><p>例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ifeq (&lt;arg1&gt;, &lt;arg2&gt;)</span></div><div class="token-line"><span class="token plain">    ifeq &#x27;&lt;arg1&gt;&#x27; &#x27;&lt;arg2&gt;&#x27;</span></div><div class="token-line"><span class="token plain">    ifeq &quot;&lt;arg1&gt;&quot; &quot;&lt;arg2&gt;&quot;</span></div><div class="token-line"><span class="token plain">    ifeq &quot;&lt;arg1&gt;&quot; &#x27;&lt;arg2&gt;&#x27;</span></div><div class="token-line"><span class="token plain">    ifeq &#x27;&lt;arg1&gt;&#x27; &quot;&lt;arg2&gt;&quot;</span></div></pre></div><p>比较arg1和arg2的值是否相同，如果相同则为真。也可以用make函数/变量替代arg1或arg2，例如 <code>ifeq ($(origin ROOT_DIR),undefined)</code> 或 <code>ifeq ($(ROOT_PACKAGE),)</code> 。origin函数会在之后专门讲函数的一讲中介绍到。</p><ol start="2"><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ifneq：条件判断，判断是否不相等。</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ifneq (&lt;arg1&gt;, &lt;arg2&gt;)</span></div><div class="token-line"><span class="token plain">    ifneq &#x27;&lt;arg1&gt;&#x27; &#x27;&lt;arg2&gt;&#x27;</span></div><div class="token-line"><span class="token plain">    ifneq &quot;&lt;arg1&gt;&quot; &quot;&lt;arg2&gt;&quot;</span></div><div class="token-line"><span class="token plain">    ifneq &quot;&lt;arg1&gt;&quot; &#x27;&lt;arg2&gt;&#x27;</span></div><div class="token-line"><span class="token plain">    ifneq &#x27;&lt;arg1&gt;&#x27; &quot;&lt;arg2&gt;&quot;</span></div></pre></div><p>比较arg1和arg2的值是否不同，如果不同则为真。</p><ol start="3"><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ifdef：条件判断，判断变量是否已定义。</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ifdef &lt;variable-name&gt;</span></div></pre></div><p>如果值非空，则表达式为真，否则为假。也可以是函数的返回值。</p><ol start="4"><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ifndef：条件判断，判断变量是否未定义。</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ifndef &lt;variable-name&gt;</span></div></pre></div><p>如果值为空，则表达式为真，否则为假。也可以是函数的返回值。</p><h3 id="函数"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/02#函数"><span class="icon icon-link"></span></a>函数</h3><p>Makefile同样也支持函数，函数语法包括定义语法和调用语法。</p><p><strong>我们先来看下自定义函数。</strong> make解释器提供了一系列的函数供Makefile调用，这些函数是Makefile的预定义函数。我们可以通过define关键字来自定义一个函数。自定义函数的语法为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">define 函数名</span></div><div class="token-line"><span class="token plain">    函数体</span></div><div class="token-line"><span class="token plain">    endef</span></div></pre></div><p>例如，下面这个自定义函数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">define Foo</span></div><div class="token-line"><span class="token plain">        @echo &quot;my name is $(0)&quot;</span></div><div class="token-line"><span class="token plain">        @echo &quot;param is $(1)&quot;</span></div><div class="token-line"><span class="token plain">    endef</span></div></pre></div><p>define本质上是定义一个多行变量，可以在call的作用下当作函数来使用，在其他位置使用只能作为多行变量来使用，例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var := $(call Foo)</span></div><div class="token-line"><span class="token plain">    new := $(Foo)</span></div></pre></div><p>自定义函数是一种过程调用，没有任何的返回值。可以使用自定义函数来定义命令的集合，并应用在规则中。</p><p><strong>再来看下预定义函数。</strong> 刚才提到，make编译器也定义了很多函数，这些函数叫作预定义函数，调用语法和变量类似，语法为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$(&lt;function&gt; &lt;arguments&gt;)</span></div></pre></div><p>或者</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">${&lt;function&gt; &lt;arguments&gt;}</span></div></pre></div><p><code>&lt;function&gt;</code>是函数名，<code>&lt;arguments&gt;</code>是函数参数，参数间用逗号分割。函数的参数也可以是变量。</p><p>我们来看一个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">PLATFORM = linux_amd64</span></div><div class="token-line"><span class="token plain">    GOOS := $(word 1, $(subst _, ,$(PLATFORM)))</span></div></pre></div><p>上面的例子用到了两个函数：word和subst。word函数有两个参数，1和subst函数的输出。subst函数将PLATFORM变量值中的_替换成空格（替换后的PLATFORM值为linux amd64）。word函数取linux amd64字符串中的第一个单词。所以最后GOOS的值为linux。</p><p>Makefile预定义函数能够帮助我们实现很多强大的功能，在编写Makefile的过程中，如果有功能需求，可以优先使用这些函数。如果你想使用这些函数，那就需要知道有哪些函数，以及它们实现的功能。</p><p>常用的函数包括下面这些，你需要先有个印象，以后用到时再来查看。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage965f96da0853e8225a656d2c0489e544865f.21051c61.jpg" alt=""/></p><h2 id="引入其他makefile"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/02#引入其他makefile"><span class="icon icon-link"></span></a>引入其他Makefile</h2><p>除了Makefile规则、Makefile语法之外，Makefile还有很多特性，比如可以引入其他Makefile、自动生成依赖关系、文件搜索等等。这里我再介绍一个IAM项目的Makefile用到的重点特性：引入其他Makefile。</p><p>在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/388920"><strong>14讲</strong></a> 中，我们介绍过Makefile要结构化、层次化，这一点可以通过<strong>在项目根目录下的Makefile中引入其他Makefile</strong>来实现。</p><p>在Makefile中，我们可以通过关键字include，把别的makefile包含进来，类似于C语言的<code>#include</code>，被包含的文件会插入在当前的位置。include用法为<code>include &lt;filename&gt;</code>，示例如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">include scripts/make-rules/common.mk</span></div><div class="token-line"><span class="token plain">    include scripts/make-rules/golang.mk</span></div></pre></div><p>include也可以包含通配符<code>include scripts/make-rules/*</code>。make命令会按下面的顺序查找makefile文件：</p><ol><li>如果是绝对或相对路径，就直接根据路径include进来。</li><li>如果make执行时，有<code>-I</code>或<code>--include-dir</code>参数，那么make就会在这个参数所指定的目录下去找。</li><li>如果目录<code>&lt;prefix&gt;/include</code>（一般是<code>/usr/local/bin</code>或<code>/usr/include</code>）存在的话，make也会去找。</li></ol><p>如果有文件没有找到，make会生成一条警告信息，但不会马上出现致命错误，而是继续载入其他的文件。一旦完成makefile的读取，make会再重试这些没有找到或是不能读取的文件。如果还是不行，make才会出现一条致命错误信息。如果你想让make忽略那些无法读取的文件继续执行，可以在include前加一个减号<code>-</code>，如<code>-include &lt;filename&gt;</code>。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/02#总结"><span class="icon icon-link"></span></a>总结</h2><p>在这一讲里，为了帮助你编写一个高质量的Makefile，我重点介绍了Makefile规则和Makefile语法里的一些核心语法知识。</p><p>在讲Makefile规则时，我们主要学习了规则语法、伪目标和order-only依赖。掌握了这些Makefile规则，你就掌握了Makefile中最核心的内容。</p><p>在介绍Makefile的语法时，我只介绍了Makefile的核心语法，以及 IAM项目的Makefile用到的语法，包括命令、变量、条件语句和函数。你可能会觉得这些语法学习起来比较枯燥，但还是那句话，工欲善其事，必先利其器。希望你能熟练掌握Makefile的核心语法，为编写高质量的Makefile打好基础。</p><p>今天的内容就到这里啦，欢迎你在下面的留言区谈谈自己的看法，我们下一讲见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/go语言项目开发实战/08.特别放送/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
