<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>特别放送 | 给你一份清晰、可直接套用的Go编码规范 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/go语言项目开发实战/08.特别放送/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/go语言项目开发实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-backend/go语言项目开发实战/01.开篇词/01"><span>开篇词 | 从 0 开始搭建一个企业级 Go 应用</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/02.课前必学">02.课前必学</a><ul><li><a href="/blog-backend/go语言项目开发实战/02.课前必学/01"><span>01 | IAM系统概述：我们要实现什么样的 Go 项目？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/02.课前必学/02"><span>02 | 环境准备：如何安装和配置一个基本的 Go 开发环境？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/02.课前必学/03"><span>03 | 项目部署：如何快速部署 IAM 系统？</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计">03.实战第1站规范设计</a><ul><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/01"><span>04 | 规范设计（上）：项目开发杂乱无章，如何规范？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/02"><span>05 | 规范设计（下）：commit 信息风格迥异、难以阅读，如何规范？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/03"><span>06 | 目录结构设计：如何组织一个可维护、可扩展的代码目录？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04"><span>07 | 工作流设计：如何设计合理的多人开发模式？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/05"><span>08 | 研发流程设计（上）：如何设计 Go 项目的开发流程？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/06"><span>09 | 研发流程设计（下）：如何管理应用的生命周期？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/07"><span>10 | 设计方法：怎么写出优雅的 Go 项目？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/08"><span>11 | 设计模式：Go常用设计模式概述</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发">04.实战第2站基础功能设计或开发</a><ul><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/01"><span>12 | API 风格（上）：如何设计RESTful API？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/02"><span>13 | API 风格（下）：RPC API介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/03"><span>14 | 项目管理：如何编写高质量的Makefile？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/04"><span>15 | 研发流程实战：IAM项目是如何进行研发流程管理的？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/05"><span>16 | 代码检查：如何进行静态代码检查？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/06"><span>17 | API 文档：如何生成 Swagger API 文档 ？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/07"><span>18 | 错误处理（上）：如何设计一套科学的错误码？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/08"><span>19 | 错误处理（下）：如何设计错误包？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/09"><span>20 | 日志处理（上）：如何设计日志包并记录日志？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/10"><span>21 | 日志处理（下）：手把手教你从 0 编写一个日志包</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/11"><span>22 | 应用构建三剑客：Pflag、Viper、Cobra 核心功能介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/12"><span>23 | 应用构建实战：如何构建一个优秀的企业应用框架？</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发">05.实战第3站服务开发</a><ul><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/01"><span>24 | Web 服务：Web 服务核心功能有哪些，如何实现？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/02"><span>25 | 认证机制：应用程序如何进行访问认证？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/03"><span>26 | IAM项目是如何设计和实现访问认证功能的？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/04"><span>27 | 权限模型：5大权限模型是如何进行资源授权的？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/05"><span>28 | 控制流（上）：通过iam-apiserver设计，看Web服务的构建</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/06"><span>29｜控制流（下）：iam-apiserver服务核心功能实现讲解</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/07"><span>30 | ORM：CURD 神器 GORM 包介绍及实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/08"><span>31 | 数据流：通过iam-authz-server设计，看数据流服务的设计</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/09"><span>32 | 数据处理：如何高效处理应用程序产生的数据？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/10"><span>33 |  SDK 设计（上）：如何设计出一个优秀的 Go SDK？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11"><span>34 | SDK 设计（下）：IAM项目Go SDK设计和实现</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/12"><span>35 | 效率神器：如何设计和实现一个命令行客户端工具？</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试">06.实战第4站服务测试</a><ul><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/01"><span>36 | 代码测试（上）：如何编写 Go 语言单元测试和性能测试用例？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/02"><span>37 | 代码测试（下）：Go 语言其他测试类型及 IAM 测试介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/03"><span>38｜性能分析（上）：如何分析 Go 语言代码的性能？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/04"><span>39｜性能分析（下）：API Server性能测试和调优实战</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署">07.实战第5站服务部署</a><ul><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/01"><span>40 | 软件部署实战（上）：部署方案及负载均衡、高可用组件介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/02"><span>41 | 软件部署实战（中）：IAM 系统生产环境部署实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/03"><span>42 | 软件部署实战（下）：IAM系统安全加固、水平扩缩容实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/04"><span>43｜技术演进（上）：虚拟化技术演进之路</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/05"><span>44｜技术演进（下）：软件架构和应用生命周期技术演进之路</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06"><span>45｜基于Kubernetes的云原生架构设计</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/07"><span>46 | 如何制作Docker镜像？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/08"><span>47 | 如何编写Kubernetes资源定义文件？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/09"><span>48 | 基于腾讯云 EKS 的容器化部署实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/10"><span>49 | 服务编排（上）：Helm服务编排基础知识</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/11"><span>50 | 服务编排（下）：基于Helm的服务编排部署实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/12"><span>51 | 基于 GitHub Actions 的 CI 实战</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战/08.特别放送">08.特别放送</a><ul><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战/08.特别放送/01"><span>特别放送 | 给你一份清晰、可直接套用的Go编码规范</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/02"><span>特别放送 | 给你一份Go项目中最常用的Makefile核心语法</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/03"><span>特别放送 | Go Modules依赖包管理全讲</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/04"><span>特别放送 | IAM排障指南</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/05"><span>特别放送 | Go Modules实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/06"><span>特别放送 | 分布式作业系统设计和实现</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/07"><span>直播加餐｜如何从小白进阶成 Go 语言专家？</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/09.结束语">09.结束语</a><ul><li><a href="/blog-backend/go语言项目开发实战/09.结束语/01"><span>结束语 | 如何让自己的 Go 研发之路走得更远？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/09.结束语/02"><span>期末考试｜《Go语言项目开发实战》满分试卷，等你来挑战！</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/summary">go语言项目开发实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="1. 代码风格" data-depth="2"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#1-代码风格"><span>1. 代码风格</span></a></li><li title="1.1 代码格式" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#11-代码格式"><span>1.1 代码格式</span></a></li><li title="1.2 声明、初始化和定义" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#12-声明初始化和定义"><span>1.2 声明、初始化和定义</span></a></li><li title="1.3 错误处理" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#13-错误处理"><span>1.3 错误处理</span></a></li><li title="1.4 panic处理" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#14-panic处理"><span>1.4 panic处理</span></a></li><li title="1.5 单元测试" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#15-单元测试"><span>1.5 单元测试</span></a></li><li title="1.6 类型断言失败处理" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#16-类型断言失败处理"><span>1.6 类型断言失败处理</span></a></li><li title="2. 命名规范" data-depth="2"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#2-命名规范"><span>2. 命名规范</span></a></li><li title="2.1 包命名" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#21-包命名"><span>2.1 包命名</span></a></li><li title="2.2 函数命名" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#22-函数命名"><span>2.2 函数命名</span></a></li><li title="2.3 文件命名" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#23-文件命名"><span>2.3 文件命名</span></a></li><li title="2.4 结构体命名" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#24-结构体命名"><span>2.4 结构体命名</span></a></li><li title="2.5 接口命名" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#25-接口命名"><span>2.5 接口命名</span></a></li><li title="2.6 变量命名" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#26-变量命名"><span>2.6 变量命名</span></a></li><li title="2.7 常量命名" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#27-常量命名"><span>2.7 常量命名</span></a></li><li title="2.8 Error的命名" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#28-error的命名"><span>2.8 Error的命名</span></a></li><li title="3. 注释规范" data-depth="2"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#3-注释规范"><span>3. 注释规范</span></a></li><li title="3.1 包注释" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#31-包注释"><span>3.1 包注释</span></a></li><li title="3.2 变量/常量注释" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#32-变量常量注释"><span>3.2 变量/常量注释</span></a></li><li title="3.3 结构体注释" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#33-结构体注释"><span>3.3 结构体注释</span></a></li><li title="3.4 方法注释" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#34-方法注释"><span>3.4 方法注释</span></a></li><li title="3.5 类型注释" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#35-类型注释"><span>3.5 类型注释</span></a></li><li title="4. 类型" data-depth="2"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#4-类型"><span>4. 类型</span></a></li><li title="4.1 字符串" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#41-字符串"><span>4.1 字符串</span></a></li><li title="4.2 切片" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#42-切片"><span>4.2 切片</span></a></li><li title="4.3 结构体" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#43-结构体"><span>4.3 结构体</span></a></li><li title="5. 控制结构" data-depth="2"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#5-控制结构"><span>5. 控制结构</span></a></li><li title="5.1 if" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#51-if"><span>5.1 if</span></a></li><li title="5.2 for" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#52-for"><span>5.2 for</span></a></li><li title="5.3 range" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#53-range"><span>5.3 range</span></a></li><li title="5.4 switch" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#54-switch"><span>5.4 switch</span></a></li><li title="5.5 goto" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#55-goto"><span>5.5 goto</span></a></li><li title="6. 函数" data-depth="2"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#6-函数"><span>6. 函数</span></a></li><li title="6.1 函数参数" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#61-函数参数"><span>6.1 函数参数</span></a></li><li title="6.2 defer" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#62-defer"><span>6.2 defer</span></a></li><li title="6.3 方法的接收器" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#63-方法的接收器"><span>6.3 方法的接收器</span></a></li><li title="6.4 嵌套" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#64-嵌套"><span>6.4 嵌套</span></a></li><li title="6.5 变量命名" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#65-变量命名"><span>6.5 变量命名</span></a></li><li title="7. GOPATH 设置规范" data-depth="2"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#7-gopath-设置规范"><span>7. GOPATH 设置规范</span></a></li><li title="8. 依赖管理" data-depth="2"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#8-依赖管理"><span>8. 依赖管理</span></a></li><li title="9. 最佳实践" data-depth="2"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#9-最佳实践"><span>9. 最佳实践</span></a></li><li title="9.1 性能" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#91-性能"><span>9.1 性能</span></a></li><li title="9.2 注意事项" data-depth="3"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#92-注意事项"><span>9.2 注意事项</span></a></li><li title="总结" data-depth="2"><a href="/blog-backend/go语言项目开发实战/08.特别放送/01#总结"><span>总结</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="特别放送--给你一份清晰可直接套用的go编码规范"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#特别放送--给你一份清晰可直接套用的go编码规范"><span class="icon icon-link"></span></a>特别放送 | 给你一份清晰、可直接套用的Go编码规范</h1><p>你好，我是孔令飞。</p><p>我们在上一讲学习了“写出优雅Go项目的方法论”，那一讲内容很丰富，是我多年Go项目开发的经验沉淀，需要你多花一些时间好好消化吸收。吃完大餐之后，咱们今天来一期特别放送，就是上一讲我提到过的编码规范。这一讲里，为了帮你节省时间和精力，我会给你一份清晰、可直接套用的 Go 编码规范，帮助你编写一个高质量的 Go 应用。</p><p>这份规范，是我参考了Go官方提供的编码规范，以及Go社区沉淀的一些比较合理的规范之后，加入自己的理解总结出的，它比很多公司内部的规范更全面，你掌握了，以后在面试大厂的时候，或者在大厂里写代码的时候，都会让人高看你一眼，觉得你code很专业。</p><p>这份编码规范中包含代码风格、命名规范、注释规范、类型、控制结构、函数、GOPATH 设置规范、依赖管理和最佳实践九类规范。如果你觉得这些规范内容太多了，看完一遍也记不住，这完全没关系。你可以多看几遍，也可以在用到时把它翻出来，在实际应用中掌握。这篇特别放送的内容，更多是作为写代码时候的一个参考手册。</p><h2 id="1-代码风格"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#1-代码风格"><span class="icon icon-link"></span></a>1. 代码风格</h2><h3 id="11-代码格式"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#11-代码格式"><span class="icon icon-link"></span></a>1.1 代码格式</h3><ul><li><p>代码都必须用 <code>gofmt</code> 进行格式化。</p></li><li><p>运算符和操作数之间要留空格。</p></li><li><p>建议一行代码不超过120个字符，超过部分，请采用合适的换行方式换行。但也有些例外场景，例如import行、工具自动生成的代码、带tag的struct字段。</p></li><li><p>文件长度不能超过800行。</p></li><li><p>函数长度不能超过80行。</p></li><li><p>import规范</p><ul><li>代码都必须用 goimports进行格式化（建议将代码Go代码编辑器设置为：保存时运行 goimports）。<br/>- 不要使用相对路径引入包，例如 import …/util/net 。<br/>- 包名称与导入路径的最后一个目录名不匹配时，或者多个相同包名冲突时，则必须使用导入别名。</li></ul></li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    	&quot;github.com/dgrijalva/jwt-go/v4&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	//good</span></div><div class="token-line"><span class="token plain">    	jwt &quot;github.com/dgrijalva/jwt-go/v4&quot;</span></div></pre></div><ul><li><ul><li>导入的包建议进行分组，匿名包的引用使用一个新的分组，并对匿名包引用进行说明。</li></ul></li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import (</span></div><div class="token-line"><span class="token plain">    		// go 标准包</span></div><div class="token-line"><span class="token plain">    		&quot;fmt&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		// 第三方包</span></div><div class="token-line"><span class="token plain">    	    &quot;github.com/jinzhu/gorm&quot;</span></div><div class="token-line"><span class="token plain">    	    &quot;github.com/spf13/cobra&quot;</span></div><div class="token-line"><span class="token plain">    	    &quot;github.com/spf13/viper&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		// 匿名包单独分组，并对匿名包引用进行说明</span></div><div class="token-line"><span class="token plain">    	    // import mysql driver</span></div><div class="token-line"><span class="token plain">    	    _ &quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		// 内部包</span></div><div class="token-line"><span class="token plain">    	    v1 &quot;github.com/marmotedu/api/apiserver/v1&quot;</span></div><div class="token-line"><span class="token plain">    	    metav1 &quot;github.com/marmotedu/apimachinery/pkg/meta/v1&quot;</span></div><div class="token-line"><span class="token plain">    	    &quot;github.com/marmotedu/iam/pkg/cli/genericclioptions&quot;</span></div><div class="token-line"><span class="token plain">    	)</span></div></pre></div><h3 id="12-声明初始化和定义"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#12-声明初始化和定义"><span class="icon icon-link"></span></a>1.2 声明、初始化和定义</h3><ul><li>当函数中需要使用到多个变量时，可以在函数开始处使用var声明。在函数外部声明必须使用 <code>var</code> ，不要采用 <code>:=</code> ，容易踩到变量的作用域的问题。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var (</span></div><div class="token-line"><span class="token plain">    	Width  int</span></div><div class="token-line"><span class="token plain">    	Height int</span></div><div class="token-line"><span class="token plain">    )</span></div></pre></div><ul><li>在初始化结构引用时，请使用&amp;T<!-- -->{<!-- -->}<!-- -->代替new(T)，以使其与结构体初始化一致。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    sptr := new(T)</span></div><div class="token-line"><span class="token plain">    sptr.Name = &quot;bar&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    sptr := &amp;T{Name: &quot;bar&quot;}</span></div></pre></div><ul><li>struct 声明和初始化格式采用多行，定义如下。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type User struct{</span></div><div class="token-line"><span class="token plain">        Username  string</span></div><div class="token-line"><span class="token plain">        Email     string</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    user := User{</span></div><div class="token-line"><span class="token plain">    	Username: &quot;colin&quot;,</span></div><div class="token-line"><span class="token plain">    	Email: &quot;colin404@foxmail.com&quot;,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><ul><li>相似的声明放在一组，同样适用于常量、变量和类型声明。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    import &quot;a&quot;</span></div><div class="token-line"><span class="token plain">    import &quot;b&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">      &quot;a&quot;</span></div><div class="token-line"><span class="token plain">      &quot;b&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div></pre></div><ul><li>尽可能指定容器容量，以便为容器预先分配内存，例如：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">v := make(map[int]string, 4)</span></div><div class="token-line"><span class="token plain">    v := make([]string, 0, 4)</span></div></pre></div><ul><li>在顶层，使用标准var关键字。请勿指定类型，除非它与表达式的类型不同。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    var _s string = F()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func F() string { return &quot;A&quot; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    var _s = F()</span></div><div class="token-line"><span class="token plain">    // 由于 F 已经明确了返回一个字符串类型，因此我们没有必要显式指定_s 的类型</span></div><div class="token-line"><span class="token plain">    // 还是那种类型</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func F() string { return &quot;A&quot; }</span></div></pre></div><ul><li>对于未导出的顶层常量和变量，使用_作为前缀。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    const (</span></div><div class="token-line"><span class="token plain">      defaultHost = &quot;127.0.0.1&quot;</span></div><div class="token-line"><span class="token plain">      defaultPort = 8080</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    const (</span></div><div class="token-line"><span class="token plain">      _defaultHost = &quot;127.0.0.1&quot;</span></div><div class="token-line"><span class="token plain">      _defaultPort = 8080</span></div><div class="token-line"><span class="token plain">    )</span></div></pre></div><ul><li>嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    type Client struct {</span></div><div class="token-line"><span class="token plain">      version int</span></div><div class="token-line"><span class="token plain">      http.Client</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    type Client struct {</span></div><div class="token-line"><span class="token plain">      http.Client</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      version int</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="13-错误处理"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#13-错误处理"><span class="icon icon-link"></span></a>1.3 错误处理</h3><ul><li><code>error</code>作为函数的值返回，必须对<code>error</code>进行处理，或将返回值赋值给明确忽略。对于<code>defer xx.Close()</code>可以不用显式处理。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func load() error {</span></div><div class="token-line"><span class="token plain">    	// normal code</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // bad</span></div><div class="token-line"><span class="token plain">    load()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">     _ = load()</span></div></pre></div><ul><li><code>error</code>作为函数的值返回且有多个返回值的时候，<code>error</code>必须是最后一个参数。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    func load() (error, int) {</span></div><div class="token-line"><span class="token plain">    	// normal code</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    func load() (int, error) {</span></div><div class="token-line"><span class="token plain">    	// normal code</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><ul><li>尽早进行错误处理，并尽早返回，减少嵌套。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    if err != nil {</span></div><div class="token-line"><span class="token plain">    	// error code</span></div><div class="token-line"><span class="token plain">    } else {</span></div><div class="token-line"><span class="token plain">    	// normal code</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    if err != nil {</span></div><div class="token-line"><span class="token plain">    	// error handling</span></div><div class="token-line"><span class="token plain">    	return err</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // normal code</span></div></pre></div><ul><li>如果需要在 if 之外使用函数调用的结果，则应采用下面的方式。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    if v, err := foo(); err != nil {</span></div><div class="token-line"><span class="token plain">    	// error handling</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    v, err := foo()</span></div><div class="token-line"><span class="token plain">    if err != nil {</span></div><div class="token-line"><span class="token plain">    	// error handling</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><ul><li>错误要单独判断，不与其他逻辑组合判断。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    v, err := foo()</span></div><div class="token-line"><span class="token plain">    if err != nil || v  == nil {</span></div><div class="token-line"><span class="token plain">    	// error handling</span></div><div class="token-line"><span class="token plain">    	return err</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    v, err := foo()</span></div><div class="token-line"><span class="token plain">    if err != nil {</span></div><div class="token-line"><span class="token plain">    	// error handling</span></div><div class="token-line"><span class="token plain">    	return err</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    if v == nil {</span></div><div class="token-line"><span class="token plain">    	// error handling</span></div><div class="token-line"><span class="token plain">    	return errors.New(&quot;invalid value v&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><ul><li>如果返回值需要初始化，则采用下面的方式。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">v, err := f()</span></div><div class="token-line"><span class="token plain">    if err != nil {</span></div><div class="token-line"><span class="token plain">        // error handling</span></div><div class="token-line"><span class="token plain">        return // or continue.</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // use v</span></div></pre></div><ul><li><p>错误描述建议</p></li><li><p>告诉用户他们可以做什么，而不是告诉他们不能做什么。</p></li><li><p>当声明一个需求时，用must 而不是should。例如，must be greater than 0、must match regex ‘[a-z]+’。</p></li><li><p>当声明一个格式不对时，用must not。例如，must not contain。</p></li><li><p>当声明一个动作时用may not。例如，may not be specified when otherField is empty、only name may be specified。</p></li><li><p>引用文字字符串值时，请在单引号中指示文字。例如，ust not contain ‘…’。</p></li><li><p>当引用另一个字段名称时，请在反引号中指定该名称。例如，must be greater than <code>request</code>。</p></li><li><p>指定不等时，请使用单词而不是符号。例如，must be less than 256、must be greater than or equal to 0 (不要用 larger than、bigger than、more than、higher than)。</p></li><li><p>指定数字范围时，请尽可能使用包含范围。</p></li><li><p>建议 Go 1.13 以上，error 生成方式为 <code>fmt.Errorf(&quot;module xxx: %w&quot;, err)</code>。</p></li><li><p>错误描述用小写字母开头，结尾不要加标点符号，例如：</p></li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    	errors.New(&quot;Redis connection failed&quot;)</span></div><div class="token-line"><span class="token plain">    	errors.New(&quot;redis connection failed.&quot;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// good</span></div><div class="token-line"><span class="token plain">    	errors.New(&quot;redis connection failed&quot;)</span></div></pre></div><h3 id="14-panic处理"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#14-panic处理"><span class="icon icon-link"></span></a>1.4 panic处理</h3><ul><li>在业务逻辑处理中禁止使用panic。</li><li>在main包中，只有当程序完全不可运行时使用panic，例如无法打开文件、无法连接数据库导致程序无法正常运行。</li><li>在main包中，使用 <code>log.Fatal</code> 来记录错误，这样就可以由log来结束程序，或者将panic抛出的异常记录到日志文件中，方便排查问题。</li><li>可导出的接口一定不能有panic。</li><li>包内建议采用error而不是panic来传递错误。</li></ul><h3 id="15-单元测试"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#15-单元测试"><span class="icon icon-link"></span></a>1.5 单元测试</h3><ul><li>单元测试文件名命名规范为 <code>example_test.go</code>。</li><li>每个重要的可导出函数都要编写测试用例。</li><li>因为单元测试文件内的函数都是不对外的，所以可导出的结构体、函数等可以不带注释。</li><li>如果存在 <code>func (b *Bar) Foo</code> ，单测函数可以为 <code>func TestBar_Foo</code>。</li></ul><h3 id="16-类型断言失败处理"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#16-类型断言失败处理"><span class="icon icon-link"></span></a>1.6 类型断言失败处理</h3><p>type assertion 的单个返回值针对不正确的类型将产生 panic。请始终使用 “comma ok”的惯用法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    t := n.(int)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    t, ok := n.(int)</span></div><div class="token-line"><span class="token plain">    if !ok {</span></div><div class="token-line"><span class="token plain">    	// error handling</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // normal code</span></div></pre></div><h2 id="2-命名规范"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#2-命名规范"><span class="icon icon-link"></span></a>2. 命名规范</h2><p>命名规范是代码规范中非常重要的一部分，一个统一的、短小的、精确的命名规范可以大大提高代码的可读性，也可以借此规避一些不必要的Bug。</p><h3 id="21-包命名"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#21-包命名"><span class="icon icon-link"></span></a>2.1 包命名</h3><ul><li>包名必须和目录名一致，尽量采取有意义、简短的包名，不要和标准库冲突。</li><li>包名全部小写，没有大写或下划线，使用多级目录来划分层级。</li><li>项目名可以通过中划线来连接多个单词。</li><li>包名以及包所在的目录名，不要使用复数，例如，是<code>net/url</code>，而不是<code>net/urls</code>。</li><li>不要用 common、util、shared 或者 lib 这类宽泛的、无意义的包名。</li><li>包名要简单明了，例如 net、time、log。</li></ul><h3 id="22-函数命名"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#22-函数命名"><span class="icon icon-link"></span></a>2.2 函数命名</h3><ul><li>函数名采用驼峰式，首字母根据访问控制决定使用大写或小写，例如：MixedCaps或者mixedCaps。</li><li>代码生成工具自动生成的代码(如xxxx.pb.go)和为了对相关测试用例进行分组，而采用的下划线(如TestMyFunction_WhatIsBeingTested)排除此规则。</li></ul><h3 id="23-文件命名"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#23-文件命名"><span class="icon icon-link"></span></a>2.3 文件命名</h3><ul><li>文件名要简短有意义。</li><li>文件名应小写，并使用下划线分割单词。</li></ul><h3 id="24-结构体命名"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#24-结构体命名"><span class="icon icon-link"></span></a>2.4 结构体命名</h3><ul><li>采用驼峰命名方式，首字母根据访问控制决定使用大写或小写，例如MixedCaps或者mixedCaps。</li><li>结构体名不应该是动词，应该是名词，比如 Node、NodeSpec。</li><li>避免使用Data、Info这类无意义的结构体名。</li><li>结构体的声明和初始化应采用多行，例如：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// User 多行声明</span></div><div class="token-line"><span class="token plain">    type User struct {</span></div><div class="token-line"><span class="token plain">        Name  string</span></div><div class="token-line"><span class="token plain">        Email string</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 多行初始化</span></div><div class="token-line"><span class="token plain">    u := User{</span></div><div class="token-line"><span class="token plain">        UserName: &quot;colin&quot;,</span></div><div class="token-line"><span class="token plain">        Email:    &quot;colin404@foxmail.com&quot;,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="25-接口命名"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#25-接口命名"><span class="icon icon-link"></span></a>2.5 接口命名</h3><ul><li><p>接口命名的规则，基本和结构体命名规则保持一致：</p><ul><li>单个函数的接口名以 “er&quot;”作为后缀（例如Reader，Writer），有时候可能导致蹩脚的英文，但是没关系。</li><li>两个函数的接口名以两个函数名命名，例如ReadWriter。</li><li>三个以上函数的接口名，类似于结构体名。</li></ul></li></ul><p>例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Seeking to an offset before the start of the file is an error.</span></div><div class="token-line"><span class="token plain">    	// Seeking to any positive offset is legal, but the behavior of subsequent</span></div><div class="token-line"><span class="token plain">    	// I/O operations on the underlying object is implementation-dependent.</span></div><div class="token-line"><span class="token plain">    	type Seeker interface {</span></div><div class="token-line"><span class="token plain">    	    Seek(offset int64, whence int) (int64, error)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// ReadWriter is the interface that groups the basic Read and Write methods.</span></div><div class="token-line"><span class="token plain">    	type ReadWriter interface {</span></div><div class="token-line"><span class="token plain">    	    Reader</span></div><div class="token-line"><span class="token plain">    	    Writer</span></div><div class="token-line"><span class="token plain">    	}</span></div></pre></div><h3 id="26-变量命名"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#26-变量命名"><span class="icon icon-link"></span></a>2.6 变量命名</h3><ul><li><p>变量名必须遵循<strong>驼峰式</strong>，首字母根据访问控制决定使用大写或小写。</p></li><li><p>在相对简单（对象数量少、针对性强）的环境中，可以将一些名称由完整单词简写为单个字母，例如：</p><ul><li>user 可以简写为 u；</li><li>userID 可以简写 uid。</li></ul></li><li><p>特有名词时，需要遵循以下规则：</p><ul><li>如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient。</li><li>其他情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID。</li></ul></li></ul><p>下面列举了一些常见的特有名词。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// A GonicMapper that contains a list of common initialisms taken from golang/lint</span></div><div class="token-line"><span class="token plain">    var LintGonicMapper = GonicMapper{</span></div><div class="token-line"><span class="token plain">        &quot;API&quot;:   true,</span></div><div class="token-line"><span class="token plain">        &quot;ASCII&quot;: true,</span></div><div class="token-line"><span class="token plain">        &quot;CPU&quot;:   true,</span></div><div class="token-line"><span class="token plain">        &quot;CSS&quot;:   true,</span></div><div class="token-line"><span class="token plain">        &quot;DNS&quot;:   true,</span></div><div class="token-line"><span class="token plain">        &quot;EOF&quot;:   true,</span></div><div class="token-line"><span class="token plain">        &quot;GUID&quot;:  true,</span></div><div class="token-line"><span class="token plain">        &quot;HTML&quot;:  true,</span></div><div class="token-line"><span class="token plain">        &quot;HTTP&quot;:  true,</span></div><div class="token-line"><span class="token plain">        &quot;HTTPS&quot;: true,</span></div><div class="token-line"><span class="token plain">        &quot;ID&quot;:    true,</span></div><div class="token-line"><span class="token plain">        &quot;IP&quot;:    true,</span></div><div class="token-line"><span class="token plain">        &quot;JSON&quot;:  true,</span></div><div class="token-line"><span class="token plain">        &quot;LHS&quot;:   true,</span></div><div class="token-line"><span class="token plain">        &quot;QPS&quot;:   true,</span></div><div class="token-line"><span class="token plain">        &quot;RAM&quot;:   true,</span></div><div class="token-line"><span class="token plain">        &quot;RHS&quot;:   true,</span></div><div class="token-line"><span class="token plain">        &quot;RPC&quot;:   true,</span></div><div class="token-line"><span class="token plain">        &quot;SLA&quot;:   true,</span></div><div class="token-line"><span class="token plain">        &quot;SMTP&quot;:  true,</span></div><div class="token-line"><span class="token plain">        &quot;SSH&quot;:   true,</span></div><div class="token-line"><span class="token plain">        &quot;TLS&quot;:   true,</span></div><div class="token-line"><span class="token plain">        &quot;TTL&quot;:   true,</span></div><div class="token-line"><span class="token plain">        &quot;UI&quot;:    true,</span></div><div class="token-line"><span class="token plain">        &quot;UID&quot;:   true,</span></div><div class="token-line"><span class="token plain">        &quot;UUID&quot;:  true,</span></div><div class="token-line"><span class="token plain">        &quot;URI&quot;:   true,</span></div><div class="token-line"><span class="token plain">        &quot;URL&quot;:   true,</span></div><div class="token-line"><span class="token plain">        &quot;UTF8&quot;:  true,</span></div><div class="token-line"><span class="token plain">        &quot;VM&quot;:    true,</span></div><div class="token-line"><span class="token plain">        &quot;XML&quot;:   true,</span></div><div class="token-line"><span class="token plain">        &quot;XSRF&quot;:  true,</span></div><div class="token-line"><span class="token plain">        &quot;XSS&quot;:   true,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><ul><li>若变量类型为bool类型，则名称应以Has，Is，Can或Allow开头，例如：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var hasConflict bool</span></div><div class="token-line"><span class="token plain">    var isExist bool</span></div><div class="token-line"><span class="token plain">    var canManage bool</span></div><div class="token-line"><span class="token plain">    var allowGitHook bool</span></div></pre></div><ul><li>局部变量应当尽可能短小，比如使用buf指代buffer，使用i指代index。</li><li>代码生成工具自动生成的代码可排除此规则(如xxx.pb.go里面的Id)</li></ul><h3 id="27-常量命名"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#27-常量命名"><span class="icon icon-link"></span></a>2.7 常量命名</h3><ul><li>常量名必须遵循驼峰式，首字母根据访问控制决定使用大写或小写。</li><li>如果是枚举类型的常量，需要先创建相应类型：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Code defines an error code type.</span></div><div class="token-line"><span class="token plain">    type Code int</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // Internal errors.</span></div><div class="token-line"><span class="token plain">    const (</span></div><div class="token-line"><span class="token plain">        // ErrUnknown - 0: An unknown error occurred.</span></div><div class="token-line"><span class="token plain">        ErrUnknown Code = iota</span></div><div class="token-line"><span class="token plain">        // ErrFatal - 1: An fatal error occurred.</span></div><div class="token-line"><span class="token plain">        ErrFatal</span></div><div class="token-line"><span class="token plain">    )</span></div></pre></div><h3 id="28-error的命名"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#28-error的命名"><span class="icon icon-link"></span></a>2.8 Error的命名</h3><ul><li>Error类型应该写成FooError的形式。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type ExitError struct {</span></div><div class="token-line"><span class="token plain">    	// ....</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><ul><li>Error变量写成ErrFoo的形式。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var ErrFormat = errors.New(&quot;unknown format&quot;)</span></div></pre></div><h2 id="3-注释规范"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#3-注释规范"><span class="icon icon-link"></span></a>3. 注释规范</h2><ul><li>每个可导出的名字都要有注释，该注释对导出的变量、函数、结构体、接口等进行简要介绍。</li><li>全部使用单行注释，禁止使用多行注释。</li><li>和代码的规范一样，单行注释不要过长，禁止超过 120 字符，超过的请使用换行展示，尽量保持格式优雅。</li><li>注释必须是完整的句子，以需要注释的内容作为开头，句点作为结尾，格式为 <code>// 名称 描述.</code> 。例如：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    // logs the flags in the flagset.</span></div><div class="token-line"><span class="token plain">    func PrintFlags(flags *pflag.FlagSet) {</span></div><div class="token-line"><span class="token plain">    	// normal code</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    // PrintFlags logs the flags in the flagset.</span></div><div class="token-line"><span class="token plain">    func PrintFlags(flags *pflag.FlagSet) {</span></div><div class="token-line"><span class="token plain">    	// normal code</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><ul><li><p>所有注释掉的代码在提交code review前都应该被删除，否则应该说明为什么不删除，并给出后续处理建议。</p><ul><li>在多段注释之间可以使用空行分隔加以区分，如下所示：</li></ul></li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Package superman implements methods for saving the world.</span></div><div class="token-line"><span class="token plain">    //</span></div><div class="token-line"><span class="token plain">    // Experience has shown that a small number of procedures can prove</span></div><div class="token-line"><span class="token plain">    // helpful when attempting to save the world.</span></div><div class="token-line"><span class="token plain">    package superman</span></div></pre></div><h3 id="31-包注释"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#31-包注释"><span class="icon icon-link"></span></a>3.1 包注释</h3><ul><li>每个包都有且仅有一个包级别的注释。</li><li>包注释统一用 <code>//</code> 进行注释，格式为 <code>// Package 包名 包描述</code> ，例如：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Package genericclioptions contains flags which can be added to you command, bound, completed, and produce</span></div><div class="token-line"><span class="token plain">    // useful helper functions.</span></div><div class="token-line"><span class="token plain">    package genericclioptions</span></div></pre></div><h3 id="32-变量常量注释"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#32-变量常量注释"><span class="icon icon-link"></span></a>3.2 变量/常量注释</h3><ul><li>每个可导出的变量/常量都必须有注释说明，格式为<code>// 变量名 变量描述</code>，例如：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// ErrSigningMethod defines invalid signing method error.</span></div><div class="token-line"><span class="token plain">    var ErrSigningMethod = errors.New(&quot;Invalid signing method&quot;)</span></div></pre></div><ul><li>出现大块常量或变量定义时，可在前面注释一个总的说明，然后在每一行常量的前一行或末尾详细注释该常量的定义，例如：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Code must start with 1xxxxx.    </span></div><div class="token-line"><span class="token plain">    const (                         </span></div><div class="token-line"><span class="token plain">        // ErrSuccess - 200: OK.          </span></div><div class="token-line"><span class="token plain">        ErrSuccess int = iota + 100001    </span></div><div class="token-line"><span class="token plain">                                                       </span></div><div class="token-line"><span class="token plain">        // ErrUnknown - 500: Internal server error.    </span></div><div class="token-line"><span class="token plain">        ErrUnknown    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // ErrBind - 400: Error occurred while binding the request body to the struct.    </span></div><div class="token-line"><span class="token plain">        ErrBind    </span></div><div class="token-line"><span class="token plain">                                                      </span></div><div class="token-line"><span class="token plain">        // ErrValidation - 400: Validation failed.    </span></div><div class="token-line"><span class="token plain">        ErrValidation </span></div><div class="token-line"><span class="token plain">    )</span></div></pre></div><h3 id="33-结构体注释"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#33-结构体注释"><span class="icon icon-link"></span></a>3.3 结构体注释</h3><ul><li>每个需要导出的结构体或者接口都必须有注释说明，格式为 <code>// 结构体名 结构体描述.</code>。</li><li>结构体内的可导出成员变量名，如果意义不明确，必须要给出注释，放在成员变量的前一行或同一行的末尾。例如：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// User represents a user restful resource. It is also used as gorm model.</span></div><div class="token-line"><span class="token plain">    type User struct {</span></div><div class="token-line"><span class="token plain">        // Standard object&#x27;s metadata.</span></div><div class="token-line"><span class="token plain">        metav1.ObjectMeta `json:&quot;metadata,omitempty&quot;`</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        Nickname string `json:&quot;nickname&quot; gorm:&quot;column:nickname&quot;`</span></div><div class="token-line"><span class="token plain">        Password string `json:&quot;password&quot; gorm:&quot;column:password&quot;`</span></div><div class="token-line"><span class="token plain">        Email    string `json:&quot;email&quot; gorm:&quot;column:email&quot;`</span></div><div class="token-line"><span class="token plain">        Phone    string `json:&quot;phone&quot; gorm:&quot;column:phone&quot;`</span></div><div class="token-line"><span class="token plain">        IsAdmin  int    `json:&quot;isAdmin,omitempty&quot; gorm:&quot;column:isAdmin&quot;`</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="34-方法注释"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#34-方法注释"><span class="icon icon-link"></span></a>3.4 方法注释</h3><ul><li>每个需要导出的函数或者方法都必须有注释，格式为<code>// 函数名 函数描述.</code>，例如：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// BeforeUpdate run before update database record.</span></div><div class="token-line"><span class="token plain">    func (p *Policy) BeforeUpdate() (err error) {</span></div><div class="token-line"><span class="token plain">    	// normal code</span></div><div class="token-line"><span class="token plain">    	return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="35-类型注释"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#35-类型注释"><span class="icon icon-link"></span></a>3.5 类型注释</h3><ul><li>每个需要导出的类型定义和类型别名都必须有注释说明，格式为 <code>// 类型名 类型描述.</code> ，例如：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Code defines an error code type.</span></div><div class="token-line"><span class="token plain">    type Code int</span></div></pre></div><h2 id="4-类型"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#4-类型"><span class="icon icon-link"></span></a>4. 类型</h2><h3 id="41-字符串"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#41-字符串"><span class="icon icon-link"></span></a>4.1 字符串</h3><ul><li>空字符串判断。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    if s == &quot;&quot; {</span></div><div class="token-line"><span class="token plain">        // normal code</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    if len(s) == 0 {</span></div><div class="token-line"><span class="token plain">        // normal code</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><ul><li>[]byte/string相等比较。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    var s1 []byte</span></div><div class="token-line"><span class="token plain">    var s2 []byte</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    bytes.Equal(s1, s2) == 0</span></div><div class="token-line"><span class="token plain">    bytes.Equal(s1, s2) != 0</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    var s1 []byte</span></div><div class="token-line"><span class="token plain">    var s2 []byte</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    bytes.Compare(s1, s2) == 0</span></div><div class="token-line"><span class="token plain">    bytes.Compare(s1, s2) != 0</span></div></pre></div><ul><li>复杂字符串使用raw字符串避免字符转义。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    regexp.MustCompile(&quot;\\.&quot;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    regexp.MustCompile(`\.`)</span></div></pre></div><h3 id="42-切片"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#42-切片"><span class="icon icon-link"></span></a>4.2 切片</h3><ul><li>空slice判断。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    if len(slice) = 0 {</span></div><div class="token-line"><span class="token plain">        // normal code</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    if slice != nil &amp;&amp; len(slice) == 0 {</span></div><div class="token-line"><span class="token plain">        // normal code</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面判断同样适用于map、channel。</p><ul><li>声明slice。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    s := []string{}</span></div><div class="token-line"><span class="token plain">    s := make([]string, 0)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    var s []string</span></div></pre></div><ul><li>slice复制。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    var b1, b2 []byte</span></div><div class="token-line"><span class="token plain">    for i, v := range b1 {</span></div><div class="token-line"><span class="token plain">       b2[i] = v</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    for i := range b1 {</span></div><div class="token-line"><span class="token plain">       b2[i] = b1[i]</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    copy(b2, b1)</span></div></pre></div><ul><li>slice新增。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    var a, b []int</span></div><div class="token-line"><span class="token plain">    for _, v := range a {</span></div><div class="token-line"><span class="token plain">        b = append(b, v)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    var a, b []int</span></div><div class="token-line"><span class="token plain">    b = append(b, a...)</span></div></pre></div><h3 id="43-结构体"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#43-结构体"><span class="icon icon-link"></span></a>4.3 结构体</h3><ul><li>struct初始化。</li></ul><p>struct以多行格式初始化。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type user struct {</span></div><div class="token-line"><span class="token plain">    	Id   int64</span></div><div class="token-line"><span class="token plain">    	Name string</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    u1 := user{100, &quot;Colin&quot;}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    u2 := user{</span></div><div class="token-line"><span class="token plain">        Id:   200,</span></div><div class="token-line"><span class="token plain">        Name: &quot;Lex&quot;,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="5-控制结构"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#5-控制结构"><span class="icon icon-link"></span></a>5. 控制结构</h2><h3 id="51-if"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#51-if"><span class="icon icon-link"></span></a>5.1 if</h3><ul><li>if 接受初始化语句，约定如下方式建立局部变量。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if err := loadConfig(); err != nil {</span></div><div class="token-line"><span class="token plain">    	// error handling</span></div><div class="token-line"><span class="token plain">    	return err</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><ul><li>if 对于bool类型的变量，应直接进行真假判断。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var isAllow bool</span></div><div class="token-line"><span class="token plain">    if isAllow {</span></div><div class="token-line"><span class="token plain">    	// normal code</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="52-for"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#52-for"><span class="icon icon-link"></span></a>5.2 for</h3><ul><li>采用短声明建立局部变量。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sum := 0</span></div><div class="token-line"><span class="token plain">    for i := 0; i &lt; 10; i++ {</span></div><div class="token-line"><span class="token plain">        sum += 1</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><ul><li>不要在 for 循环里面使用 defer，defer只有在函数退出时才会执行。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// bad</span></div><div class="token-line"><span class="token plain">    for file := range files {</span></div><div class="token-line"><span class="token plain">    	fd, err := os.Open(file)</span></div><div class="token-line"><span class="token plain">    	if err != nil {</span></div><div class="token-line"><span class="token plain">    		return err</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	defer fd.Close()</span></div><div class="token-line"><span class="token plain">    	// normal code</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // good</span></div><div class="token-line"><span class="token plain">    for file := range files {</span></div><div class="token-line"><span class="token plain">    	func() {</span></div><div class="token-line"><span class="token plain">    		fd, err := os.Open(file)</span></div><div class="token-line"><span class="token plain">    		if err != nil {</span></div><div class="token-line"><span class="token plain">    			return err</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    		defer fd.Close()</span></div><div class="token-line"><span class="token plain">    		// normal code</span></div><div class="token-line"><span class="token plain">    	}()</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="53-range"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#53-range"><span class="icon icon-link"></span></a>5.3 range</h3><ul><li>如果只需要第一项（key），就丢弃第二个。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for key := range keys {</span></div><div class="token-line"><span class="token plain">    // normal code</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><ul><li>如果只需要第二项，则把第一项置为下划线。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sum := 0</span></div><div class="token-line"><span class="token plain">    for _, value := range array {</span></div><div class="token-line"><span class="token plain">        sum += value</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="54-switch"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#54-switch"><span class="icon icon-link"></span></a>5.4 switch</h3><ul><li>必须要有default。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">switch os := runtime.GOOS; os {</span></div><div class="token-line"><span class="token plain">        case &quot;linux&quot;:</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;Linux.&quot;)</span></div><div class="token-line"><span class="token plain">        case &quot;darwin&quot;:</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;OS X.&quot;)</span></div><div class="token-line"><span class="token plain">        default:</span></div><div class="token-line"><span class="token plain">            fmt.Printf(&quot;%s.\n&quot;, os)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="55-goto"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#55-goto"><span class="icon icon-link"></span></a>5.5 goto</h3><ul><li>业务代码禁止使用 <code>goto</code> 。</li><li>框架或其他底层源码尽量不用。</li></ul><h2 id="6-函数"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#6-函数"><span class="icon icon-link"></span></a>6. 函数</h2><ul><li><p>传入变量和返回变量以小写字母开头。</p></li><li><p>函数参数个数不能超过5个。</p></li><li><p>函数分组与顺序</p><ul><li>函数应按粗略的调用顺序排序。</li><li>同一文件中的函数应按接收者分组。</li></ul></li><li><p>尽量采用值传递，而非指针传递。</p></li><li><p>传入参数是 map、slice、chan、interface ，不要传递指针。</p></li></ul><h3 id="61-函数参数"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#61-函数参数"><span class="icon icon-link"></span></a>6.1 函数参数</h3><ul><li>如果函数返回相同类型的两个或三个参数，或者如果从上下文中不清楚结果的含义，使用命名返回，其他情况不建议使用命名返回，例如：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func coordinate() (x, y float64, err error) {</span></div><div class="token-line"><span class="token plain">    	// normal code</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><ul><li>传入变量和返回变量都以小写字母开头。</li><li>尽量用值传递，非指针传递。</li><li>参数数量均不能超过5个。</li><li>多返回值最多返回三个，超过三个请使用 struct。</li></ul><h3 id="62-defer"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#62-defer"><span class="icon icon-link"></span></a>6.2 defer</h3><ul><li>当存在资源创建时，应紧跟defer释放资源(可以大胆使用defer，defer在Go1.14版本中，性能大幅提升，defer的性能损耗即使在性能敏感型的业务中，也可以忽略)。</li><li>先判断是否错误，再defer释放资源，例如：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">rep, err := http.Get(url)</span></div><div class="token-line"><span class="token plain">    if err != nil {</span></div><div class="token-line"><span class="token plain">        return err</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    defer resp.Body.Close()</span></div></pre></div><h3 id="63-方法的接收器"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#63-方法的接收器"><span class="icon icon-link"></span></a>6.3 方法的接收器</h3><ul><li>推荐以类名第一个英文首字母的小写作为接收器的命名。</li><li>接收器的命名在函数超过20行的时候不要用单字符。</li><li>接收器的命名不能采用me、this、self这类易混淆名称。</li></ul><h3 id="64-嵌套"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#64-嵌套"><span class="icon icon-link"></span></a>6.4 嵌套</h3><ul><li>嵌套深度不能超过4层。</li></ul><h3 id="65-变量命名"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#65-变量命名"><span class="icon icon-link"></span></a>6.5 变量命名</h3><ul><li>变量声明尽量放在变量第一次使用的前面，遵循就近原则。</li><li>如果魔法数字出现超过两次，则禁止使用，改用一个常量代替，例如：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// PI ...</span></div><div class="token-line"><span class="token plain">    const Prise = 3.14</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func getAppleCost(n float64) float64 {</span></div><div class="token-line"><span class="token plain">    	return Prise * n</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func getOrangeCost(n float64) float64 {</span></div><div class="token-line"><span class="token plain">    	return Prise * n</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="7-gopath-设置规范"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#7-gopath-设置规范"><span class="icon icon-link"></span></a>7. GOPATH 设置规范</h2><ul><li>Go 1.11 之后，弱化了 GOPATH 规则，已有代码（很多库肯定是在1.11之前建立的）肯定符合这个规则，建议保留 GOPATH 规则，便于维护代码。</li><li>建议只使用一个 GOPATH，不建议使用多个 GOPATH。如果使用多个GOPATH，编译生效的 bin 目录是在第一个 GOPATH 下。</li></ul><h2 id="8-依赖管理"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#8-依赖管理"><span class="icon icon-link"></span></a>8. 依赖管理</h2><ul><li>Go 1.11 以上必须使用 Go Modules。</li><li>使用Go Modules作为依赖管理的项目时，不建议提交vendor目录。</li><li>使用Go Modules作为依赖管理的项目时，必须提交go.sum文件。</li></ul><h2 id="9-最佳实践"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#9-最佳实践"><span class="icon icon-link"></span></a>9. 最佳实践</h2><ul><li>尽量少用全局变量，而是通过参数传递，使每个函数都是“无状态”的。这样可以减少耦合，也方便分工和单元测试。</li><li>在编译时验证接口的符合性，例如：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type LogHandler struct {</span></div><div class="token-line"><span class="token plain">      h   http.Handler</span></div><div class="token-line"><span class="token plain">      log *zap.Logger</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    var _ http.Handler = LogHandler{}</span></div></pre></div><ul><li>服务器处理请求时，应该创建一个context，保存该请求的相关信息（如requestID），并在函数调用链中传递。</li></ul><h3 id="91-性能"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#91-性能"><span class="icon icon-link"></span></a>9.1 性能</h3><ul><li>string 表示的是不可变的字符串变量，对 string 的修改是比较重的操作，基本上都需要重新申请内存。所以，如果没有特殊需要，需要修改时多使用 []byte。</li><li>优先使用 strconv 而不是 fmt。</li></ul><h3 id="92-注意事项"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#92-注意事项"><span class="icon icon-link"></span></a>9.2 注意事项</h3><ul><li>append 要小心自动分配内存，append 返回的可能是新分配的地址。</li><li>如果要直接修改 map 的 value 值，则 value 只能是指针，否则要覆盖原来的值。</li><li>map 在并发中需要加锁。</li><li>编译过程无法检查 interface<!-- -->{<!-- -->}<!-- --> 的转换，只能在运行时检查，小心引起 panic。</li></ul><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/08.特别放送/01#总结"><span class="icon icon-link"></span></a>总结</h2><p>这一讲，我向你介绍了九类常用的编码规范。但今天的最后，我要在这里提醒你一句：规范是人定的，你也可以根据需要，制定符合你项目的规范。这也是我在之前的课程里一直强调的思路。但同时我也建议你采纳这些业界沉淀下来的规范，并通过工具来确保规范的执行。</p><p>今天的内容就到这里啦，欢迎你在下面的留言区谈谈自己的看法，我们下一讲见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/go语言项目开发实战/08.特别放送/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
