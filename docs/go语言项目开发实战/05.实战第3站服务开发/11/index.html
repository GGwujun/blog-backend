<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>34 | SDK 设计（下）：IAM项目Go SDK设计和实现 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/go语言项目开发实战/05.实战第3站服务开发/11" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/go语言项目开发实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-backend/go语言项目开发实战/01.开篇词/01"><span>开篇词 | 从 0 开始搭建一个企业级 Go 应用</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/02.课前必学">02.课前必学</a><ul><li><a href="/blog-backend/go语言项目开发实战/02.课前必学/01"><span>01 | IAM系统概述：我们要实现什么样的 Go 项目？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/02.课前必学/02"><span>02 | 环境准备：如何安装和配置一个基本的 Go 开发环境？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/02.课前必学/03"><span>03 | 项目部署：如何快速部署 IAM 系统？</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计">03.实战第1站规范设计</a><ul><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/01"><span>04 | 规范设计（上）：项目开发杂乱无章，如何规范？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/02"><span>05 | 规范设计（下）：commit 信息风格迥异、难以阅读，如何规范？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/03"><span>06 | 目录结构设计：如何组织一个可维护、可扩展的代码目录？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/04"><span>07 | 工作流设计：如何设计合理的多人开发模式？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/05"><span>08 | 研发流程设计（上）：如何设计 Go 项目的开发流程？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/06"><span>09 | 研发流程设计（下）：如何管理应用的生命周期？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/07"><span>10 | 设计方法：怎么写出优雅的 Go 项目？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/03.实战第1站规范设计/08"><span>11 | 设计模式：Go常用设计模式概述</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发">04.实战第2站基础功能设计或开发</a><ul><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/01"><span>12 | API 风格（上）：如何设计RESTful API？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/02"><span>13 | API 风格（下）：RPC API介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/03"><span>14 | 项目管理：如何编写高质量的Makefile？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/04"><span>15 | 研发流程实战：IAM项目是如何进行研发流程管理的？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/05"><span>16 | 代码检查：如何进行静态代码检查？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/06"><span>17 | API 文档：如何生成 Swagger API 文档 ？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/07"><span>18 | 错误处理（上）：如何设计一套科学的错误码？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/08"><span>19 | 错误处理（下）：如何设计错误包？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/09"><span>20 | 日志处理（上）：如何设计日志包并记录日志？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/10"><span>21 | 日志处理（下）：手把手教你从 0 编写一个日志包</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/11"><span>22 | 应用构建三剑客：Pflag、Viper、Cobra 核心功能介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/04.实战第2站基础功能设计或开发/12"><span>23 | 应用构建实战：如何构建一个优秀的企业应用框架？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发">05.实战第3站服务开发</a><ul><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/01"><span>24 | Web 服务：Web 服务核心功能有哪些，如何实现？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/02"><span>25 | 认证机制：应用程序如何进行访问认证？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/03"><span>26 | IAM项目是如何设计和实现访问认证功能的？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/04"><span>27 | 权限模型：5大权限模型是如何进行资源授权的？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/05"><span>28 | 控制流（上）：通过iam-apiserver设计，看Web服务的构建</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/06"><span>29｜控制流（下）：iam-apiserver服务核心功能实现讲解</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/07"><span>30 | ORM：CURD 神器 GORM 包介绍及实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/08"><span>31 | 数据流：通过iam-authz-server设计，看数据流服务的设计</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/09"><span>32 | 数据处理：如何高效处理应用程序产生的数据？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/10"><span>33 |  SDK 设计（上）：如何设计出一个优秀的 Go SDK？</span></a></li><li><a aria-current="page" class="active" href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11"><span>34 | SDK 设计（下）：IAM项目Go SDK设计和实现</span></a></li><li><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/12"><span>35 | 效率神器：如何设计和实现一个命令行客户端工具？</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试">06.实战第4站服务测试</a><ul><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/01"><span>36 | 代码测试（上）：如何编写 Go 语言单元测试和性能测试用例？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/02"><span>37 | 代码测试（下）：Go 语言其他测试类型及 IAM 测试介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/03"><span>38｜性能分析（上）：如何分析 Go 语言代码的性能？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/06.实战第4站服务测试/04"><span>39｜性能分析（下）：API Server性能测试和调优实战</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署">07.实战第5站服务部署</a><ul><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/01"><span>40 | 软件部署实战（上）：部署方案及负载均衡、高可用组件介绍</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/02"><span>41 | 软件部署实战（中）：IAM 系统生产环境部署实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/03"><span>42 | 软件部署实战（下）：IAM系统安全加固、水平扩缩容实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/04"><span>43｜技术演进（上）：虚拟化技术演进之路</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/05"><span>44｜技术演进（下）：软件架构和应用生命周期技术演进之路</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/06"><span>45｜基于Kubernetes的云原生架构设计</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/07"><span>46 | 如何制作Docker镜像？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/08"><span>47 | 如何编写Kubernetes资源定义文件？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/09"><span>48 | 基于腾讯云 EKS 的容器化部署实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/10"><span>49 | 服务编排（上）：Helm服务编排基础知识</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/11"><span>50 | 服务编排（下）：基于Helm的服务编排部署实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/07.实战第5站服务部署/12"><span>51 | 基于 GitHub Actions 的 CI 实战</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送">08.特别放送</a><ul><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/01"><span>特别放送 | 给你一份清晰、可直接套用的Go编码规范</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/02"><span>特别放送 | 给你一份Go项目中最常用的Makefile核心语法</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/03"><span>特别放送 | Go Modules依赖包管理全讲</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/04"><span>特别放送 | IAM排障指南</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/05"><span>特别放送 | Go Modules实战</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/06"><span>特别放送 | 分布式作业系统设计和实现</span></a></li><li><a href="/blog-backend/go语言项目开发实战/08.特别放送/07"><span>直播加餐｜如何从小白进阶成 Go 语言专家？</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/09.结束语">09.结束语</a><ul><li><a href="/blog-backend/go语言项目开发实战/09.结束语/01"><span>结束语 | 如何让自己的 Go 研发之路走得更远？</span></a></li><li><a href="/blog-backend/go语言项目开发实战/09.结束语/02"><span>期末考试｜《Go语言项目开发实战》满分试卷，等你来挑战！</span></a></li></ul></li><li><a href="/blog-backend/go语言项目开发实战/summary">go语言项目开发实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="marmotedu-sdk-go设计" data-depth="2"><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#marmotedu-sdk-go设计"><span>marmotedu-sdk-go设计</span></a></li><li title="marmotedu-sdk-go客户端设计" data-depth="3"><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#marmotedu-sdk-go客户端设计"><span>marmotedu-sdk-go客户端设计</span></a></li><li title="项目级别客户端创建" data-depth="3"><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#项目级别客户端创建"><span>项目级别客户端创建</span></a></li><li title="应用级别客户端创建" data-depth="3"><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#应用级别客户端创建"><span>应用级别客户端创建</span></a></li><li title="服务级别客户端创建" data-depth="3"><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#服务级别客户端创建"><span>服务级别客户端创建</span></a></li><li title="marmotedu-sdk-go的实现" data-depth="2"><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#marmotedu-sdk-go的实现"><span>marmotedu-sdk-go的实现</span></a></li><li title="RESTClient客户端实现" data-depth="3"><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#restclient客户端实现"><span>RESTClient客户端实现</span></a></li><li title="Request模块实现" data-depth="3"><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#request模块实现"><span>Request模块实现</span></a></li><li title="请求认证" data-depth="3"><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#请求认证"><span>请求认证</span></a></li><li title="总结" data-depth="2"><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#总结"><span>总结</span></a></li><li title="课后练习" data-depth="2"><a href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#课后练习"><span>课后练习</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="34--sdk-设计下iam项目go-sdk设计和实现"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#34--sdk-设计下iam项目go-sdk设计和实现"><span class="icon icon-link"></span></a>34 | SDK 设计（下）：IAM项目Go SDK设计和实现</h1><p>你好，我是孔令飞。</p><p>上一讲，我介绍了公有云厂商普遍采用的SDK设计方式。其实，还有一些比较优秀的SDK设计方式，比如 Kubernetes的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/kubernetes/client-go">client-go<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> SDK设计方式。IAM项目参考client-go，也实现了client-go风格的SDK：<a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go">marmotedu-sdk-go<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>和 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/406389">33讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 介绍的SDK设计方式相比，client-go风格的SDK具有以下优点：</p><ul><li>大量使用了Go interface特性，将接口的定义和实现解耦，可以支持多种实现方式。</li><li>接口调用层级跟资源的层级相匹配，调用方式更加友好。</li><li>多版本共存。</li></ul><p>所以，我更推荐你使用marmotedu-sdk-go。接下来，我们就来看下marmotedu-sdk-go是如何设计和实现的。</p><h2 id="marmotedu-sdk-go设计"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#marmotedu-sdk-go设计"><span class="icon icon-link"></span></a>marmotedu-sdk-go设计</h2><p>和medu-sdk-go相比，marmotedu-sdk-go的设计和实现要复杂一些，但功能更强大，使用体验也更好。</p><p>这里，我们先来看一个使用SDK调用iam-authz-server <code>/v1/authz</code> 接口的示例，代码保存在 <a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.3/examples/authz_clientset/main.go">marmotedu-sdk-go/examples/authz_clientset/main.go<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>文件中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">    	&quot;context&quot;</span></div><div class="token-line"><span class="token plain">    	&quot;flag&quot;</span></div><div class="token-line"><span class="token plain">    	&quot;fmt&quot;</span></div><div class="token-line"><span class="token plain">    	&quot;path/filepath&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	&quot;github.com/ory/ladon&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	metav1 &quot;github.com/marmotedu/component-base/pkg/meta/v1&quot;</span></div><div class="token-line"><span class="token plain">    	&quot;github.com/marmotedu/component-base/pkg/util/homedir&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	&quot;github.com/marmotedu/marmotedu-sdk-go/marmotedu&quot;</span></div><div class="token-line"><span class="token plain">    	&quot;github.com/marmotedu/marmotedu-sdk-go/tools/clientcmd&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">    	var iamconfig *string</span></div><div class="token-line"><span class="token plain">    	if home := homedir.HomeDir(); home != &quot;&quot; {</span></div><div class="token-line"><span class="token plain">    		iamconfig = flag.String(</span></div><div class="token-line"><span class="token plain">    			&quot;iamconfig&quot;,</span></div><div class="token-line"><span class="token plain">    			filepath.Join(home, &quot;.iam&quot;, &quot;config&quot;),</span></div><div class="token-line"><span class="token plain">    			&quot;(optional) absolute path to the iamconfig file&quot;,</span></div><div class="token-line"><span class="token plain">    		)</span></div><div class="token-line"><span class="token plain">    	} else {</span></div><div class="token-line"><span class="token plain">    		iamconfig = flag.String(&quot;iamconfig&quot;, &quot;&quot;, &quot;absolute path to the iamconfig file&quot;)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	flag.Parse()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// use the current context in iamconfig</span></div><div class="token-line"><span class="token plain">    	config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, *iamconfig)</span></div><div class="token-line"><span class="token plain">    	if err != nil {</span></div><div class="token-line"><span class="token plain">    		panic(err.Error())</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// create the clientset</span></div><div class="token-line"><span class="token plain">    	clientset, err := marmotedu.NewForConfig(config)</span></div><div class="token-line"><span class="token plain">    	if err != nil {</span></div><div class="token-line"><span class="token plain">    		panic(err.Error())</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	request := &amp;ladon.Request{</span></div><div class="token-line"><span class="token plain">    		Resource: &quot;resources:articles:ladon-introduction&quot;,</span></div><div class="token-line"><span class="token plain">    		Action:   &quot;delete&quot;,</span></div><div class="token-line"><span class="token plain">    		Subject:  &quot;users:peter&quot;,</span></div><div class="token-line"><span class="token plain">    		Context: ladon.Context{</span></div><div class="token-line"><span class="token plain">    			&quot;remoteIP&quot;: &quot;192.168.0.5&quot;,</span></div><div class="token-line"><span class="token plain">    		},</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// Authorize the request</span></div><div class="token-line"><span class="token plain">    	fmt.Println(&quot;Authorize request...&quot;)</span></div><div class="token-line"><span class="token plain">    	ret, err := clientset.Iam().AuthzV1().Authz().Authorize(context.TODO(), request, metav1.AuthorizeOptions{})</span></div><div class="token-line"><span class="token plain">    	if err != nil {</span></div><div class="token-line"><span class="token plain">    		panic(err.Error())</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	fmt.Printf(&quot;Authorize response: %s.\n&quot;, ret.ToString())</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在上面的代码示例中，包含了下面的操作。</p><ul><li>首先，调用 <code>BuildConfigFromFlags</code> 函数，创建出SDK的配置实例config；</li><li>接着，调用 <code>marmotedu.NewForConfig(config)</code> 创建了IAM项目的客户端 <code>clientset</code> ;</li><li>最后，调用以下代码请求 <code>/v1/authz</code> 接口执行资源授权请求：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ret, err := clientset.Iam().AuthzV1().Authz().Authorize(context.TODO(), request, metav1.AuthorizeOptions{})    </span></div><div class="token-line"><span class="token plain">    if err != nil {           </span></div><div class="token-line"><span class="token plain">        panic(err.Error())    </span></div><div class="token-line"><span class="token plain">    }    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fmt.Printf(&quot;Authorize response: %s.\n&quot;, ret.ToString())</span></div></pre></div><p>调用格式为<code>项目客户端.应用客户端.服务客户端.资源名.接口</code> 。</p><p>所以，上面的代码通过创建项目级别的客户端、应用级别的客户端和服务级别的客户端，来调用资源的API接口。接下来，我们来看下如何创建这些客户端。</p><h3 id="marmotedu-sdk-go客户端设计"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#marmotedu-sdk-go客户端设计"><span class="icon icon-link"></span></a>marmotedu-sdk-go客户端设计</h3><p>在讲客户端创建之前，我们先来看下客户端的设计思路。</p><p>Go项目的组织方式是有层级的：<strong>Project -&gt; Application -&gt; Service</strong>。marmotedu-sdk-go很好地体现了这种层级关系，使得SDK的调用更加易懂、易用。marmotedu-sdk-go的层级关系如下图所示：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage3a213a4721afa7fe365c0954019087d82021.b2605dbb.jpg" alt=""/></p><p>marmotedu-sdk-go定义了3类接口，分别代表了项目、应用和服务级别的API接口：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 项目级别的接口</span></div><div class="token-line"><span class="token plain">    type Interface interface {</span></div><div class="token-line"><span class="token plain">        Iam() iam.IamInterface</span></div><div class="token-line"><span class="token plain">        Tms() tms.TmsInterface</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 应用级别的接口</span></div><div class="token-line"><span class="token plain">    type IamInterface interface {</span></div><div class="token-line"><span class="token plain">        APIV1() apiv1.APIV1Interface</span></div><div class="token-line"><span class="token plain">        AuthzV1() authzv1.AuthzV1Interface</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 服务级别的接口</span></div><div class="token-line"><span class="token plain">    type APIV1Interface interface {</span></div><div class="token-line"><span class="token plain">        RESTClient() rest.Interface</span></div><div class="token-line"><span class="token plain">        SecretsGetter</span></div><div class="token-line"><span class="token plain">        UsersGetter</span></div><div class="token-line"><span class="token plain">        PoliciesGetter</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 资源级别的客户端</span></div><div class="token-line"><span class="token plain">    type SecretsGetter interface {</span></div><div class="token-line"><span class="token plain">        Secrets() SecretInterface</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 资源的接口定义</span></div><div class="token-line"><span class="token plain">    type SecretInterface interface {</span></div><div class="token-line"><span class="token plain">        Create(ctx context.Context, secret *v1.Secret, opts metav1.CreateOptions) (*v1.Secret, error)</span></div><div class="token-line"><span class="token plain">        Update(ctx context.Context, secret *v1.Secret, opts metav1.UpdateOptions) (*v1.Secret, error)</span></div><div class="token-line"><span class="token plain">        Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error</span></div><div class="token-line"><span class="token plain">        DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error</span></div><div class="token-line"><span class="token plain">        Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.Secret, error)</span></div><div class="token-line"><span class="token plain">        List(ctx context.Context, opts metav1.ListOptions) (*v1.SecretList, error)</span></div><div class="token-line"><span class="token plain">        SecretExpansion</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><code>Interface</code> 代表了项目级别的接口，里面包含了 <code>Iam</code> 和 <code>Tms</code> 两个应用； <code>IamInterface</code> 代表了应用级别的接口，里面包含了api（iam-apiserver）和authz（iam-authz-server）两个服务级别的接口。api和authz服务中，又包含了各自服务中REST资源的CURD接口。</p><p>marmotedu-sdk-go通过 <code>XxxV1</code> 这种命名方式来支持不同版本的API接口，好处是可以在程序中同时调用同一个API接口的不同版本，例如：</p><p><code>clientset.Iam().AuthzV1().Authz().Authorize()</code> 、<code>clientset.Iam().AuthzV2().Authz().Authorize()</code> 分别调用了 <code>/v1/authz</code> 和 <code>/v2/authz</code> 两个版本的API接口。</p><p>上述关系也可以从目录结构中反映出来，marmotedu-sdk-go目录设计如下（只列出了一些重要的文件）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">├── examples                        # 存放SDK的使用示例</span></div><div class="token-line"><span class="token plain">    ├── Makefile                        # 管理SDK源码，静态代码检查、代码格式化、测试、添加版权信息等</span></div><div class="token-line"><span class="token plain">    ├── marmotedu</span></div><div class="token-line"><span class="token plain">    │   ├── clientset.go                # clientset实现，clientset中包含多个应用，多个服务的API接口</span></div><div class="token-line"><span class="token plain">    │   ├── fake                        # clientset的fake实现，主要用于单元测试</span></div><div class="token-line"><span class="token plain">    │   └── service                     # 按应用进行分类，存放应用中各服务API接口的具体实现</span></div><div class="token-line"><span class="token plain">    │       ├── iam                     # iam应用的API接口实现，包含多个服务</span></div><div class="token-line"><span class="token plain">    │       │   ├── apiserver           # iam应用中，apiserver服务的API接口，包含多个版本</span></div><div class="token-line"><span class="token plain">    │       │   │   └── v1              # apiserver v1版本API接口</span></div><div class="token-line"><span class="token plain">    │       │   ├── authz               # iam应用中，authz服务的API接口</span></div><div class="token-line"><span class="token plain">    │       │   │   └── v1              # authz服务v1版本接口</span></div><div class="token-line"><span class="token plain">    │       │   └── iam_client.go       # iam应用的客户端，包含了apiserver和authz 2个服务的客户端</span></div><div class="token-line"><span class="token plain">    │       └── tms                     # tms应用的API接口实现</span></div><div class="token-line"><span class="token plain">    ├── pkg                             # 存放一些共享包，可对外暴露</span></div><div class="token-line"><span class="token plain">    ├── rest                            # HTTP请求的底层实现</span></div><div class="token-line"><span class="token plain">    ├── third_party                     # 存放修改过的第三方包，例如：gorequest</span></div><div class="token-line"><span class="token plain">    └── tools</span></div><div class="token-line"><span class="token plain">        └── clientcmd                   # 一些函数用来帮助创建rest.Config配置</span></div></pre></div><p>每种类型的客户端，都可以通过以下相似的方式来创建：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, &quot;/root/.iam/config&quot;)</span></div><div class="token-line"><span class="token plain">    clientset, err := xxxx.NewForConfig(config)</span></div></pre></div><p><code>/root/.iam/config</code> 为配置文件，里面包含了服务的地址和认证信息。<code>BuildConfigFromFlags</code> 函数加载配置文件，创建并返回 <code>rest.Config</code> 类型的配置变量，并通过 <code>xxxx.NewForConfig</code> 函数创建需要的客户端。<code>xxxx</code> 是所在层级的client包，例如 iam、tms。</p><p>marmotedu-sdk-go客户端定义了3类接口，这可以带来两个好处。</p><p>第一，API接口调用格式规范，层次清晰，可以使API接口调用更加清晰易记。</p><p>第二，可以根据需要，自行选择客户端类型，调用灵活。举个例子，在A服务中需要同时用到iam-apiserver 和 iam-authz-server提供的接口，就可以创建应用级别的客户端IamClient，然后通过 <code>iamclient.APIV1()</code> 和 <code>iamclient.AuthzV1()</code> ，来切换调用不同服务的API接口。</p><p>接下来，我们来看看如何创建三个不同级别的客户端。</p><h3 id="项目级别客户端创建"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#项目级别客户端创建"><span class="icon icon-link"></span></a>项目级别客户端创建</h3><p><code>Interface</code> 对应的客户端实现为<a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.2/marmotedu/clientset.go#L20-L23">Clientset<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，所在的包为 <a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/tree/v1.0.2/marmotedu">marmotedu-sdk-go/marmotedu<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，Clientset客户端的创建方式为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, &quot;/root/.iam/config&quot;)</span></div><div class="token-line"><span class="token plain">    clientset, err := marmotedu.NewForConfig(config)</span></div></pre></div><p>调用方式为 <code>clientset.应用.服务.资源名.接口</code> ，例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">rsp, err := clientset.Iam().AuthzV1().Authz().Authorize()</span></div></pre></div><p>参考示例为 <a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.3/examples/authz_clientset/main.go">marmotedu-sdk-go/examples/authz_clientset/main.go<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><h3 id="应用级别客户端创建"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#应用级别客户端创建"><span class="icon icon-link"></span></a>应用级别客户端创建</h3><p><code>IamInterface</code> 对应的客户端实现为<a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.2/marmotedu/service/iam/iam_client.go#L22-L25">IamClient<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，所在的包为 <a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/tree/v1.0.2/marmotedu/service/iam">marmotedu-sdk-go/marmotedu/service/iam<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，IamClient客户端的创建方式为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, &quot;/root/.iam/config&quot;)</span></div><div class="token-line"><span class="token plain">    iamclient,, err := iam.NewForConfig(config)</span></div></pre></div><p>调用方式为 <code>iamclient.服务.资源名.接口</code> ，例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">rsp, err := iamclient.AuthzV1().Authz().Authorize()</span></div></pre></div><p>参考示例为 <a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.2/examples/authz_iam/main.go">marmotedu-sdk-go/examples/authz_iam/main.go<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><h3 id="服务级别客户端创建"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#服务级别客户端创建"><span class="icon icon-link"></span></a>服务级别客户端创建</h3><p><code>AuthzV1Interface</code> 对应的客户端实现为<a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.2/marmotedu/service/iam/authz/v1/authz_client.go#L21-L23">AuthzV1Client<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，所在的包为 <a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/tree/v1.0.2/marmotedu/service/iam/authz/v1">marmotedu-sdk-go/marmotedu/service/iam/authz/v1<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，AuthzV1Client客户端的创建方式为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, &quot;/root/.iam/config&quot;)</span></div><div class="token-line"><span class="token plain">    client, err := v1.NewForConfig(config)</span></div></pre></div><p>调用方式为 <code>client.资源名.接口</code> ，例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">rsp, err := client.Authz().Authorize()</span></div></pre></div><p>参考示例为 <a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.3/examples/authz/main.go">marmotedu-sdk-go/examples/authz/main.go<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>上面我介绍了marmotedu-sdk-go的客户端创建方法，接下来我们再来看下，这些客户端具体是如何执行REST API请求的。</p><h2 id="marmotedu-sdk-go的实现"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#marmotedu-sdk-go的实现"><span class="icon icon-link"></span></a>marmotedu-sdk-go的实现</h2><p>marmotedu-sdk-go的实现和medu-sdk-go一样，也是采用分层结构，分为API层和基础层。如下图所示：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimagec4b2c40439c97998a01758923394116c33b2.7d55c2b9.jpg" alt=""/></p><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.2/rest/client.go#L95-L105">RESTClient<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>是整个SDK的核心，RESTClient向下通过调用<a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.2/rest/request.go#L28-L50">Request<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>模块，来完成HTTP请求方法、请求路径、请求体、认证信息的构建。Request模块最终通过调用<a target="_blank" rel="noopener noreferrer" href="https://github.com/parnurzeal/gorequest">gorequest<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>包提供的方法，完成HTTP的POST、PUT、GET、DELETE等请求，获取HTTP返回结果，并解析到指定的结构体中。RESTClient向上提供 <code>Post()</code> 、 <code>Put()</code> 、 <code>Get()</code> 、 <code>Delete()</code> 等方法来供客户端完成HTTP请求。</p><p>marmotedu-sdk-go提供了两类客户端，分别是RESTClient客户端和基于RESTClient封装的客户端。</p><ul><li>RESTClient：Raw类型的客户端，可以通过指定HTTP的请求方法、请求路径、请求参数等信息，直接发送HTTP请求，例如 <code>client.Get().AbsPath(&quot;/version&quot;).Do().Into()</code> 。</li><li>基于RESTClient封装的客户端：例如AuthzV1Client、APIV1Client等，执行特定REST资源、特定API接口的请求，方便开发者调用。</li></ul><p>接下来，我们具体看下如何创建RESTClient客户端，以及Request模块的实现。</p><h3 id="restclient客户端实现"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#restclient客户端实现"><span class="icon icon-link"></span></a>RESTClient客户端实现</h3><p>我通过下面两个步骤，实现了RESTClient客户端。</p><p><strong>第一步，创建</strong><a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.2/rest/config.go#L29-L60">rest.Config<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><strong>类型的变量。</strong></p><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.2/tools/clientcmd/client_config.go#L190-L203">BuildConfigFromFlags<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>函数通过加载yaml格式的配置文件，来创建 <code>rest.Config</code> 类型的变量，加载的yaml格式配置文件内容为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apiVersion: v1</span></div><div class="token-line"><span class="token plain">    user:</span></div><div class="token-line"><span class="token plain">      #token: # JWT Token</span></div><div class="token-line"><span class="token plain">      username: admin # iam 用户名</span></div><div class="token-line"><span class="token plain">      password: Admin@2020 # iam 密码</span></div><div class="token-line"><span class="token plain">      #secret-id: # 密钥 ID</span></div><div class="token-line"><span class="token plain">      #secret-key: # 密钥 Key</span></div><div class="token-line"><span class="token plain">      client-certificate: /home/colin/.iam/cert/admin.pem # 用于 TLS 的客户端证书文件路径</span></div><div class="token-line"><span class="token plain">      client-key: /home/colin/.iam/cert/admin-key.pem # 用于 TLS 的客户端 key 文件路径</span></div><div class="token-line"><span class="token plain">      #client-certificate-data:</span></div><div class="token-line"><span class="token plain">      #client-key-data:</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    server:</span></div><div class="token-line"><span class="token plain">      address: https://127.0.0.1:8443 # iam api-server 地址</span></div><div class="token-line"><span class="token plain">      timeout: 10s # 请求 api-server 超时时间</span></div><div class="token-line"><span class="token plain">      #max-retries: # 最大重试次数，默认为 0</span></div><div class="token-line"><span class="token plain">      #retry-interval: # 重试间隔，默认为 1s</span></div><div class="token-line"><span class="token plain">      #tls-server-name: # TLS 服务器名称</span></div><div class="token-line"><span class="token plain">      #insecure-skip-tls-verify: # 设置为 true 表示跳过 TLS 安全验证模式，将使得 HTTPS 连接不安全</span></div><div class="token-line"><span class="token plain">      certificate-authority: /home/colin/.iam/cert/ca.pem # 用于 CA 授权的 cert 文件路径</span></div><div class="token-line"><span class="token plain">      #certificate-authority-data:</span></div></pre></div><p>在配置文件中，我们可以指定服务的地址、用户名/密码、密钥、TLS证书、超时时间、重试次数等信息。</p><p>创建方法如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, *iamconfig)    </span></div><div class="token-line"><span class="token plain">    if err != nil {                                                  </span></div><div class="token-line"><span class="token plain">        panic(err.Error())    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里的代码中，<code>*iamconfig</code> 是yaml格式的配置文件路径。<code>BuildConfigFromFlags</code> 函数中，调用<a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.3/tools/clientcmd/loader.go#L32-L56">LoadFromFile<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>函数来解析yaml配置文件。LoadFromFile最终是通过 <code>yaml.Unmarshal</code> 的方式来解析yaml格式的配置文件的。</p><p><strong>第二步，根据rest.Config类型的变量，创建RESTClient客户端。</strong></p><p>通过<a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.2/rest/config.go#L191-L237">RESTClientFor<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>函数来创建RESTClient客户端：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func RESTClientFor(config *Config) (*RESTClient, error) {</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">        baseURL, versionedAPIPath, err := defaultServerURLFor(config)</span></div><div class="token-line"><span class="token plain">        if err != nil {</span></div><div class="token-line"><span class="token plain">            return nil, err</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // Get the TLS options for this client config</span></div><div class="token-line"><span class="token plain">        tlsConfig, err := TLSConfigFor(config)</span></div><div class="token-line"><span class="token plain">        if err != nil {</span></div><div class="token-line"><span class="token plain">            return nil, err</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // Only retry when get a server side error.</span></div><div class="token-line"><span class="token plain">        client := gorequest.New().TLSClientConfig(tlsConfig).Timeout(config.Timeout).</span></div><div class="token-line"><span class="token plain">            Retry(config.MaxRetries, config.RetryInterval, http.StatusInternalServerError)</span></div><div class="token-line"><span class="token plain">        // NOTICE: must set DoNotClearSuperAgent to true, or the client will clean header befor http.Do</span></div><div class="token-line"><span class="token plain">        client.DoNotClearSuperAgent = true</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        clientContent := ClientContentConfig{</span></div><div class="token-line"><span class="token plain">            Username:           config.Username,</span></div><div class="token-line"><span class="token plain">            Password:           config.Password,</span></div><div class="token-line"><span class="token plain">            SecretID:           config.SecretID,</span></div><div class="token-line"><span class="token plain">            SecretKey:          config.SecretKey,</span></div><div class="token-line"><span class="token plain">            ...</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return NewRESTClient(baseURL, versionedAPIPath, clientContent, client)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>RESTClientFor函数调用<a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.2/rest/url_utils.go#L69-L81">defaultServerURLFor(config)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>生成基本的HTTP请求路径：baseURL=<a target="_blank" rel="noopener noreferrer" href="http://127.0.0.1:8080/%EF%BC%8CversionedAPIPath=/v1%E3%80%82%E7%84%B6%E5%90%8E%EF%BC%8C%E9%80%9A%E8%BF%87%5BTLSConfigFor%5D(https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.2/rest/config.go#L241-L298)%E5%87%BD%E6%95%B0%E7%94%9F%E6%88%90TLS%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%B9%B6%E8%B0%83%E7%94%A8">http://127.0.0.1:8080，versionedAPIPath=/v1。然后，通过[TLSConfigFor](https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.2/rest/config.go#L241-L298)函数生成TLS配置，并调用<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <code>gorequest.New()</code> 创建gorequest客户端，将客户端配置信息保存在变量中。最后，调用<a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.2/rest/client.go#L109-L130">NewRESTClient<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>函数创建RESTClient客户端。</p><p>RESTClient客户端提供了以下方法，来供调用者完成HTTP请求：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (c *RESTClient) APIVersion() scheme.GroupVersion</span></div><div class="token-line"><span class="token plain">    func (c *RESTClient) Delete() *Request</span></div><div class="token-line"><span class="token plain">    func (c *RESTClient) Get() *Request</span></div><div class="token-line"><span class="token plain">    func (c *RESTClient) Post() *Request</span></div><div class="token-line"><span class="token plain">    func (c *RESTClient) Put() *Request</span></div><div class="token-line"><span class="token plain">    func (c *RESTClient) Verb(verb string) *Request</span></div></pre></div><p>可以看到，RESTClient提供了 <code>Delete</code> 、 <code>Get</code> 、 <code>Post</code> 、 <code>Put</code> 方法，分别用来执行HTTP的DELETE、GET、POST、PUT方法，提供的 <code>Verb</code> 方法可以灵活地指定HTTP方法。这些方法都返回了 <code>Request</code> 类型的变量。<code>Request</code> 类型的变量提供了一些方法，用来完成具体的HTTP请求，例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Response struct {</span></div><div class="token-line"><span class="token plain">        Allowed bool   `json:&quot;allowed&quot;`</span></div><div class="token-line"><span class="token plain">        Denied  bool   `json:&quot;denied,omitempty&quot;`</span></div><div class="token-line"><span class="token plain">        Reason  string `json:&quot;reason,omitempty&quot;`</span></div><div class="token-line"><span class="token plain">        Error   string `json:&quot;error,omitempty&quot;`</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (c *authz) Authorize(ctx context.Context, request *ladon.Request, opts metav1.AuthorizeOptions) (result *Response, err error) {</span></div><div class="token-line"><span class="token plain">        result = &amp;Response{}                                         </span></div><div class="token-line"><span class="token plain">        err = c.client.Post().</span></div><div class="token-line"><span class="token plain">            Resource(&quot;authz&quot;).</span></div><div class="token-line"><span class="token plain">            VersionedParams(opts).</span></div><div class="token-line"><span class="token plain">            Body(request).</span></div><div class="token-line"><span class="token plain">            Do(ctx).</span></div><div class="token-line"><span class="token plain">            Into(result)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面的代码中， <code>c.client</code> 是RESTClient客户端，通过调用RESTClient客户端的 <code>Post</code> 方法，返回了 <code>*Request</code> 类型的变量。</p><p><code>*Request</code> 类型的变量提供了 <code>Resource</code> 和 <code>VersionedParams</code> 方法，来构建请求HTTP URL中的路径 <code>/v1/authz</code> ；通过 <code>Body</code> 方法，指定了HTTP请求的Body。</p><p>到这里，我们分别构建了HTTP请求需要的参数：HTTP Method、请求URL、请求Body。所以，之后就可以调用 <code>Do</code> 方法来执行HTTP请求，并将返回结果通过 <code>Into</code> 方法保存在传入的result变量中。</p><h3 id="request模块实现"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#request模块实现"><span class="icon icon-link"></span></a>Request模块实现</h3><p>RESTClient客户端的方法会返回Request类型的变量，Request类型的变量提供了一系列的方法用来构建HTTP请求参数，并执行HTTP请求。</p><p>所以，Request模块可以理解为最底层的通信层，我们来看下Request模块具体是如何完成HTTP请求的。</p><p>我们先来看下<a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.3/rest/request.go#L28-L50">Request结构体<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的定义：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type RESTClient struct {           </span></div><div class="token-line"><span class="token plain">        // base is the root URL for all invocations of the client    </span></div><div class="token-line"><span class="token plain">        base *url.URL    </span></div><div class="token-line"><span class="token plain">        // group stand for the client group, eg: iam.api, iam.authz                       </span></div><div class="token-line"><span class="token plain">        group string                                                                          </span></div><div class="token-line"><span class="token plain">        // versionedAPIPath is a path segment connecting the base URL to the resource root    </span></div><div class="token-line"><span class="token plain">        versionedAPIPath string                                      </span></div><div class="token-line"><span class="token plain">        // content describes how a RESTClient encodes and decodes responses.    </span></div><div class="token-line"><span class="token plain">        content ClientContentConfig    </span></div><div class="token-line"><span class="token plain">        Client  *gorequest.SuperAgent    </span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type Request struct {</span></div><div class="token-line"><span class="token plain">    	c *RESTClient</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	timeout time.Duration</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// generic components accessible via method setters</span></div><div class="token-line"><span class="token plain">    	verb       string</span></div><div class="token-line"><span class="token plain">    	pathPrefix string</span></div><div class="token-line"><span class="token plain">    	subpath    string</span></div><div class="token-line"><span class="token plain">    	params     url.Values</span></div><div class="token-line"><span class="token plain">    	headers    http.Header</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// structural elements of the request that are part of the IAM API conventions</span></div><div class="token-line"><span class="token plain">    	// namespace    string</span></div><div class="token-line"><span class="token plain">    	// namespaceSet bool</span></div><div class="token-line"><span class="token plain">    	resource     string</span></div><div class="token-line"><span class="token plain">    	resourceName string</span></div><div class="token-line"><span class="token plain">    	subresource  string</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// output</span></div><div class="token-line"><span class="token plain">    	err  error</span></div><div class="token-line"><span class="token plain">    	body interface{}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>再来看下Request结构体提供的方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (r *Request) AbsPath(segments ...string) *Request</span></div><div class="token-line"><span class="token plain">    func (r *Request) Body(obj interface{}) *Request</span></div><div class="token-line"><span class="token plain">    func (r *Request) Do(ctx context.Context) Result</span></div><div class="token-line"><span class="token plain">    func (r *Request) Name(resourceName string) *Request</span></div><div class="token-line"><span class="token plain">    func (r *Request) Param(paramName, s string) *Request</span></div><div class="token-line"><span class="token plain">    func (r *Request) Prefix(segments ...string) *Request</span></div><div class="token-line"><span class="token plain">    func (r *Request) RequestURI(uri string) *Request</span></div><div class="token-line"><span class="token plain">    func (r *Request) Resource(resource string) *Request</span></div><div class="token-line"><span class="token plain">    func (r *Request) SetHeader(key string, values ...string) *Request</span></div><div class="token-line"><span class="token plain">    func (r *Request) SubResource(subresources ...string) *Request</span></div><div class="token-line"><span class="token plain">    func (r *Request) Suffix(segments ...string) *Request</span></div><div class="token-line"><span class="token plain">    func (r *Request) Timeout(d time.Duration) *Request</span></div><div class="token-line"><span class="token plain">    func (r *Request) URL() *url.URL</span></div><div class="token-line"><span class="token plain">    func (r *Request) Verb(verb string) *Request</span></div><div class="token-line"><span class="token plain">    func (r *Request) VersionedParams(v interface{}) *Request</span></div></pre></div><p>通过Request结构体的定义和使用方法，我们不难猜测出：Request模块通过 <code>Name</code> 、 <code>Resource</code> 、 <code>Body</code> 、 <code>SetHeader</code> 等方法来设置Request结构体中的各个字段。这些字段最终用来构建出一个HTTP请求，并通过 <code>Do</code> 方法来执行HTTP请求。</p><p>那么，如何构建并执行一个HTTP请求呢？我们可以通过以下5步，来构建并执行HTTP请求：</p><ol><li>构建HTTP URL；</li><li>构建HTTP Method；</li><li>构建HTTP Body；</li><li>执行HTTP请求；</li><li>保存HTTP返回结果。</li></ol><p>接下来，我们就来具体看下Request模块是如何构建这些请求参数，并发送HTTP请求的。</p><p><strong>第一步，构建HTTP URL。</strong></p><p>首先，通过<a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.3/rest/url_utils.go#L69-L81">defaultServerURLFor<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>函数返回了<code>http://iam.api.marmotedu.com:8080</code> 和 <code>/v1</code> ，并将二者分别保存在了Request类型结构体变量中 <code>c</code> 字段的 <code>base</code> 字段和 <code>versionedAPIPath</code> 字段中。</p><p>通过 <a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.3/rest/request.go#L379-L416">Do<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 方法执行HTTP时，会调用<a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.3/rest/request.go#L392">r.URL()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>方法来构建请求URL。 <code>r.URL</code> 方法中，通过以下代码段构建了HTTP请求URL：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (r *Request) URL() *url.URL {</span></div><div class="token-line"><span class="token plain">        p := r.pathPrefix</span></div><div class="token-line"><span class="token plain">        if len(r.resource) != 0 {</span></div><div class="token-line"><span class="token plain">            p = path.Join(p, strings.ToLower(r.resource))</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if len(r.resourceName) != 0 || len(r.subpath) != 0 || len(r.subresource) != 0 {</span></div><div class="token-line"><span class="token plain">            p = path.Join(p, r.resourceName, r.subresource, r.subpath)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">                                                                                       </span></div><div class="token-line"><span class="token plain">        finalURL := &amp;url.URL{}</span></div><div class="token-line"><span class="token plain">        if r.c.base != nil {</span></div><div class="token-line"><span class="token plain">            *finalURL = *r.c.bas</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">        finalURL.Path = p</span></div><div class="token-line"><span class="token plain">        ...    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><code>p := r.pathPrefix</code> 和 <code>r.c.base</code> ，是通过 <code>defaultServerURLFor</code> 调用返回的 <code>v1</code> 和 <code>http://iam.api.marmotedu.com:8080</code> 来构建的。</p><p><code>resourceName</code> 通过 <code>func (r *Request) Resource(resource string) *Request</code> 来指定，例如 <code>authz</code> 。</p><p>所以，最终我们构建的请求URL为 <code>http://iam.api.marmotedu.com:8080/v1/authz</code> 。</p><p><strong>第二步，构建HTTP Method。</strong></p><p>HTTP Method通过RESTClient提供的 <code>Post</code> 、<code>Delete</code> 、<code>Get</code> 等方法来设置，例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (c *RESTClient) Post() *Request {                                                                                 </span></div><div class="token-line"><span class="token plain">        return c.Verb(&quot;POST&quot;)                                                                                              </span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (c *RESTClient) Verb(verb string) *Request {                                                                      </span></div><div class="token-line"><span class="token plain">        return NewRequest(c).Verb(verb)                                                                                    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><code>NewRequest(c).Verb(verb)</code> 最终设置了Request结构体的 <code>verb</code> 字段，供 <code>Do</code> 方法使用。</p><p><strong>第三步，构建HTTP Body。</strong></p><p>HTTP Body通过Request结构体提供的Body方法来指定：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (r *Request) Body(obj interface{}) *Request {                    </span></div><div class="token-line"><span class="token plain">        if v := reflect.ValueOf(obj); v.Kind() == reflect.Struct {              </span></div><div class="token-line"><span class="token plain">            r.SetHeader(&quot;Content-Type&quot;, r.c.content.ContentType)                </span></div><div class="token-line"><span class="token plain">        }                                                                                                                  </span></div><div class="token-line"><span class="token plain">                                                                                                                           </span></div><div class="token-line"><span class="token plain">        r.body = obj                                                                                                       </span></div><div class="token-line"><span class="token plain">                                                                                                                           </span></div><div class="token-line"><span class="token plain">        return r                                                                                                           </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><strong>第四步，执行HTTP请求。</strong></p><p>通过Request结构体提供的Do方法来执行具体的HTTP请求，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (r *Request) Do(ctx context.Context) Result {</span></div><div class="token-line"><span class="token plain">    	client := r.c.Client</span></div><div class="token-line"><span class="token plain">    	client.Header = r.headers</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	if r.timeout &gt; 0 {</span></div><div class="token-line"><span class="token plain">    		var cancel context.CancelFunc</span></div><div class="token-line"><span class="token plain">    		ctx, cancel = context.WithTimeout(ctx, r.timeout)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		defer cancel()</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	client.WithContext(ctx)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	resp, body, errs := client.CustomMethod(r.verb, r.URL().String()).Send(r.body).EndBytes()</span></div><div class="token-line"><span class="token plain">    	if err := combineErr(resp, body, errs); err != nil {</span></div><div class="token-line"><span class="token plain">    		return Result{</span></div><div class="token-line"><span class="token plain">    			response: &amp;resp,</span></div><div class="token-line"><span class="token plain">    			err:      err,</span></div><div class="token-line"><span class="token plain">    			body:     body,</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	decoder, err := r.c.content.Negotiator.Decoder()</span></div><div class="token-line"><span class="token plain">    	if err != nil {</span></div><div class="token-line"><span class="token plain">    		return Result{</span></div><div class="token-line"><span class="token plain">    			response: &amp;resp,</span></div><div class="token-line"><span class="token plain">    			err:      err,</span></div><div class="token-line"><span class="token plain">    			body:     body,</span></div><div class="token-line"><span class="token plain">    			decoder:  decoder,</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	return Result{</span></div><div class="token-line"><span class="token plain">    		response: &amp;resp,</span></div><div class="token-line"><span class="token plain">    		body:     body,</span></div><div class="token-line"><span class="token plain">    		decoder:  decoder,</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在Do方法中，使用了Request结构体变量中各个字段的值，通过 <code>client.CustomMethod</code> 来执行HTTP请求。 <code>client</code> 是 <code>*gorequest.SuperAgent</code> 类型的客户端。</p><p><strong>第五步，保存HTTP返回结果。</strong></p><p>通过Request结构体的 <code>Into</code> 方法来保存HTTP返回结果：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (r Result) Into(v interface{}) error {</span></div><div class="token-line"><span class="token plain">        if r.err != nil {                                          </span></div><div class="token-line"><span class="token plain">            return r.Error()</span></div><div class="token-line"><span class="token plain">        }                                                                                 </span></div><div class="token-line"><span class="token plain">                                                             </span></div><div class="token-line"><span class="token plain">        if r.decoder == nil {                                                                    </span></div><div class="token-line"><span class="token plain">            return fmt.Errorf(&quot;serializer doesn&#x27;t exist&quot;)</span></div><div class="token-line"><span class="token plain">        }                            </span></div><div class="token-line"><span class="token plain">                                 </span></div><div class="token-line"><span class="token plain">        if err := r.decoder.Decode(r.body, &amp;v); err != nil {</span></div><div class="token-line"><span class="token plain">            return err                                                                    </span></div><div class="token-line"><span class="token plain">        }                                                                                        </span></div><div class="token-line"><span class="token plain">                                                                 </span></div><div class="token-line"><span class="token plain">        return nil                                                                      </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><code>r.body</code> 是在Do方法中，执行完HTTP请求后设置的，它的值为HTTP请求返回的Body。</p><h3 id="请求认证"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#请求认证"><span class="icon icon-link"></span></a>请求认证</h3><p>接下来，我再来介绍下marmotedu-sdk-go另外一个比较核心的功能：请求认证。</p><p>marmotedu-sdk-go支持两种认证方式：</p><ul><li>Basic认证：通过给请求添加 <code>Authorization: Basic xxxx</code> 来实现。</li><li>Bearer认证：通过给请求添加 <code>Authorization: Bearer xxxx</code> 来实现。这种方式又支持直接指定JWT Token，或者通过指定密钥对由SDK自动生成JWT Token。</li></ul><p>Basic认证和Bearer认证，我在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/398410">25讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>介绍过，你可以返回查看下。</p><p>认证头是RESTClient客户端发送HTTP请求时指定的，具体实现位于<a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.2/rest/request.go#L53-L102">NewRequest<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>函数中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">switch {</span></div><div class="token-line"><span class="token plain">        case c.content.HasTokenAuth():</span></div><div class="token-line"><span class="token plain">            r.SetHeader(&quot;Authorization&quot;, fmt.Sprintf(&quot;Bearer %s&quot;, c.content.BearerToken))</span></div><div class="token-line"><span class="token plain">        case c.content.HasKeyAuth():</span></div><div class="token-line"><span class="token plain">            tokenString := auth.Sign(c.content.SecretID, c.content.SecretKey, &quot;marmotedu-sdk-go&quot;, c.group+&quot;.marmotedu.com&quot;)</span></div><div class="token-line"><span class="token plain">            r.SetHeader(&quot;Authorization&quot;, fmt.Sprintf(&quot;Bearer %s&quot;, tokenString))</span></div><div class="token-line"><span class="token plain">        case c.content.HasBasicAuth():</span></div><div class="token-line"><span class="token plain">            // TODO: get token and set header</span></div><div class="token-line"><span class="token plain">            r.SetHeader(&quot;Authorization&quot;, &quot;Basic &quot;+basicAuth(c.content.Username, c.content.Password))</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面的代码会根据配置信息，自动判断使用哪种认证方式。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#总结"><span class="icon icon-link"></span></a>总结</h2><p>这一讲中，我介绍了Kubernetes client-go风格的SDK实现方式。和公有云厂商的SDK设计相比，client-go风格的SDK设计有很多优点。</p><p>marmotedu-sdk-go在设计时，通过接口实现了3类客户端，分别是项目级别的客户端、应用级别的客户端和服务级别的客户端。开发人员可以根据需要，自行创建客户端类型。</p><p>marmotedu-sdk-go通过<a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.2/rest/config.go#L191-L237">RESTClientFor<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，创建了RESTClient类型的客户端，RESTClient向下通过调用<a target="_blank" rel="noopener noreferrer" href="https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.2/rest/request.go#L28-L50">Request<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>模块，来完成HTTP请求方法、请求路径、请求体、认证信息的构建。Request模块最终通过调用<a target="_blank" rel="noopener noreferrer" href="https://github.com/parnurzeal/gorequest">gorequest<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>包提供的方法，完成HTTP的POST、PUT、GET、DELETE等请求，获取HTTP返回结果，并解析到指定的结构体中。RESTClient向上提供 <code>Post()</code> 、 <code>Put()</code> 、 <code>Get()</code> 、 <code>Delete()</code> 等方法，来供客户端完成HTTP请求。</p><h2 id="课后练习"><a aria-hidden="true" tabindex="-1" href="/blog-backend/go语言项目开发实战/05.实战第3站服务开发/11#课后练习"><span class="icon icon-link"></span></a>课后练习</h2><ol><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">阅读[defaultServerURLFor](https://github.com/marmotedu/marmotedu-sdk-go/blob/v1.0.3/rest/url_utils.go#L69-L81)源码，思考下defaultServerURLFor是如何构建请求地址 `http://iam.api.marmotedu.com:8080` 和API版本 `/v1` 的。</span></div></pre></div></li><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">使用[gorequest](https://github.com/parnurzeal/gorequest)包，编写一个可以执行以下HTTP请求的示例：</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">curl -XPOST http://example.com/v1/user -d &#x27;{&quot;username&quot;:&quot;colin&quot;,&quot;address&quot;:&quot;shenzhen&quot;}&#x27;</span></div></pre></div><p>欢迎你在留言区与我交流讨论，我们下一讲见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/go语言项目开发实战/05.实战第3站服务开发/11.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
