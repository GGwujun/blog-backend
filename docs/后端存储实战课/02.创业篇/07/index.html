<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>07｜MySQL HA：如何将“删库跑路”的损失降到最低？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/后端存储实战课/02.创业篇/07" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a aria-current="page" class="active" href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a aria-current="page" class="active" href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端存储实战课/01.课前必读">01.课前必读</a><ul><li><a href="/blog-backend/后端存储实战课/01.课前必读/01"><span>开篇词 | 从今天起，换种方式学存储</span></a></li><li><a href="/blog-backend/后端存储实战课/01.课前必读/02"><span>课前加餐 | 电商系统是如何设计的？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/后端存储实战课/02.创业篇">02.创业篇</a><ul><li><a href="/blog-backend/后端存储实战课/02.创业篇/01"><span>01 | 创建和更新订单时，如何保证数据准确无误？</span></a></li><li><a href="/blog-backend/后端存储实战课/02.创业篇/02"><span>02 | 流量大、数据多的商品详情页系统该如何设计？</span></a></li><li><a href="/blog-backend/后端存储实战课/02.创业篇/03"><span>03 | 复杂而又重要的购物车系统，应该如何设计？</span></a></li><li><a href="/blog-backend/后端存储实战课/02.创业篇/04"><span>04 | 事务：账户余额总是对不上账，怎么办？</span></a></li><li><a href="/blog-backend/后端存储实战课/02.创业篇/05"><span>05 | 分布式事务：如何保证多个系统间的数据是一致的？</span></a></li><li><a href="/blog-backend/后端存储实战课/02.创业篇/06"><span>06 | 如何用Elasticsearch构建商品搜索系统？</span></a></li><li><a aria-current="page" class="active" href="/blog-backend/后端存储实战课/02.创业篇/07"><span>07｜MySQL HA：如何将“删库跑路”的损失降到最低？</span></a></li></ul></li><li><a href="/blog-backend/后端存储实战课/03.高速增长篇">03.高速增长篇</a><ul><li><a href="/blog-backend/后端存储实战课/03.高速增长篇/01"><span>08 | 一个几乎每个系统必踩的坑儿：访问数据库超时</span></a></li><li><a href="/blog-backend/后端存储实战课/03.高速增长篇/02"><span>09 | 怎么能避免写出慢SQL？</span></a></li><li><a href="/blog-backend/后端存储实战课/03.高速增长篇/03"><span>10 | 走进黑盒：SQL是如何在数据库中执行的？</span></a></li><li><a href="/blog-backend/后端存储实战课/03.高速增长篇/04"><span>11 | MySQL如何应对高并发（一）：使用缓存保护MySQL</span></a></li><li><a href="/blog-backend/后端存储实战课/03.高速增长篇/05"><span>12 | MySQL如何应对高并发（二）：读写分离</span></a></li><li><a href="/blog-backend/后端存储实战课/03.高速增长篇/06"><span>13 | MySQL主从数据库同步是如何实现的？</span></a></li><li><a href="/blog-backend/后端存储实战课/03.高速增长篇/07"><span>14 | 订单数据越来越多，数据库越来越慢该怎么办？</span></a></li></ul></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇">04.海量数据篇</a><ul><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/01"><span>15 | MySQL存储海量数据的最后一招：分库分表</span></a></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/02"><span>16 | 用Redis构建缓存集群的最佳实践有哪些？</span></a></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/03"><span>17 | 大厂都是怎么做MySQL to Redis同步的?</span></a></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/04"><span>18 | 分布式存储：你知道对象存储是如何保存图片文件的吗？</span></a></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/05"><span>19 | 跨系统实时同步数据，分布式事务是唯一的解决方案吗？</span></a></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/06"><span>20 | 如何在不停机的情况下，安全地更换数据库？</span></a></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/07"><span>21 | 类似“点击流”这样的海量数据应该如何存储？</span></a></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/08"><span>22 | 面对海量数据，如何才能查得更快?</span></a></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/09"><span>23 | MySQL经常遇到的高可用、分片问题，NewSQL是如何解决的？</span></a></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/10"><span>24 | RocksDB：不丢数据的高性能KV存储</span></a></li></ul></li><li><a href="/blog-backend/后端存储实战课/05.结课测试">05.结课测试</a><ul><li><a href="/blog-backend/后端存储实战课/05.结课测试/01"><span>结课测试 | 后端存储，100分试卷等你来挑战</span></a></li></ul></li><li><a href="/blog-backend/后端存储实战课/06.结束语">06.结束语</a><ul><li><a href="/blog-backend/后端存储实战课/06.结束语/01"><span>结束语 | 把奋斗当习惯</span></a></li></ul></li><li><a href="/blog-backend/后端存储实战课/07.特别放送">07.特别放送</a><ul><li><a href="/blog-backend/后端存储实战课/07.特别放送/01"><span>特别放送 | 如何平衡存储系统的一致性和可用性？</span></a></li><li><a href="/blog-backend/后端存储实战课/07.特别放送/02"><span>特别放送 | 和你分享一个好消息：这门课被出版了一本书</span></a></li></ul></li><li><a href="/blog-backend/后端存储实战课/summary">后端存储实战课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="如何更安全地做数据备份和恢复？" data-depth="2"><a href="/blog-backend/后端存储实战课/02.创业篇/07#如何更安全地做数据备份和恢复"><span>如何更安全地做数据备份和恢复？</span></a></li><li title="配置MySQL HA实现高可用" data-depth="2"><a href="/blog-backend/后端存储实战课/02.创业篇/07#配置mysql-ha实现高可用"><span>配置MySQL HA实现高可用</span></a></li><li title="小结" data-depth="2"><a href="/blog-backend/后端存储实战课/02.创业篇/07#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-backend/后端存储实战课/02.创业篇/07#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="07mysql-ha如何将删库跑路的损失降到最低"><a aria-hidden="true" tabindex="-1" href="/blog-backend/后端存储实战课/02.创业篇/07#07mysql-ha如何将删库跑路的损失降到最低"><span class="icon icon-link"></span></a>07｜MySQL HA：如何将“删库跑路”的损失降到最低？</h1><p>你好，我是李玥。</p><p>对于任何一个企业来说，数据安全的重要性是不言而喻的。我在开篇词中也曾经强调过，凡是涉及到数据的问题，都是损失惨重的大问题。</p><p>能够影响数据安全的事件，都是极小概率的事件，比如说：数据库宕机、磁盘损坏甚至机房着火，还有最近频繁出现在段子中“程序员不满老板删库跑路”的梗儿，但这些事儿一旦发生了，我们的业务就会损失惨重。</p><p>一般来说，存储系统导致的比较严重的损失主要有两种情况，一是数据丢失造成的直接财产损失，比如大量的坏账；二是由于存储系统损坏，造成整个业务系统停止服务而带来的损失。</p><p>所谓防患于未然，你从设计一个系统的第一天起，就需要考虑在出现各种问题的时候，如何来保证这个系统的数据安全性。今天我们来聊一聊，如何提前预防，将“删库跑路”等这类问题导致的损失尽量降到最低。</p><h2 id="如何更安全地做数据备份和恢复"><a aria-hidden="true" tabindex="-1" href="/blog-backend/后端存储实战课/02.创业篇/07#如何更安全地做数据备份和恢复"><span class="icon icon-link"></span></a>如何更安全地做数据备份和恢复？</h2><p>保证数据安全，最简单而且有效的手段就是定期备份数据，这样出现任何问题导致的数据损失，都可以通过备份来恢复数据。但是，如何备份，才能最大程度地保证数据安全，并不是一个简单的事儿。</p><p>2018年还出现过某个著名的云服务商因为硬盘损坏，导致多个客户数据全部丢失的重大故障。这么大的云服务商，数据是不可能没有备份的，按说硬盘损坏，不会导致数据丢失的，但是因为各种各样的原因，最终的结果是数据的三个副本都被删除，数据丢失无法找回。</p><p>所以说，不是简单地定期把数据备份一下就可以高枕无忧了。接下来我们还是以大家最常用的MySQL为例来说一下，如何更安全地来做数据备份和恢复。</p><p>最简单的备份方式就是全量备份。备份的时候，把所有的数据复制一份，存放到文件中，恢复的时候再把文件中的数据复制回去，这样可以保证恢复之后数据库中的数据和备份时是完全一样的。在MySQL中，你可以使用<a target="_blank" rel="noopener noreferrer" href="https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html">mysqldump<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>命令来执行全量备份。</p><p>比如我们要全量备份数据库test：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$mysqldump -uroot -p test &gt; test.sql</span></div></pre></div><p>备份出来的文件就是一个SQL文件，就是创建数据库、表，写入数据等等这些SQL，如果要恢复数据，直接执行这个备份的SQL文件就可以了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$mysql -uroot test &lt; test.sql</span></div></pre></div><p>不过，全量备份的代价非常高，为什么这么说呢？</p><p>首先，备份文件包含数据库中的所有数据，占用的磁盘空间非常大；其次，每次备份操作都要拷贝大量数据，备份过程中会占用数据库服务器大量的CPU、磁盘IO资源，并且为了保证数据一致性，还有可能会锁表，这些都会导致备份期间，数据库本身的性能严重下降。所以，我们不能经常对数据库执行全量备份。</p><p>一般来说，每天执行一次全量备份已经是非常频繁了。那这就意味着，如果数据库中的数据丢了，那只能恢复到最近一次全量备份的那个时间点，这个时间点之后的数据还是丢了。也就是说，全量备份不能做到完全无损地恢复。</p><p>既然全量备份代价太高，不能频繁执行，那有没有代价低一点儿的备份方法，能让我们少丢甚至不丢数据呢？还真有，那就是<strong>增量备份</strong>。相比于全量备份，增量备份每次只备份相对于上一次备份变化的那部分数据，所以每次增量备份速度更快。</p><p>MySQL自带了Binlog，就是一种实时的增量备份。Binlog里面记录的就是MySQL数据的变更的操作日志，开启Binlog之后，我们对MySQL中的每次更新数据操作，都会被记录到Binlog中。</p><p>Binlog是可以回放的，回放Binlog，就相当于把之前对数据库所有数据更新操作按照顺序重新执行了一遍，回放完成之后数据自然就恢复了。这就是Binlog增量备份的基本原理。很多数据库都有类似于MySQL Binlog的日志，原理和Binlog是一样的，备份和恢复方法也是类似的。</p><p>下面通过一个例子看一下如何使用Binlog进行备份和恢复。首先使用“show variables like ‘%log_bin%’”命令确认一下是否开启了Binlog功能：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">mysql&gt; show variables like &#x27;%log_bin%&#x27;;</span></div><div class="token-line"><span class="token plain">    +---------------------------------+-----------------------------------+</span></div><div class="token-line"><span class="token plain">    | Variable_name                   | Value                             |</span></div><div class="token-line"><span class="token plain">    +---------------------------------+-----------------------------------+</span></div><div class="token-line"><span class="token plain">    | log_bin                         | ON                                |</span></div><div class="token-line"><span class="token plain">    | log_bin_basename                | /usr/local/var/mysql/binlog       |</span></div><div class="token-line"><span class="token plain">    +---------------------------------+-----------------------------------+</span></div><div class="token-line"><span class="token plain">    mysql&gt; show master status;</span></div><div class="token-line"><span class="token plain">    +---------------+----------+--------------+------------------+-------------------+</span></div><div class="token-line"><span class="token plain">    | File          | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span></div><div class="token-line"><span class="token plain">    +---------------+----------+--------------+------------------+-------------------+</span></div><div class="token-line"><span class="token plain">    | binlog.000001 |    18745 |              |                  |                   |</span></div><div class="token-line"><span class="token plain">    +---------------+----------+--------------+------------------+-------------------+</span></div></pre></div><p>可以看到当前这个数据库已经开启了Binlog，log_bin_basename表示Binlog文件在服务器磁盘上的具体位置。然后用“show master status”命令可查看当前Binlog的状态，显示正在写入的Binlog文件，及当前的位置。假设我们每天凌晨用mysqldump做一个全量备份，然后开启了Binlog，有了这些，我们就可以把数据恢复到全量备份之后的任何一个时刻。</p><p>下面我们做一个简单的备份恢复演示。我们先模拟一次“删库跑路”的场景，直接把账户余额表清空：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">mysql&gt; truncate table account_balance;</span></div><div class="token-line"><span class="token plain">    Query OK, 0 rows affected (0.02 sec)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    mysql&gt; select * from  account_balance;</span></div><div class="token-line"><span class="token plain">    Empty set (0.00 sec)</span></div></pre></div><p>然后我们来进行数据恢复，首先执行一次全量恢复，把数据库恢复到今天凌晨的状态。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$mysql -uroot test &lt; dump.sql</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    mysql&gt; select * from  account_balance;</span></div><div class="token-line"><span class="token plain">    +---------+---------+---------------------+--------+</span></div><div class="token-line"><span class="token plain">    | user_id | balance | timestamp           | log_id |</span></div><div class="token-line"><span class="token plain">    +---------+---------+---------------------+--------+</span></div><div class="token-line"><span class="token plain">    |       0 |     100 | 2020-02-13 20:24:33 |      3 |</span></div><div class="token-line"><span class="token plain">    +---------+---------+---------------------+--------+</span></div></pre></div><p>可以看到，表里面的数据已经恢复了，但还是比较旧的数据。然后我们再用Binlog把数据恢复到删库跑路之前的那个时刻：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$mysqlbinlog --start-datetime &quot;2020-02-20 00:00:00&quot; --stop-datetime &quot;2020-02-20 15:09:00&quot; /usr/local/var/mysql/binlog.000001 | mysql -uroot</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    mysql&gt; select * from  account_balance;</span></div><div class="token-line"><span class="token plain">    +---------+---------+---------------------+--------+</span></div><div class="token-line"><span class="token plain">    | user_id | balance | timestamp           | log_id |</span></div><div class="token-line"><span class="token plain">    +---------+---------+---------------------+--------+</span></div><div class="token-line"><span class="token plain">    |       0 |     200 | 2020-02-20 15:08:12 |      0 |</span></div><div class="token-line"><span class="token plain">    +---------+---------+---------------------+--------+</span></div></pre></div><p>这时候，数据已经恢复到当天的15点了。</p><p>通过定期的全量备份，配合Binlog，我们就可以把数据恢复到任意一个时间点，再也不怕程序员删库跑路了。详细的命令你可以参考<a target="_blank" rel="noopener noreferrer" href="https://dev.mysql.com/doc/refman/8.0/en/backup-and-recovery.html">MySQL的官方文档中“备份和恢复”这一章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>在执行备份和恢复的时候，有几个要点你需要特别的注意。</p><p><strong>第一，也是最重要的，“不要把所有的鸡蛋放在同一个篮子中”，无论是全量备份还是Binlog，都不要和数据库存放在同一个服务器上</strong>**。**最好能做到不同机房，甚至不同城市，离得越远越好。这样即使出现机房着火、光缆被挖断甚至地震也不怕。</p><p><strong>第二，在回放Binlog的时候，指定的起始时间可以比全量备份的时间稍微提前一点儿，确保全量备份之后的所有操作都在恢复的Binlog范围内，这样可以保证恢复的数据的完整性。</strong></p><p>因为回放Binlog的操作是具备幂等性的（为了确保回放幂等，需要设置Binlog的格式为ROW格式)，关于幂等性，我们在《<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/204673">01 | 创建和更新订单时，如何保证数据准确无误？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》这节课中讲到过，多次操作和一次操作对系统的影响是一样的，所以重复回放的那部分Binlog并不会影响数据的准确性。</p><h2 id="配置mysql-ha实现高可用"><a aria-hidden="true" tabindex="-1" href="/blog-backend/后端存储实战课/02.创业篇/07#配置mysql-ha实现高可用"><span class="icon icon-link"></span></a>配置MySQL HA实现高可用</h2><p>通过全量备份加上Binlog，我们可以将数据库恢复到任何一个时间点，这样至少不会丢数据了。如果说，数据库服务器宕机了，因为我们有备份数据，完全可以启动一个新的数据库服务器，把备份数据恢复到新的数据库上，这样新的数据库就可以替代宕机的数据库，继续提供服务。</p><p>但是，这个恢复数据的时间是很长的，如果数据量比较大的话，有可能需要恢复几个小时。这几个小时，我们的系统是一直不可用的，这样肯定不行。</p><p>这个问题怎么解决？很简单，你不要等着数据库宕机了，才开始做恢复，我们完全可以提前来做恢复这些事儿。</p><p>我们准备一台备用的数据库，把它的数据恢复成主库一样，然后实时地在主备数据库之间来同步Binlog，主库做了一次数据变更，生成一条Binlog，我们就把这一条Binlog复制到备用库并立即回放，这样就可以让备用库里面的数据和主库中的数据一直保持是一样的。一旦主库宕机，就可以立即切换到备用库上继续提供服务。这就是MySQL的高可用方案，也叫MySQL HA。</p><p>MySQL自身就提供了主从复制的功能，通过配置就可以让一主一备两台MySQL的数据库保持数据同步，具体的配置方法你可以参考<a target="_blank" rel="noopener noreferrer" href="https://dev.mysql.com/doc/refman/8.0/en/replication.html">MySQ官方文档中“复制”这一章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>接下来我们说这个方案的问题。当我们对主库执行一次更新操作的时候，主从两个数据库更新数据实际的时序是这样的：</p><ol><li>在主库的磁盘上写入Binlog；</li><li>主库更新存储引擎中的数据；</li><li>给客户端返回成功响应；</li><li>主库把Binlog复制到从库；</li><li>从库回放Binlog，更新存储引擎中的数据。</li></ol><p>也就是说，从库的数据是有可能比主库上的数据旧一些的，这个主从之间复制数据的延迟，称为“主从延迟”。正常情况下，主从延迟基本都是毫秒级别，你可以认为主从就是实时保持同步的。麻烦的是不正常的情况，一旦主库或者从库繁忙的时候，有可能会出现明显的主从延迟。</p><p>而很多情况下，数据库都不是突然宕机的，而是先繁忙，性能下降，最终宕机。这种情况下，很有可能主从延迟很大，如果我们把业务直接切到从库上继续读写，主从延迟这部分数据就丢了，并且这个数据丢失是不可逆的。即使事后你找回了当时主库的Binlog也是没法做到自动恢复的，因为它和从库的数据是冲突的。</p><p>简单地说，如果主库宕机并且主从存在延迟的情况下，切换到从库继续读写，可以保证业务的可用性，但是主从延迟这部分数据就丢失了。</p><p>这个时候你就需要做一个选择题了，第一个选项是，保证不丢数据，牺牲可用性，暂时停止服务，想办法把主库的Binlog恢复到从库上之后再提供服务。第二个选项就是，冒着丢一些数据的风险，保证可用性，第一时间切换到从库继续提供服务。</p><p>那能不能既保证数据不丢，还能做到高可用呢？也是可以的，那你就要牺牲一些性能。MySQL也支持<a target="_blank" rel="noopener noreferrer" href="https://dev.mysql.com/doc/refman/8.0/en/replication-semisync.html">同步复制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，开启同步复制时，MySQL主库会等待数据成功复制到从库之后，再给客户端返回响应。</p><p>如果说，牺牲的这点儿性能我不在乎，这个方案是不是就完美了呢？也不是，新的问题又来了！你想一下，这种情况下从库宕机了怎么办？本来从库宕机对主库是完全没影响的，因为现在主库要等待从库写入成功再返回，从库宕机，主库就会一直等待从库，主库也卡死了。</p><p>这个问题也有解决办法，那就是再加一个从库，把主库配置成：成功复制到任意一个从库就返回，只要有一个从库还活着，就不会影响主库写入数据，这样就解决了从库宕机阻塞主库的问题。如果主库发生宕机，在两个从库中，至少有一个从库中的数据是和主库完全一样的，可以把这个库作为新的主库，继续提供服务。为此你需要付出的代价是，你要至少用三台数据库服务器，并且这三台服务器提供的服务性能，还不如一台服务器高。</p><p>我把上面这三种典型的HA方案总结成下面这个表格，便于你对比选择：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage04ac04ff6bce8f5b607950fc469a606433ac.a58be00d.jpg" alt=""/></p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/后端存储实战课/02.创业篇/07#小结"><span class="icon icon-link"></span></a>小结</h2><p>今天这节课讲了两件事儿，一是如何备份和恢复数据库中的数据，确保数据安全；二是如何来实现数据库的高可用，避免宕机停服。</p><p>虽然这是两个不同的问题，但你要知道，解决这两个问题背后的实现原理是一样的。<strong>高可用依赖的是数据复制，数据复制的本质就是从一个库备份数据，然后恢复到另外一个库中去。</strong></p><p>数据备份时，使用低频度的全量备份配合Binlog增量备份是一种常用而且非常实用的方法，使用这种备份方法，我们可以把数据库的数据精确地恢复到历史上任意一个时刻，不仅能解决数据损坏的问题，也不用怕误操作、删库跑路这些事儿了。特别要注意的是，让备份数据尽量地远离数据库。</p><p>我们今天讲到的几种MySQL典型的HA方案，在数据可靠性、数据库可用性、性能和成本几个方面，各有利弊，你需要根据业务情况，做一个最优的选择，并且为可能存在的风险做好准备。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-backend/后端存储实战课/02.创业篇/07#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>课后也请你在留言区分享一下，你现在负责系统的数据库是如何来实现高可用的，有什么风险和问题，学习了这节课之后，你会如何来改进这个高可用方案？欢迎你在留言区与我讨论。</p><p>感谢阅读，如果你觉得今天的内容对你有帮助，也欢迎把它分享给你的朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/后端存储实战课/02.创业篇/07.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
