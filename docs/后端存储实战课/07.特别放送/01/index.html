<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>特别放送 | 如何平衡存储系统的一致性和可用性？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/后端存储实战课/07.特别放送/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a aria-current="page" class="active" href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a aria-current="page" class="active" href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端存储实战课/01.课前必读">01.课前必读</a><ul><li><a href="/blog-backend/后端存储实战课/01.课前必读/01"><span>开篇词 | 从今天起，换种方式学存储</span></a></li><li><a href="/blog-backend/后端存储实战课/01.课前必读/02"><span>课前加餐 | 电商系统是如何设计的？</span></a></li></ul></li><li><a href="/blog-backend/后端存储实战课/02.创业篇">02.创业篇</a><ul><li><a href="/blog-backend/后端存储实战课/02.创业篇/01"><span>01 | 创建和更新订单时，如何保证数据准确无误？</span></a></li><li><a href="/blog-backend/后端存储实战课/02.创业篇/02"><span>02 | 流量大、数据多的商品详情页系统该如何设计？</span></a></li><li><a href="/blog-backend/后端存储实战课/02.创业篇/03"><span>03 | 复杂而又重要的购物车系统，应该如何设计？</span></a></li><li><a href="/blog-backend/后端存储实战课/02.创业篇/04"><span>04 | 事务：账户余额总是对不上账，怎么办？</span></a></li><li><a href="/blog-backend/后端存储实战课/02.创业篇/05"><span>05 | 分布式事务：如何保证多个系统间的数据是一致的？</span></a></li><li><a href="/blog-backend/后端存储实战课/02.创业篇/06"><span>06 | 如何用Elasticsearch构建商品搜索系统？</span></a></li><li><a href="/blog-backend/后端存储实战课/02.创业篇/07"><span>07｜MySQL HA：如何将“删库跑路”的损失降到最低？</span></a></li></ul></li><li><a href="/blog-backend/后端存储实战课/03.高速增长篇">03.高速增长篇</a><ul><li><a href="/blog-backend/后端存储实战课/03.高速增长篇/01"><span>08 | 一个几乎每个系统必踩的坑儿：访问数据库超时</span></a></li><li><a href="/blog-backend/后端存储实战课/03.高速增长篇/02"><span>09 | 怎么能避免写出慢SQL？</span></a></li><li><a href="/blog-backend/后端存储实战课/03.高速增长篇/03"><span>10 | 走进黑盒：SQL是如何在数据库中执行的？</span></a></li><li><a href="/blog-backend/后端存储实战课/03.高速增长篇/04"><span>11 | MySQL如何应对高并发（一）：使用缓存保护MySQL</span></a></li><li><a href="/blog-backend/后端存储实战课/03.高速增长篇/05"><span>12 | MySQL如何应对高并发（二）：读写分离</span></a></li><li><a href="/blog-backend/后端存储实战课/03.高速增长篇/06"><span>13 | MySQL主从数据库同步是如何实现的？</span></a></li><li><a href="/blog-backend/后端存储实战课/03.高速增长篇/07"><span>14 | 订单数据越来越多，数据库越来越慢该怎么办？</span></a></li></ul></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇">04.海量数据篇</a><ul><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/01"><span>15 | MySQL存储海量数据的最后一招：分库分表</span></a></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/02"><span>16 | 用Redis构建缓存集群的最佳实践有哪些？</span></a></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/03"><span>17 | 大厂都是怎么做MySQL to Redis同步的?</span></a></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/04"><span>18 | 分布式存储：你知道对象存储是如何保存图片文件的吗？</span></a></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/05"><span>19 | 跨系统实时同步数据，分布式事务是唯一的解决方案吗？</span></a></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/06"><span>20 | 如何在不停机的情况下，安全地更换数据库？</span></a></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/07"><span>21 | 类似“点击流”这样的海量数据应该如何存储？</span></a></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/08"><span>22 | 面对海量数据，如何才能查得更快?</span></a></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/09"><span>23 | MySQL经常遇到的高可用、分片问题，NewSQL是如何解决的？</span></a></li><li><a href="/blog-backend/后端存储实战课/04.海量数据篇/10"><span>24 | RocksDB：不丢数据的高性能KV存储</span></a></li></ul></li><li><a href="/blog-backend/后端存储实战课/05.结课测试">05.结课测试</a><ul><li><a href="/blog-backend/后端存储实战课/05.结课测试/01"><span>结课测试 | 后端存储，100分试卷等你来挑战</span></a></li></ul></li><li><a href="/blog-backend/后端存储实战课/06.结束语">06.结束语</a><ul><li><a href="/blog-backend/后端存储实战课/06.结束语/01"><span>结束语 | 把奋斗当习惯</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/后端存储实战课/07.特别放送">07.特别放送</a><ul><li><a aria-current="page" class="active" href="/blog-backend/后端存储实战课/07.特别放送/01"><span>特别放送 | 如何平衡存储系统的一致性和可用性？</span></a></li><li><a href="/blog-backend/后端存储实战课/07.特别放送/02"><span>特别放送 | 和你分享一个好消息：这门课被出版了一本书</span></a></li></ul></li><li><a href="/blog-backend/后端存储实战课/summary">后端存储实战课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="如无必要，勿增副本" data-depth="2"><a href="/blog-backend/后端存储实战课/07.特别放送/01#如无必要勿增副本"><span>如无必要，勿增副本</span></a></li><li title="一致性与可用性的矛盾" data-depth="2"><a href="/blog-backend/后端存储实战课/07.特别放送/01#一致性与可用性的矛盾"><span>一致性与可用性的矛盾</span></a></li><li title="在一致性与可用性之间保持平衡" data-depth="2"><a href="/blog-backend/后端存储实战课/07.特别放送/01#在一致性与可用性之间保持平衡"><span>在一致性与可用性之间保持平衡</span></a></li><li title="小结" data-depth="2"><a href="/blog-backend/后端存储实战课/07.特别放送/01#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-backend/后端存储实战课/07.特别放送/01#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="特别放送--如何平衡存储系统的一致性和可用性"><a aria-hidden="true" tabindex="-1" href="/blog-backend/后端存储实战课/07.特别放送/01#特别放送--如何平衡存储系统的一致性和可用性"><span class="icon icon-link"></span></a>特别放送 | 如何平衡存储系统的一致性和可用性？</h1><p>你好，我是李玥。</p><p>非常开心在结课近两年后的今天，我又有机会和你分享这段时间，我对存储技术一点新的思考。</p><p>最近我的工作重心有了一些变化，更加关注高可用架构在大规模系统落地工程实践方法。在存储技术领域，对平衡存储系统的一致性和可用性的设计方法，也有了一些新的认知，在这里分享给你。</p><p>**无论技术如何发展，保证系统高可用最基础也是最本质的方法从没有改变过。相信你已经猜到这种方法是什么了，是的，就是冗余。**简单地说，冗余就是为你的系统准备多个副本，或者说是多个实例，它们提供同样的服务，共同工作。这样即使其中一个副本或者实例出现了故障，其它的实例仍然可以替这个故障实例承担工作，保证你的系统持续可用。</p><p>对于数据库、KV存储等存储系统来说，同样是通过冗余，或者说多副本的方法来实现其高可用架构的。但相比于无状态的系统，有状态的存储系统使用这种冗余的方法时，需要额外维护多个副本上的数据一致性。<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/215383">第13讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中，我们讲的MySQL主从同步，以及在这一讲末尾给你总结的复制状态机理论，就是MySQL维护主库和从库数据一致性的方法。</p><p>在分布式存储系统中，让系统中多个实例的状态保持一致，是一个比较难处理的问题。尤其是当系统出现故障时，系统能否始终保持一致性，很大程度上影响了系统的可用性和数据的可靠性。</p><p>典型的由不一致导致的重大事故是这样的：正常情况下，系统通过某种数据同步机制保持各实例上状态的一致性，当发生实例宕机、网络分区等故障时，这种同步机制无法正常工作，一致性被打破。</p><p>这种情况下，出现了多份不一致的状态数据，系统很难自动去判断到底哪份状态数据才是“正确的”，也就没有办法自动恢复。更糟糕的是，一旦这种不一致的状态被其它系统读取，错误的状态将被传递到其它系统中，造成不可预期的结果。这种复杂的数据错误，即使人工处理也是非常难恢复，往往恢复时间需要几小时或几天，严重情况下甚至于无法恢复。</p><p>可以看出，在故障情况下仍然保持一致性，是系统能快速从故障中恢复的前提条件，有助于提升系统的可用性。但为了保证一致性，在数据更新时，往往需要协调参与的各个模块，确保它们同步更新。比如，使用各种分布式事务。但这会导致这些模块在可用性上紧密耦合在一起，反而降低了系统的可用性。这种场景下，可用性和一致性又存在矛盾。</p><p>接下来我将和你一起，从高可用视角来重新审视数据一致性问题，讨论如何在可用性和一致性上取得相对的平衡。</p><h2 id="如无必要勿增副本"><a aria-hidden="true" tabindex="-1" href="/blog-backend/后端存储实战课/07.特别放送/01#如无必要勿增副本"><span class="icon icon-link"></span></a>如无必要，勿增副本</h2><p>在考虑如何平衡一致性与可用性之前，最重要的是要意识到，在分布式系统中解决一致性问题需要付出非常大的代价，这些代价可能包括：可用性降低、性能下降、用户体验变差或者是极大的增加了系统的复杂度。</p><p>因此，不要人为制造一致性难题。但是，很多情况下，因为缺少这方面的意识，我们无意间为系统制造了本无必要的一致性难题，然后又付出了巨大的代价去解决这个难题，得不偿失。</p><p>为系统中的状态数据设计多个副本的情况并不罕见，常见的多副本设计包括：</p><ul><li>以不同格式或数据结构存储多个副本。</li><li>在不同类型的外部存储中存储多个副本。</li><li>在本地磁盘或内存中缓存数据的副本。<br/>以上这些都是我们时常会用到的设计模式，难道说它们都是“不好的设计”么？</li></ul><p>当然不是这样的。</p><p>架构设计是平衡的艺术，当架构师选择某种设计或架构时，一定要充分了解当前选择的优势和代价，确保优点是我们所需要的，代价是我们能接受的。这样的设计才是在当前场景下最优的选择。</p><p>为数据增加副本会带来一致性难题，开发者需要为此付出巨大的代价去维护数据一致性。所以，在设计过程中需要慎重考虑，为系统增加副本所带来的收益和付出的代价，二者相比是不是值得做出这样的选择。</p><p><strong>我们需要避免的是，在设计过程中未经仔细思考随意增加副本的行为。</strong></p><p>这里，我和你分享几个常见的错误示例：</p><ul><li>仅仅是为了写代码的时候更方便地读取数据，就随意增加副本。比如，为了便于查询，将数据库中A表中的部分字段，在B表中也保存一份。</li><li>系统中存在多个外部存储，为了读写方便，在每个外部存储都保存一份数据副本。比如，集群的元数据保存在ZooKeeper中，为了方便管理控制台操作，也在MySQL中保存一份同样的数据。</li><li>不考虑系统的性能实际要求，为了让系统速度更快一些，在Redis和内存中缓存数据。</li></ul><h2 id="一致性与可用性的矛盾"><a aria-hidden="true" tabindex="-1" href="/blog-backend/后端存储实战课/07.特别放送/01#一致性与可用性的矛盾"><span class="icon icon-link"></span></a>一致性与可用性的矛盾</h2><p>在现有硬件技术条件下，对分布式系统中每个节点更新操作，总会有先后，不可能做到绝对的“同时”，也就无法保证系统的多个副本在“任何时刻”状态都相同。</p><p>因此，<strong>这里我们讨论的一致性是，系统作为一个整体对外部所表现出的一致性</strong>。换句话说就是，分布式系统内部可以存在不一致的状态，但只要这种不一致的状态对外部是不可见的，那就可以认为这个系统具备一致性。</p><p>在分布式系统中，既要保证高可用又要保证一致性是几乎不可能实现的。我们把分布式系统抽象成最简单的模型：一个只有两个有状态节点系统。然后在这个最简模型下来分析一致性问题：如何保证这两个节点上的状态，在任何时刻都是相同的？</p><p>即使在这样一个最简模型下，<strong>保持一致性仍然面临下面的3个难题</strong>。</p><p><strong>第一个难题是，如何处理更新操作失败的情况</strong>。</p><p>要保持两个节点上状态的一致性，理论上需要每次更新状态时同步更新两个节点上的状态。如果某一个节点上的更新操作失败了，系统将变成如下不一致的状态：一个节点更新成功，而另外一个节点更新失败。在这种情况下，还要保持系统的一致性，就需要将这种不一致状态隔离在系统内部，不能让外部系统感知，并且尽快修复不一致的状态。</p><p>要修复这种不一致状态，一般有两种方法，分别是重试和回滚。</p><ul><li>重试指的是，让失败的节点重新执行更新操作。如果重试成功，系统将重新回到一致的状态。</li><li>回滚指的是，让之前更新成功的节点执行回滚操作，回到更新前的状态，也可以让系统重新回到一致状态。<br/>但重试和回滚的实现代价都很大。</li></ul><p>通过重试来解决一致性的前提是，被重试的更新操作必须具备幂等性和原子性。幂等性，可以保证多次重试同一个更新操作不会改变状态的正确性；原子性，则可以避免在更新具有复杂数据结构的状态失败时，只更新了部分状态的尴尬局面。如果系统的状态不是保存在关系型数据库中，要实现幂等性和原子性其实很不容易。</p><p>实现回滚同样要保证原子性，此外为了能将状态恢复到更新之前，需要在执行更新操作之前记录原始状态，系统还要考虑如何处理回滚失败的问题。</p><p><strong>第二个难题是，如何在其中一个节点不可用的情况下保证系统一致性。</strong></p><p>当系统其中的一个节点不可用时，另外一个节点仍然可以提供读写服务。当故障节点恢复后，理论上只要把状态数据从可用节点同步到之前故障的节点上，系统就可以重新回到一致性状态了。而在现实中实现好数据同步，既要做到快速同步，又要保证不重不漏，难度和代价都比较大。</p><p>最简单的方法是全量数据同步，清空故障节点上的状态数据，然后将可用节点上的状态数据全部复制到故障节点上。全量同步相对比较耗时，如果数据量比较大，就必须采用增量同步的方法。</p><p>而增量同步，则需要精准地界定出哪些数据属于“增量数据”。这对于大多数采用多线程并行处理请求的服务来说，几乎不可能实现。同时，另一个不得不考虑的极端情况是，如果在一段时间内两个节点交替多次出现不可用的情况，系统将很难判定哪个节点上的状态才是“正确可信的状态”，也就无法恢复系统的一致性状态。</p><p><strong>第三个难题是，如何在网络分区情况下保证系统的一致性。</strong></p><p>网络分区，指的是由于网络设备故障，造成网络分裂为多个独立的区域。典型场景是两个机房间的网络中断，这两个机房就形成了两个互不联通的分区。</p><p>假设发生了网络分区，系统的两个节点恰巧分别位于不同分区，这种情况下，虽然没有节点不可用，但节点间无法通信，也就无法保证系统一致性。如果系统不能容忍“不一致”，唯一的办法就是在网络分区期间停止对外提供服务，也就是说需要牺牲“可用性”。</p><p>上面我们讨论的情况，就是著名的CAP理论的一种典型场景：在网络分区的情况下，一致性和可用性只能二选其一。</p><p>鉴于一致性与可用性存在冲突，以及实现一致性的代价过高这两个原因，在设计分布式系统时，<strong>放弃对严格一致性的约束，让系统去适应相对宽松一致性，从而在一致性、可用性和性能上取得相对可接受的平衡，是更加理性的选择。</strong></p><p>所谓“宽松一致”，是在隔离性和性能等方面适当放宽要求后的一系列降级版一致性。相对的，我们之前讨论的一致性，也被称为“强一致”。最终一致是普遍采用的一种宽松一致。</p><p>比如上面的例子，在网络分区的情况下，如果可以接受最终一致，则系统仍然可以在其中的一个分区提供提供读写服务，另一个分区提供只读服务，极大增强系统的可用性。只要待网络故障结束后，再通过单向数据同步即可恢复系统一致性。</p><h2 id="在一致性与可用性之间保持平衡"><a aria-hidden="true" tabindex="-1" href="/blog-backend/后端存储实战课/07.特别放送/01#在一致性与可用性之间保持平衡"><span class="icon icon-link"></span></a>在一致性与可用性之间保持平衡</h2><p>牺牲强一致后，当系统故障时，由于系统存在多个副本，就比较容易继续维持可用性。无论是发生网络故障还是服务器宕机，只要调用端还能访问某个存活的副本，系统仍然可以提供服务。</p><p>BASE给出了一种平衡一致性和可用性的策略，这种策略适用范围广泛，实现难度不大，在一致性和可用性上都有不错的表现。BASE是“<strong>基本可用（Basically Available）</strong>”“<strong>软状态（Soft State）</strong>”和“<strong>最终一致（Eventually Consistent）</strong>”这三个词的缩写。</p><p>其中：</p><ul><li>基本可用是对可用性的妥协，指的是在故障时，系统以响应时间变长、部分功能不可用或者部分请求失败为代价，换取整个系统仍然可以提供基本的服务能力。</li><li>软状态和最终一致则是对一致性的妥协。具体地说，就是牺牲了原子性和隔离性，允许系统内出现外部可见的“中间状态”，但需要在短时间内恢复为一致状态，达成最终一致。<br/>在多个组件构成的分布式系统中，如果某个组件在设计上降低了可用性和一致性的等级，依赖这个组件的其它组件或外部服务为了能够兼容这种降级设计，往往需要付出额外的代价。因此，<strong>设计者需要针对系统的实际情况来权衡决策，谨慎降级可用性和一致性。基本可用不等于不可用，最终一致也不等于不一致。</strong></li></ul><p>接下来，我将和你介绍实践BASE理论的常用方法和常见误区。</p><p>“最终一致”允许不一致的中间状态被外部可见，但需要在短时间内恢复为一致状态。这里面的“短时间”能否量化呢？</p><p>要回答这个问题，我们需要分系统正常和故障二种情况来分别讨论。</p><p>在系统正常时，<strong>达成最终一致的时间要求是“在系统外部几乎不可感知”</strong>，具体来说应该与需要同步状态的节点之间的网络时延差不多。比如，如果系统的节点都部署在同一个数据中心内，达成最终一致的时延不应超过几个毫秒；对于一个全球部署的系统，达成最终一致的时延可能需要几十至几百毫秒。在系统发生网络分区故障时，为了尽可能保证系统的可用性，需要进一步牺牲达成最终一致的时延，最长可能需要等到故障恢复后系统才能达成最终一致。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimagea7c6a7f3bef2b2b65cbb647cae1d8fb419c6.f1ae35f0.png" alt="图片"/></p><p>图1 系统故障时需要更长的时间达成最终一致</p><p><strong>牺牲一致性需要守住两个底线：防止脑裂和要保证单调读写。</strong></p><p>我们首先来讨论底线一：防止脑裂。</p><p>例如，传统MySQL主从结构中，如果主库宕机，或者网络分区导致无法访问主库，也不应该去更新从库中的数据，否则在故障结束后，系统面对主库和从库二份不一样的数据，是无法自动恢复的。这种情况被称为“脑裂（Split-brain）”，出现脑裂后，理论上系统的一致性不可恢复。</p><p>工程实践中，一般都需要人工介入，借助数据的业务属性（比如，同一订单支付操作一定早于发货操作，则可以判断“已发货”状态是比“已支付”更新的状态），才有可能完成数据的一致性修复。</p><p>特别注意的是，<strong>不应该以状态更新的时间戳来判断状态数据的新旧并用于恢复一致性</strong>。状态数据中记录的时间戳来自客户端或服务端应用所在的多个节点，而现有的时间同步技术所能保证的误差（10~500ms）过大，所以用时间戳来判断状态新旧极其不可靠。人工恢复脑裂的代价往往是“部分数据丢失”和“更长的故障恢复时长”。</p><p>那么，如何防止脑裂呢？</p><p>在我看来，关键是确保故障后能够恢复最终一致。其前提则是，系统需要具备足够的信息，以判断出最新的状态。然后才能将所有副本的状态都恢复至这一状态。在系统故障时，即使为了保证可用性，也不应该违反更新操作的一致性约束。</p><p>这里，“更新操作的一致性约束”指的是，系统为了保证一致性，而对状态更新操作施加的约束条件。比如，最简单的主从模式下，只能通过主副本更新状态，无论任何原因无法更新主副本，那就要让本次更新失败，牺牲更新操作的可用性。</p><p>Paxos等一致性协议，采用了多数派（Quorum）机制保证更新操作的一致性。简单地说，就是每次更新操作必须在超过半数的副本上达成一致才算更新成功，如果在系统故障时，更新请求不能达成多数派一致，也必须让本次更新失败。</p><p>接下来，我们讨论单调读写。</p><p>最终一致系统在故障时，为了保证系统持续可用，应允许客户端从任意一个尚可访问的节点上读取状态数据。尽管这个时候，客户端读到的可能并非最新状态。对于绝大多数系统来说，短时间内读到一个并非最新状态都是可接受的。</p><p>先来看第一个例子。小明用手机银行给小华转了100元，当小明完成了转账操作后，实际上这笔钱已经转入到小华的账户。如果这个时候因为系统故障，小华的手机银行上显示尚未到账，然后过了一段时间之后才显示到账，也并非是完全不可接受。</p><p>然后我们再来看第二个例子，同样还是以小明给小华转账来说明。如图二所示，在一个只有主从二副本的最终一致性系统中，转账成功后主副本的状态已更新，小明转给小华的钱已到账，小华的账户余额是100元。但由于同步延迟，从副本中转账还未到账，小华的账户余额还是0元。</p><p>假设小华第一次查询账户的请求被分配到主副本上，App显示余额100元。小华再次查询，这次查询请求被分配到了从副本上，App显示余额0元！刚到账的钱没了！对小明来说也可能出现类似的问题，转账成功后再查询账户，如果这个查询请求被分配到了从副本上（这在配置了读写分离的数据库集群上是默认的行为），发现账户余额并没有减少，小明以为转账没成功，再次发起了转账，结果多转了100元。</p><p>以上这两种情况，对外部系统来说无法判断读到的状态是否准确，显然是不可接受的。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage33a833045711c9bc1c36b498ae3bb9b0eaa8.53f69c92.png" alt="图片"/></p><p>图2 状态时序错乱问题</p><p>要避免这两个问题，就需要保证在客户端视角的一致性。所谓单调读写，要求对每一个客户端来说，每次读到的状态不能比上次一读写到的状态更旧。简单的说就是“<strong>不能时序错乱</strong>”。实现单调读写有两种常用的方法。</p><p><strong>第一种方法是通过保持会话（Sticky Session）的方式</strong>，让同一个客户端的请求总是由与之建立会话的那个特定的服务端节点（副本）处理。客户端只与服务端一个节点交互，自然就不会出现“时序错乱”的问题。</p><p>保持会话的方式实现比较简单，很多网关都内置了保持会话的功能。如果系统是通过网关对外提供服务，则可以直接使用。即使系统没有使用网关，只要在客户端首次连接成功时，返回服务端节点的唯一标识（ID）或URL给客户端，后续客户端就可以用这个ID或URL继续访问同一个服务端节点了。</p><p>但保持会话这种实现方式的问题是，在系统故障时需要降级。如果客户端连不上会话中的那个服务端节点，只能选择去连接其它服务端节点创建新的会话。这个会话切换的过程中，仍然存在时序错乱的可能性。</p><p>幸运的是时序错乱只可能发生在会话切换过程中，而会话切换只在系统故障时才发生，发生概率很低。而且，客户端是可以感知到会话切换，从而主动从业务逻辑上做一些补偿。此外，因为需要维持会话，无法使用负载均衡策略，系统的弹性（Elasticity）将受到很大的限制，容易出现热点问题，并且扩缩容也会受到会话的限制。</p><p><strong>另一种方法是，通过记录和比较状态的版本号来实现单调读写</strong>。</p><p>系统需要为状态数据维护一个版本号系统，状态版本号是状态的一部分，并且要确保每次状态更新，对应版本号都单调递增。这个状态版本号的目的是，标记状态更新的先后顺序，在英文中也称为Ephoc或者Logical timestamps。</p><p>客户端需要记录上一次读写状态的版本号，然后在每一次读取状态之前比对本次版本号和上次版本号，如果本次版本号不小于上次版本号，就可以认为本次读取的状态是可信的。否则，需要丢弃本次读取结果，等待一会儿或者连接其它服务端重试，以获取新版本的状态数据。通过状态版本号的方式实现单调读写，可以完美地保证客户端视角的一致性，但服务端的实现则更加复杂。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/后端存储实战课/07.特别放送/01#小结"><span class="icon icon-link"></span></a>小结</h2><p>今天这节课的分享就到这里了，我们来回顾下核心内容。</p><p>在分布式系统中，平衡可用性和一致性是一个难题，因此在设计过程中，需要避免未经仔细思考而随意增加副本的行为。</p><p>我们推荐设计者在设计系统一致性时能够兼容最终一致，这样可以极大提升系统在面临故障时保持高可用的难度，在一致性和可用性上取得相对较好的平衡。但系统最终一致也不等于不一致，需要防止系统出现脑裂，并通过单调读写保证客户端视角的一致性。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-backend/后端存储实战课/07.特别放送/01#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>有些系统为了保证最终一致性，会在系统外增加一层防御性设计。定期比对各副本状态数据的一致性，用于自动发现和修复状态数据不一致的问题。</p><p>请你思考一下这种防御性的设计，是必要的么？</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/后端存储实战课/07.特别放送/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
