<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>34｜快速分配和释放内存：内存池 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/现代c编程实战/10.增补篇/05" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/现代c编程实战/01.课前必读">01.课前必读</a><ul><li><a href="/blog-backend/现代c编程实战/01.课前必读/01"><span>开篇词 | C加加这么难，为什么我们还要用C加加？</span></a></li><li><a href="/blog-backend/现代c编程实战/01.课前必读/02"><span>课前必读 | 有关术语发音及环境要求</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/02.基础篇">02.基础篇</a><ul><li><a href="/blog-backend/现代c编程实战/02.基础篇/01"><span>01 | 堆、栈、RAII：C加加里该如何管理资源？</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/02"><span>02 | 自己动手，实现C加加的智能指针</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/03"><span>03 | 右值和移动究竟解决了什么问题？</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/04"><span>04 | 容器汇编 I：比较简单的若干容器</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/05"><span>05 | 容器汇编 II：需要函数对象的容器</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/06"><span>06 | 异常：用还是不用，这是个问题</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/07"><span>07 | 迭代器和好用的新for循环</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/08"><span>08 | 易用性改进 I：自动类型推断和初始化</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/09"><span>09 | 易用性改进 II：字面量、静态断言和成员函数说明符</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/03.提高篇">03.提高篇</a><ul><li><a href="/blog-backend/现代c编程实战/03.提高篇/01"><span>10 | 到底应不应该返回对象？</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/02"><span>11 | Unicode：进入多文字支持的世界</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/03"><span>12 | 编译期多态：泛型编程和模板入门</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/04"><span>13 | 编译期能做些什么？一个完整的计算世界</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/05"><span>14 | SFINAE：不是错误的替换失败是怎么回事?</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/06"><span>15 | constexpr：一个常态的世界</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/07"><span>16 | 函数对象和lambda：进入函数式编程</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/08"><span>17 | 函数式编程：一种越来越流行的编程范式</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/09"><span>18 | 应用可变模板和tuple的编译期技巧</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/10"><span>19 | thread和future：领略异步中的未来</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/11"><span>20 | 内存模型和atomic：理解并发的复杂性</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/04.实战篇">04.实战篇</a><ul><li><a href="/blog-backend/现代c编程实战/04.实战篇/01"><span>21 | 工具漫谈：编译、格式化、代码检查、排错各显身手</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/02"><span>22 | 处理数据类型变化和错误：optional、variant、expected和Herbception</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/03"><span>23 | 数字计算：介绍线性代数和数值计算库</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/04"><span>24 | Boost：你需要的“瑞士军刀”</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/05"><span>25 | 两个单元测试库：C加加里如何进行单元测试?</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/06"><span>26 | Easylogging++和spdlog：两个好用的日志库</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/07"><span>27 | C加加 REST SDK：使用现代C开发网络应用</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/05.新年特别策划">05.新年特别策划</a><ul><li><a href="/blog-backend/现代c编程实战/05.新年特别策划/01"><span>新春寄语 | 35年码龄程序员：人生漫长，走点弯路在所难免</span></a></li><li><a href="/blog-backend/现代c编程实战/05.新年特别策划/02"><span>新春福利 | C加加好书荐读</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/06.未来篇">06.未来篇</a><ul><li><a href="/blog-backend/现代c编程实战/06.未来篇/01"><span>28 | Concepts：如何对模板进行约束?</span></a></li><li><a href="/blog-backend/现代c编程实战/06.未来篇/02"><span>29 | Ranges：无迭代器的迭代和更方便的组合</span></a></li><li><a href="/blog-backend/现代c编程实战/06.未来篇/03"><span>30 | Coroutines：协作式的交叉调度执行</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/07.加餐">07.加餐</a><ul><li><a href="/blog-backend/现代c编程实战/07.加餐/01"><span>加餐 | 部分课后思考题答案合集</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/08.结束语">08.结束语</a><ul><li><a href="/blog-backend/现代c编程实战/08.结束语/01"><span>结束语 | 终点已达，行程还要继续</span></a></li><li><a href="/blog-backend/现代c编程实战/08.结束语/02"><span>结课问卷获奖用户名单</span></a></li><li><a href="/blog-backend/现代c编程实战/08.结束语/03"><span>第二季回归｜拿下Vim，让编程效率神器为我所用</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/09.期末测试">09.期末测试</a><ul><li><a href="/blog-backend/现代c编程实战/09.期末测试/01"><span>期末测试 | 对于现代C，你掌握了多少呢？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战/10.增补篇">10.增补篇</a><ul><li><a href="/blog-backend/现代c编程实战/10.增补篇/01"><span>旅程再启｜那些关于C加加的新认知</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/02"><span>31｜new和delete背后：分配函数和释放函数</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/03"><span>32｜容器里的内存管理：分配器</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/04"><span>33｜性能测试的正确姿势：性能、时间和优化</span></a></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战/10.增补篇/05"><span>34｜快速分配和释放内存：内存池</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/06"><span>35 | 发现和识别内存问题：内存调试实践</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/07"><span>36｜访问对象的代理对象：视图类型</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/summary">现代c编程实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="一个测试用例" data-depth="2"><a href="/blog-backend/现代c编程实战/10.增补篇/05#一个测试用例"><span>一个测试用例</span></a></li><li title="PMR 内存池" data-depth="2"><a href="/blog-backend/现代c编程实战/10.增补篇/05#pmr-内存池"><span>PMR 内存池</span></a></li><li title="自定义内存池" data-depth="2"><a href="/blog-backend/现代c编程实战/10.增补篇/05#自定义内存池"><span>自定义内存池</span></a></li><li title="基本策略" data-depth="3"><a href="/blog-backend/现代c编程实战/10.增补篇/05#基本策略"><span>基本策略</span></a></li><li title="对象内存池" data-depth="3"><a href="/blog-backend/现代c编程实战/10.增补篇/05#对象内存池"><span>对象内存池</span></a></li><li title="内存池应用：类特定的分配和释放函数" data-depth="3"><a href="/blog-backend/现代c编程实战/10.增补篇/05#内存池应用类特定的分配和释放函数"><span>内存池应用：类特定的分配和释放函数</span></a></li><li title="内存池应用：分配器" data-depth="3"><a href="/blog-backend/现代c编程实战/10.增补篇/05#内存池应用分配器"><span>内存池应用：分配器</span></a></li><li title="生命周期陷阱" data-depth="3"><a href="/blog-backend/现代c编程实战/10.增补篇/05#生命周期陷阱"><span>生命周期陷阱</span></a></li><li title="内容小结" data-depth="2"><a href="/blog-backend/现代c编程实战/10.增补篇/05#内容小结"><span>内容小结</span></a></li><li title="课后思考" data-depth="2"><a href="/blog-backend/现代c编程实战/10.增补篇/05#课后思考"><span>课后思考</span></a></li><li title="参考资料" data-depth="2"><a href="/blog-backend/现代c编程实战/10.增补篇/05#参考资料"><span>参考资料</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="34快速分配和释放内存内存池"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/05#34快速分配和释放内存内存池"><span class="icon icon-link"></span></a>34｜快速分配和释放内存：内存池</h1><p>你好，我是吴咏炜。</p><p>在上一讲讲过了性能测试之后，我们终于可以回到内存池这个话题，来深入讨论一下了。</p><h2 id="一个测试用例"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/05#一个测试用例"><span class="icon icon-link"></span></a>一个测试用例</h2><p>如果你想用内存池，那我的第一个问题就是，你到底是不是需要使用内存池？</p><p>下面是一些你可能想使用内存池的理由：</p><ul><li>希望减少内存分配和释放的时间开销——更快的分配和释放</li><li>希望减少内存分配和释放的空间开销——更少的总体内存使用</li></ul><p>下面则是一些反对使用内存池的理由：</p><ul><li>你的通用内存分配器可能已经足够快了</li><li>使用内存池可能导致操作系统更难回收你已经不再需要的内存</li><li>使用内存池可能使得你的对象较难跟其他对象进行交互（参考<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/491227">第 32 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，在 PMR 之前分配器是容器类型的一部分）</li></ul><p>当然，既然你看到这里了，你肯定是想要使用内存池的。不过，我们需要能够衡量使用内存池的效果，所以我们需要进行测试。</p><p>如果你想要进行某个操作的性能测试，你就需要某种“典型场景”。作为例子，我这儿拿一个掺入了随机操作的过程当作测试场景。具体来说，我做的事情是：</p><ol><li>产生随机数</li><li>把这些随机数插入到一个 <code>unordered_set</code> 中，测量所需的时间</li><li>把这些随机数从这个 <code>unordered_set</code> 里逐个删除，测量所需的时间</li><li>再把这些随机数重新插入到 <code>unordered_set</code> 中，测量所需的时间</li></ol><p>这虽然不是一个完美的例子，但确实可以让我们观察到内存池的作用。如果你有真实的场景，也可以借鉴这种方式来进行测试。</p><p>我们的待测对象和类型非常简单：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">using TestType = unordered_set&lt;int&gt;;</span></div><div class="token-line"><span class="token plain">    TestType s;</span></div></pre></div><p>产生随机数的代码略复杂一点点：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">mt19937 engine;</span></div><div class="token-line"><span class="token plain">    uniform_int_distribution&lt;int&gt; dist;</span></div><div class="token-line"><span class="token plain">    array&lt;int, LEN&gt; rand_nums{};</span></div><div class="token-line"><span class="token plain">    for (int&amp; num : rand_nums) {</span></div><div class="token-line"><span class="token plain">      num = dist(engine);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们希望得到跨平台的稳定测试结果，因此指定了一个名声不错的伪随机数引擎 <code>mt19937</code>（否则默认的伪随机数引擎 <code>default_random_engine</code> 也没什么问题）。我们只需要一个简单的随机均匀分布，因而使用了默认构造的 <code>uniform_int_distribution</code>，不给出随机数的范围，来产生所有合法整数范围内的随机数。然后，我们在长度为 <code>LEN</code> 的数组中，每一项（注意此处必须使用引用的方式来范围遍历 <code>rand_nums</code>）都写入一个随机的整数。由于我们没有对随机数引擎使用真正随机的种子来初始化，这些随机数每次都是相同的，可以保证测试的稳定性。</p><p>初始插入操作就简单了，只是把数组 <code>rand_nums</code> 里的每一项插入到 <code>s</code> 里。由于 <code>s</code> 这个变量的操作实在有点复杂，不管它是全局变量还是本地变量，编译器都不太可能把这些操作优化掉了。我们这个测试可以简单地测量总体耗时：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">t1 = rdtsc();</span></div><div class="token-line"><span class="token plain">    for (int num : rand_nums) {</span></div><div class="token-line"><span class="token plain">      s.insert(num);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    t2 = rdtsc();</span></div></pre></div><p>删除操作也差不多，我们仍然使用 <code>rand_nums</code> 来删除 <code>s</code> 中的每一项：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">t1 = rdtsc();</span></div><div class="token-line"><span class="token plain">    for (int num : rand_nums) {</span></div><div class="token-line"><span class="token plain">      s.erase(num);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    t2 = rdtsc();</span></div></pre></div><p>最后，我们再重复一遍插入的过程，看看重新插入的性能有没有变化。完整的测试代码可以看一下<a target="_blank" rel="noopener noreferrer" href="https://github.com/adah1972/geek_time_cpp">代码库<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>下面是某硬件环境下的初步测试结果。</p><p>Apple Clang 12.0，macOS Catalina 10.15：</p><blockquote><p><code>It took 449 cycles by average to insert a number</code><br/><code>It took 492 cycles by average to erase a number</code><br/><code>It took 305 cycles by average to insert a number again</code></p></blockquote><p>MSVC 19.29，Windows 10：</p><blockquote><p><code>It took 366 cycles by average to insert a number</code><br/><code>It took 185 cycles by average to erase a number</code><br/><code>It took 300 cycles by average to insert a number again</code></p></blockquote><p>GCC 10.3，Ubuntu Linux 20.04 LTS：</p><blockquote><p><code>It took 307 cycles by average to insert a number</code><br/><code>It took 162 cycles by average to erase a number</code><br/><code>It took 176 cycles by average to insert a number again</code></p></blockquote><p>可以看到，使用不同的平台和编译器，结果差异比较大。但我们确实可以看到，再次插入的性能比第一次要高，在 Linux 上尤其明显。</p><p>事实上，这还只是使用默认的内存分配器的结果。使用不同的内存分配器也能获得不同的效果。比如，在 Linux 上使用 tcmalloc [1] 来取代默认的分配器 [2]，我们可以得到更好的测试结果：</p><blockquote><p><code>It took 250 cycles by average to insert a number</code><br/><code>It took 116 cycles by average to erase a number</code><br/><code>It took 117 cycles by average to insert a number again</code></p></blockquote><p>取决于你使用的平台的内存分配器的性能，也取决于你是否需要跨平台地得到更好的内存分配性能，内存池也许对你很有用，也许对你用处不大。目前，我就假设内存池会对你有用吧（既然你已经读到这里了😁）。</p><h2 id="pmr-内存池"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/05#pmr-内存池"><span class="icon icon-link"></span></a>PMR 内存池</h2><p>有了测试用例之后，我们可以验证一下多态分配器（<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/491227">第 32 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）里提供的内存池的作用了。我们只需要对测试用例做一下小修改，把 <code>TestType</code> 相关的两行改成下面这样子就行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">using TestType = pmr::unordered_set&lt;int&gt;;</span></div><div class="token-line"><span class="token plain">    pmr::unsynchronized_pool_resource res;</span></div><div class="token-line"><span class="token plain">    pmr::polymorphic_allocator&lt;int&gt; a{&amp;res};</span></div><div class="token-line"><span class="token plain">    TestType s(a);</span></div></pre></div><p>取决于平台，你可能会看到不同的性能结果。比如，在 Linux 上我得到了下面的测试结果：</p><blockquote><p><code>It took 272 cycles by average to insert a number</code><br/><code>It took 210 cycles by average to erase a number</code><br/><code>It took 169 cycles by average to insert a number again</code></p></blockquote><p>性能数据有得有失。而在 macOS 和 Windows 上，我看到了更大的、全方位的性能提升。对于跨平台的应用，这样的内存池确实会有效果。</p><p>注意，我上面使用的是无多线程同步的 <code>unsynchronized_pool_resource</code>。有多线程同步的内存池就是另外一个故事了。在 Linux 上，性能反而会有下降；而在其他平台上，性能提升也很不明显。——一般而言，对于多线程的处理，通用内存分配器已经做了充足的优化，性能上可能反而会超出一般简单实现的内存池。内存池通常应该在<strong>单线程</strong>或<strong>线程本地</strong>（thread_local）的场景使用，至少从执行时间的角度来讲是如此。</p><h2 id="自定义内存池"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/05#自定义内存池"><span class="icon icon-link"></span></a>自定义内存池</h2><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/489409">第 31 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>我提到过，利用同一类型的对象的大小完全相同这一特性，可以实现一个高度优化的内存池。只是利用类特定的分配和释放函数，使用场景会比较受限。下面我会描述利用这个思路实现的一个内存池，既可以用在类特定的分配和释放函数里，也可以用在容器的分配器里。</p><h3 id="基本策略"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/05#基本策略"><span class="icon icon-link"></span></a>基本策略</h3><p>作为内存池，最基本的要求就是减少向系统的内存分配器请求内存的次数。因此，我们希望单次内存分配就获得大块的内存（chunk），然后分割开给各个对象使用。这样的内存块，通常是某个特定大小的整数倍。</p><p>下一步，我们有两种不同的做法：</p><ol><li>任何要求某个大小（或某个大小范围）的内存分配请求都到某一个内存池里分配和释放</li><li>任何要求某个特定类型的对象的内存分配请求都到某一个内存池里分配和释放</li></ol><p>第一种做法跟 SGI STL 差不多，而第二种做法是 C加加 的内存分配机制给我们的额外优化机会。两种做法各有一些优缺点，而我目前是采取了第二种做法，主要考虑下面这些因素：</p><ul><li>不同类型的对象使用不同的内存池，即使它们的大小相同。在很多场景下，把同一类型的对象放在一起，程序会有更好的局域性。</li><li>通过对象类型可以得出对象大小，但反过来则不可以。换句话说，按我目前的方式，你可以把方案退化成为只使用对象大小，因而讲解目前这种方式更具有通用性。</li></ul><p>我做的另外一个选择是在大部分时间里<strong>不</strong>返回内存给内存分配器。原因是：</p><ul><li>返回内存给内存分配器反而更容易导致内存碎片，导致后续内存不足或消耗更大。</li><li>返回内存给内存分配器，通常内存分配器也没法返回给操作系统（因为内存碎片的原因），因此并不能减少程序的运行期内存开销。</li><li>不返回内存给内存分配器的话，实现简单，代码更小、更快。</li></ul><p>我的一些实验表明，内存池也很难决定什么时候返回内存给内存分配器。如果某个内存块（chunk）全空就返回的话，程序向内存分配器请求内存的次数会明显增加。目前我能想到的唯一好处，是程序的对象数量会有明显的波动的时候：在某个时刻，程序会产生大量的 A 对象，然后释放掉；在另一时刻，又会产生大量的 B 对象，然后释放掉。仅在这种情况下，我的不返回选择会增加程序的最大内存开销。目前我就暂不考虑这种特殊场景了。</p><h3 id="对象内存池"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/05#对象内存池"><span class="icon icon-link"></span></a>对象内存池</h3><p>根据上面的讨论，我们需要有一个内存块的数据结构，也需要决定一个内存块里放多少个对象。我们采用一个可特化的参数来决定后者：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;typename T&gt;</span></div><div class="token-line"><span class="token plain">    inline constexpr size_t</span></div><div class="token-line"><span class="token plain">      memory_chunk_size = 64;</span></div></pre></div><p>也就是说，<code>memory_chunk_size</code> 默认大小是 64，但你可以针对某一特定类型来进行特化，改变其大小。比如，你想针对你的某一特定 <code>Obj</code> 类型把大小改成 32，你可以写：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;&gt;</span></div><div class="token-line"><span class="token plain">    inline constexpr size_t</span></div><div class="token-line"><span class="token plain">      memory_chunk_size&lt;Obj&gt; = 32;</span></div></pre></div><p>当然，一般情况下你没必要这么做。在大部分需要内存池的场景，默认大小已经工作得挺好了。</p><p>然后，我们需要定义一个数据结构，可以存放某种对象，也可以把内存块串成一个链表。显然，我们可以使用一个 union：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">union node {</span></div><div class="token-line"><span class="token plain">      T data;</span></div><div class="token-line"><span class="token plain">      node* next;</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>直接使用 <code>T</code> 类型的好处是我们可以自然地使用 <code>T</code> 类型的对齐特征，而不需要使用 <code>alignas</code> 之类的麻烦方式。不过，我们也有一些小复杂性需要解决：当 <code>T</code> 是一个带有非平凡构造函数和析构函数的对象时，上面的代码编译会有问题，因为编译器不知道在构造和析构时到底该怎么办了。我们只用这个结点来管理内存，因此我们声明空的构造函数和析构函数就好（注意，此处不能使用 <code>= default</code>）。此外，这样的内存结点显然也不应该进行复制，因此，我们最好要禁用拷贝构造函数和拷贝赋值运算符。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">union node {</span></div><div class="token-line"><span class="token plain">      T data;</span></div><div class="token-line"><span class="token plain">      node* next;</span></div><div class="token-line"><span class="token plain">      node() {}</span></div><div class="token-line"><span class="token plain">      ~node() {}</span></div><div class="token-line"><span class="token plain">      node(const node&amp;) = delete;</span></div><div class="token-line"><span class="token plain">      node&amp;</span></div><div class="token-line"><span class="token plain">      operator=(const node&amp;) = delete;</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>然后，我们就可以定义出内存块了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;typename T&gt;</span></div><div class="token-line"><span class="token plain">    class memory_chunk {</span></div><div class="token-line"><span class="token plain">    public:</span></div><div class="token-line"><span class="token plain">      union node {</span></div><div class="token-line"><span class="token plain">        …</span></div><div class="token-line"><span class="token plain">      };</span></div><div class="token-line"><span class="token plain">      memory_chunk(</span></div><div class="token-line"><span class="token plain">        memory_chunk* next_chunk);</span></div><div class="token-line"><span class="token plain">      node* get_free_nodes()</span></div><div class="token-line"><span class="token plain">      {</span></div><div class="token-line"><span class="token plain">        return storage_.data();</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      memory_chunk* get_next() const</span></div><div class="token-line"><span class="token plain">      {</span></div><div class="token-line"><span class="token plain">        return next_chunk_;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    private:</span></div><div class="token-line"><span class="token plain">      memory_chunk* next_chunk_{};</span></div><div class="token-line"><span class="token plain">      array&lt;node, memory_chunk_size&lt;T&gt;&gt;</span></div><div class="token-line"><span class="token plain">        storage_;</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>内存块就是结点的数组，加上指向下一个内存块的指针，来把内存块串成一个链表。我们通过构造函数来初始化内存块：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;typename T&gt;</span></div><div class="token-line"><span class="token plain">    memory_chunk&lt;T&gt;::memory_chunk(</span></div><div class="token-line"><span class="token plain">      memory_chunk* next_chunk)</span></div><div class="token-line"><span class="token plain">      : next_chunk_(next_chunk)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      for (size_t i = 0;</span></div><div class="token-line"><span class="token plain">           i &lt; storage_.size() - 1;</span></div><div class="token-line"><span class="token plain">           ++i) {</span></div><div class="token-line"><span class="token plain">        storage_[i].next =</span></div><div class="token-line"><span class="token plain">          &amp;storage_[i + 1];</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      storage_[storage_.size() - 1]</span></div><div class="token-line"><span class="token plain">        .next = nullptr;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>“下一个”内存块的指针由外部传入。对于结点的数组，我们使每个结点的 <code>next</code> 指针指向下一项；除了最后一项，其 <code>next</code> 指针为空。也就是说，我们把内存块串成了一个链表，供后面内存池来使用。</p><p>有了这些原料，我们的内存池就可以很方便地写出来了。类的定义如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;typename T&gt;</span></div><div class="token-line"><span class="token plain">    class memory_pool {</span></div><div class="token-line"><span class="token plain">    public:</span></div><div class="token-line"><span class="token plain">      using node =</span></div><div class="token-line"><span class="token plain">        typename memory_chunk&lt;T&gt;::node;</span></div><div class="token-line"><span class="token plain">      memory_pool() = default;</span></div><div class="token-line"><span class="token plain">      memory_pool(const memory_pool&amp;) =</span></div><div class="token-line"><span class="token plain">        delete;</span></div><div class="token-line"><span class="token plain">      memory_pool&amp; operator=(</span></div><div class="token-line"><span class="token plain">        const memory_pool&amp;) = delete;</span></div><div class="token-line"><span class="token plain">      ~memory_pool();</span></div><div class="token-line"><span class="token plain">      T* allocate();</span></div><div class="token-line"><span class="token plain">      void deallocate(T* ptr);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    private:</span></div><div class="token-line"><span class="token plain">      node* free_list_{};</span></div><div class="token-line"><span class="token plain">      memory_chunk&lt;T&gt;* chunk_list_{};</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>可以看到，内存池对象只有两个成员变量，<code>free_list_</code> 和 <code>chunk_list_</code>，及三个成员函数，析构函数、<code>allocate</code> 和 <code>deallocate</code>。<code>free_list_</code> 是空闲结点的链表，<code>chunk_list_</code> 是所有内存块的链表。而在三个成员函数里，析构函数的意义是负责释放所有的内存块：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;typename T&gt;</span></div><div class="token-line"><span class="token plain">    memory_pool&lt;T&gt;::~memory_pool()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      while (chunk_list_) {</span></div><div class="token-line"><span class="token plain">        memory_chunk&lt;T&gt;* chunk =</span></div><div class="token-line"><span class="token plain">          chunk_list_;</span></div><div class="token-line"><span class="token plain">        chunk_list_ =</span></div><div class="token-line"><span class="token plain">          chunk_list_-&gt;get_next();</span></div><div class="token-line"><span class="token plain">        delete chunk;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><code>allocate</code> 负责内存的分配：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;typename T&gt;</span></div><div class="token-line"><span class="token plain">    T* memory_pool&lt;T&gt;::allocate()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      if (free_list_ == nullptr) {</span></div><div class="token-line"><span class="token plain">        chunk_list_ =</span></div><div class="token-line"><span class="token plain">          new memory_chunk&lt;T&gt;(</span></div><div class="token-line"><span class="token plain">            chunk_list_);</span></div><div class="token-line"><span class="token plain">        free_list_ =</span></div><div class="token-line"><span class="token plain">          chunk_list_-&gt;get_free_nodes();</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      T* result = &amp;free_list_-&gt;data;</span></div><div class="token-line"><span class="token plain">      free_list_ = free_list_-&gt;next;</span></div><div class="token-line"><span class="token plain">      return result;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们首先检查空闲列表 <code>free_list_</code> 是否为空，为空则说明内存池里已经没有内存供对象使用，因此我们需要新申请一个内存块，然后让 <code>chunk_list_</code> 指向这个新内存块，并让 <code>free_list</code> 指向其首项。随后，分配内存只是简单地从结点链表上摘下一项，并调整链表的首项指针。</p><p><code>deallocate</code> 当然就是负责内存的释放：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;typename T&gt;</span></div><div class="token-line"><span class="token plain">    void memory_pool&lt;T&gt;::deallocate(T* ptr)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      auto free_item =</span></div><div class="token-line"><span class="token plain">        reinterpret_cast&lt;node*&gt;(ptr);</span></div><div class="token-line"><span class="token plain">      free_item-&gt;next = free_list_;</span></div><div class="token-line"><span class="token plain">      free_list_ = free_item;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这就更简单了，就是把用户传进来的指针当成结点的指针，然后放回到空闲列表里而已。</p><p>顺便说一句，对于调整链表这样的操作，标准库提供的 <code>std::exchange</code> 工具可以让代码更加简洁。比如，<code>allocate</code> 的最后三条语句可以缩成一条：<code>return &amp;exchange(free_list_, free_list_-&gt;next)-&gt;data;</code>。</p><h3 id="内存池应用类特定的分配和释放函数"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/05#内存池应用类特定的分配和释放函数"><span class="icon icon-link"></span></a>内存池应用：类特定的分配和释放函数</h3><p>虽然类特定的分配和释放函数已经不那么经常使用，我们还是可以看一下如何把内存池用到这一最简单的应用场景中。这也可以让我们测一下这种极端情况下的内存池收益。</p><p>之前提过，对于某一个类 <code>Obj</code>，我们要使用类特定的分配和释放函数，只需在其中声明这样两个成员函数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class Obj {</span></div><div class="token-line"><span class="token plain">    public:</span></div><div class="token-line"><span class="token plain">      …</span></div><div class="token-line"><span class="token plain">      void* operator new(size_t size);</span></div><div class="token-line"><span class="token plain">      void operator delete(</span></div><div class="token-line"><span class="token plain">        void* ptr) noexcept;</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>这里我省去了声明前的 <code>static</code>，这是允许的，效果相同（不管写不写 <code>static</code>，这两个成员函数都是静态的）。我们可以在这个类的实现文件（非头文件）里加入下面的内容即可使用内存池：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">memory_pool&lt;Obj&gt; obj_pool;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    void* Obj::operator new(size_t size)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      assert(size == sizeof(Obj));</span></div><div class="token-line"><span class="token plain">      return obj_pool.allocate();</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    void Obj::operator delete(</span></div><div class="token-line"><span class="token plain">      void* ptr) noexcept</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      obj_pool.deallocate(</span></div><div class="token-line"><span class="token plain">        static_cast&lt;Obj*&gt;(ptr));</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>对于这样的对象，及没有类特定的分配和释放函数的对象，分别做大量的 <code>new</code> 和 <code>delete</code> 操作，我在 Linux（默认分配和释放性能最好的主流平台）上得到：</p><blockquote><p><code>107 cycles for each allocation and deallocations on normal Obj</code><br/><code>8 cycles for each allocation and deallocations on pooled Obj</code>\</p></blockquote><p>不使用内存池时平均每次分配和释放耗时 107 个时钟周期，使用内存池则降为 8 个时钟周期。</p><p>如果使用 tcmalloc，区别就小一点了：</p><blockquote><p><code>27 cycles for each allocation and deallocations on normal Obj</code><br/><code>8 cycles for each allocation and deallocations on pooled Obj</code>\</p></blockquote><p>不使用内存池也只要 27 个时钟周期。</p><h3 id="内存池应用分配器"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/05#内存池应用分配器"><span class="icon icon-link"></span></a>内存池应用：分配器</h3><p>上面的测试可以让我们看到内存池带来的收益会有多大，但手工使用 <code>new</code> 和 <code>delete</code> 早就已经不是推荐的做法了。最常见的情况，我们需要把对象放在容器里面。因此，我们需要让分配器支持内存池。</p><p>除了我们定义分配器需要的那些必要定义外，我们需要定义的核心成员函数是 <code>allocate</code> 和 <code>deallocate</code>。实现的示意如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;typename T&gt;</span></div><div class="token-line"><span class="token plain">    memory_pool&lt;T&gt;&amp; get_memory_pool()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      thread_local memory_pool&lt;T&gt; pool;</span></div><div class="token-line"><span class="token plain">      return pool;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    template &lt;typename T,</span></div><div class="token-line"><span class="token plain">              typename Base =</span></div><div class="token-line"><span class="token plain">                allocator&lt;T&gt;&gt;</span></div><div class="token-line"><span class="token plain">    struct pooled_allocator</span></div><div class="token-line"><span class="token plain">      : private Base {</span></div><div class="token-line"><span class="token plain">      …</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      T* allocate(size_t n)</span></div><div class="token-line"><span class="token plain">      {</span></div><div class="token-line"><span class="token plain">        if (n == 1) {</span></div><div class="token-line"><span class="token plain">          return get_memory_pool&lt;T&gt;()</span></div><div class="token-line"><span class="token plain">            .allocate();</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">          return Base::allocate(n);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      void deallocate(T* p, size_t n)</span></div><div class="token-line"><span class="token plain">      {</span></div><div class="token-line"><span class="token plain">        if (n == 1) {</span></div><div class="token-line"><span class="token plain">          return get_memory_pool&lt;T&gt;()</span></div><div class="token-line"><span class="token plain">            .deallocate(p);</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">          return Base::deallocate(p, n);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>也就是说，对于每一种特定类型 <code>T</code>，我们都有一个专属的线程本地内存池。这个内存池会在首次使用被创建，在线程退出时被销毁。</p><p>在 <code>allocate</code> 和 <code>deallocate</code> 函数里，我们首先检查需要分配或释放的对象个数。当前的实现不能处理超过单个对象大小的分配和释放，因此这样的请求会直接转到基类的内存分配器进行处理， 默认情况下是系统的 <code>std::allocator</code>，它会使用 <code>operator new</code> 和 <code>operator delete</code> 来进行分配和释放。我们仅针对单个对象的内存分配和释放使用线程本地内存池，因此这个分配器适合 <code>list</code>、<code>map</code>、<code>set</code> 这样的对元素单独分配内存的容器，而不适合 <code>vector</code>、<code>deque</code> 这样的批量分配内存的容器。——后者实际上也基本没有使用内存池的必要了。</p><p>使用这个内存池很简单，把容器的 <code>Allocator</code> 模板参数设成目前实现的 <code>pooled_allocator</code> 即可。使用之前的测试，我们需要把 <code>TestType</code> 定义成下面的形式：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">using TestType = unordered_set&lt;</span></div><div class="token-line"><span class="token plain">      int, hash&lt;int&gt;, equal_to&lt;int&gt;,</span></div><div class="token-line"><span class="token plain">      pooled_allocator&lt;int&gt;&gt;;</span></div></pre></div><p>由于 <code>Allocator</code> 是最后一个参数，我们必须把之前类模板的默认模板参数也手工补上，也就是 <code>hash&lt;int&gt;</code> 和 <code>equal_to&lt;int&gt;</code> 这两个。这样做一下简单修改之后，我们就能看到测试的性能提升。在 Linux 上我得到了：</p><blockquote><p><code>It took 199 cycles by average to insert a number</code><br/><code>It took 112 cycles by average to erase a number</code><br/><code>It took 110 cycles by average to insert a number again</code></p></blockquote><p>确实是迄今为止最好的性能测试结果！</p><h3 id="生命周期陷阱"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/05#生命周期陷阱"><span class="icon icon-link"></span></a>生命周期陷阱</h3><p>好吧，我撒了个小谎。如果你原封不动按我目前给出的代码来自己实现一遍的话，你很可能看到程序在退出时挂起或崩溃。问题是这样发生的：</p><ol><li>我们有一个全局对象，在构造时会把它的析构函数调用挂到程序退出时需要执行的代码中。</li><li>在这个全局对象首次需要内存时，我们会初始化内存池的实例。同时，它的析构函数会挂到线程退出需要执行的代码中。注意这比第 1 步要晚。</li><li>内存池析构会发生在全局对象析构之前（即使它们都是全局对象或者都是线程本地对象，也一定是后构造的先析构），它会释放所有的内存。</li><li>在全局对象析构时，如果有任何读写之前分配的堆上内存的操作，都是未定义行为！</li></ol><p>那么问题如何解决呢？我们可以选择以下几种方式：</p><ul><li>确保内存池的构造先于全局对象的构造。把全局对象改成 thread_local 是一件简单的事（或者如果我们只需要单线程操作的话，可以把 <code>get_memory_pool</code> 里的 <code>thread_local</code> 改成 <code>static</code>），但问题是，内存池实例的类型是实现定义的，很难预料。对于我们的 <code>unordered_set&lt;int, …&gt;</code>，真正需要实例化的内存池类型可能是 <code>pooled_allocator&lt;std::__detail::_Hash_node&lt;int, false&gt;&gt;</code>，并且会随编译器不同而不同！</li><li>在线程退出时不释放内存。问题是，如果我们重复起停线程的话，就会有内存泄漏了。只有在我们起的线程数量固定的情况下，这种方法才可行。</li><li>不使用全局对象或线程本地对象，而是只使用本地对象。这当然对程序是一种限制……</li></ul><p>很遗憾，似乎真没有完美的解决方案！你只能根据你的实际使用场景，选择其中最合适的一种了。</p><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/adah1972/geek_time_cpp">代码库<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>本讲的最后一个测试用例展示了预声明内存池的做法，如果你真有这样的需要，可以参考一下。</p><h2 id="内容小结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/05#内容小结"><span class="icon icon-link"></span></a>内容小结</h2><p>在本讲中我们完整讨论了内存池，包括它的测试和实现。你在学完这一讲之后，应该已经对内存池有了充分的了解，知道什么情况下、该如何去实现一个内存池。</p><h2 id="课后思考"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/05#课后思考"><span class="icon icon-link"></span></a>课后思考</h2><p>请练习一下本讲的代码，复现内存池生命周期的问题，并尝试使用不同的解决方案。然后：</p><ol><li>尝试一下，在 <code>memory_pool</code> 中加入对象计数，并在析构时检查对象数是否为零，仅在为零时才释放内存。</li><li>考虑一下，如何发现你的容器结点究竟是什么类型？</li></ol><p>如果有任何问题，欢迎留言和我进行讨论。</p><h2 id="参考资料"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/05#参考资料"><span class="icon icon-link"></span></a>参考资料</h2><p>[1] Google, “gperftools”. <a target="_blank" rel="noopener noreferrer" href="https://github.com/gperftools/gperftools">https://github.com/gperftools/gperftools<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[2] GNU, “The GNU allocator”. <a target="_blank" rel="noopener noreferrer" href="https://www.gnu.org/software/libc/manual/html_node/The-GNU-Allocator.html">https://www.gnu.org/software/libc/manual/html_node/The-GNU-Allocator.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/现代c编程实战/10.增补篇/05.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
