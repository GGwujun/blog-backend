<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>33｜性能测试的正确姿势：性能、时间和优化 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/现代c编程实战/10.增补篇/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/现代c编程实战/01.课前必读">01.课前必读</a><ul><li><a href="/blog-backend/现代c编程实战/01.课前必读/01"><span>开篇词 | C加加这么难，为什么我们还要用C加加？</span></a></li><li><a href="/blog-backend/现代c编程实战/01.课前必读/02"><span>课前必读 | 有关术语发音及环境要求</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/02.基础篇">02.基础篇</a><ul><li><a href="/blog-backend/现代c编程实战/02.基础篇/01"><span>01 | 堆、栈、RAII：C加加里该如何管理资源？</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/02"><span>02 | 自己动手，实现C加加的智能指针</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/03"><span>03 | 右值和移动究竟解决了什么问题？</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/04"><span>04 | 容器汇编 I：比较简单的若干容器</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/05"><span>05 | 容器汇编 II：需要函数对象的容器</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/06"><span>06 | 异常：用还是不用，这是个问题</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/07"><span>07 | 迭代器和好用的新for循环</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/08"><span>08 | 易用性改进 I：自动类型推断和初始化</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/09"><span>09 | 易用性改进 II：字面量、静态断言和成员函数说明符</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/03.提高篇">03.提高篇</a><ul><li><a href="/blog-backend/现代c编程实战/03.提高篇/01"><span>10 | 到底应不应该返回对象？</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/02"><span>11 | Unicode：进入多文字支持的世界</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/03"><span>12 | 编译期多态：泛型编程和模板入门</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/04"><span>13 | 编译期能做些什么？一个完整的计算世界</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/05"><span>14 | SFINAE：不是错误的替换失败是怎么回事?</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/06"><span>15 | constexpr：一个常态的世界</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/07"><span>16 | 函数对象和lambda：进入函数式编程</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/08"><span>17 | 函数式编程：一种越来越流行的编程范式</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/09"><span>18 | 应用可变模板和tuple的编译期技巧</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/10"><span>19 | thread和future：领略异步中的未来</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/11"><span>20 | 内存模型和atomic：理解并发的复杂性</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/04.实战篇">04.实战篇</a><ul><li><a href="/blog-backend/现代c编程实战/04.实战篇/01"><span>21 | 工具漫谈：编译、格式化、代码检查、排错各显身手</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/02"><span>22 | 处理数据类型变化和错误：optional、variant、expected和Herbception</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/03"><span>23 | 数字计算：介绍线性代数和数值计算库</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/04"><span>24 | Boost：你需要的“瑞士军刀”</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/05"><span>25 | 两个单元测试库：C加加里如何进行单元测试?</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/06"><span>26 | Easylogging++和spdlog：两个好用的日志库</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/07"><span>27 | C加加 REST SDK：使用现代C开发网络应用</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/05.新年特别策划">05.新年特别策划</a><ul><li><a href="/blog-backend/现代c编程实战/05.新年特别策划/01"><span>新春寄语 | 35年码龄程序员：人生漫长，走点弯路在所难免</span></a></li><li><a href="/blog-backend/现代c编程实战/05.新年特别策划/02"><span>新春福利 | C加加好书荐读</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/06.未来篇">06.未来篇</a><ul><li><a href="/blog-backend/现代c编程实战/06.未来篇/01"><span>28 | Concepts：如何对模板进行约束?</span></a></li><li><a href="/blog-backend/现代c编程实战/06.未来篇/02"><span>29 | Ranges：无迭代器的迭代和更方便的组合</span></a></li><li><a href="/blog-backend/现代c编程实战/06.未来篇/03"><span>30 | Coroutines：协作式的交叉调度执行</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/07.加餐">07.加餐</a><ul><li><a href="/blog-backend/现代c编程实战/07.加餐/01"><span>加餐 | 部分课后思考题答案合集</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/08.结束语">08.结束语</a><ul><li><a href="/blog-backend/现代c编程实战/08.结束语/01"><span>结束语 | 终点已达，行程还要继续</span></a></li><li><a href="/blog-backend/现代c编程实战/08.结束语/02"><span>结课问卷获奖用户名单</span></a></li><li><a href="/blog-backend/现代c编程实战/08.结束语/03"><span>第二季回归｜拿下Vim，让编程效率神器为我所用</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/09.期末测试">09.期末测试</a><ul><li><a href="/blog-backend/现代c编程实战/09.期末测试/01"><span>期末测试 | 对于现代C，你掌握了多少呢？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战/10.增补篇">10.增补篇</a><ul><li><a href="/blog-backend/现代c编程实战/10.增补篇/01"><span>旅程再启｜那些关于C加加的新认知</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/02"><span>31｜new和delete背后：分配函数和释放函数</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/03"><span>32｜容器里的内存管理：分配器</span></a></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战/10.增补篇/04"><span>33｜性能测试的正确姿势：性能、时间和优化</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/05"><span>34｜快速分配和释放内存：内存池</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/06"><span>35 | 发现和识别内存问题：内存调试实践</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/07"><span>36｜访问对象的代理对象：视图类型</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/summary">现代c编程实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="意外的测试结果" data-depth="2"><a href="/blog-backend/现代c编程实战/10.增补篇/04#意外的测试结果"><span>意外的测试结果</span></a></li><li title="如何进行性能测试" data-depth="2"><a href="/blog-backend/现代c编程实战/10.增补篇/04#如何进行性能测试"><span>如何进行性能测试</span></a></li><li title="内存屏障问题" data-depth="3"><a href="/blog-backend/现代c编程实战/10.增补篇/04#内存屏障问题"><span>内存屏障问题</span></a></li><li title="时间测量问题" data-depth="3"><a href="/blog-backend/现代c编程实战/10.增补篇/04#时间测量问题"><span>时间测量问题</span></a></li><li title="通用测试方法" data-depth="3"><a href="/blog-backend/现代c编程实战/10.增补篇/04#通用测试方法"><span>通用测试方法</span></a></li><li title="一个小测试框架" data-depth="3"><a href="/blog-backend/现代c编程实战/10.增补篇/04#一个小测试框架"><span>一个小测试框架</span></a></li><li title="浅谈优化的问题" data-depth="2"><a href="/blog-backend/现代c编程实战/10.增补篇/04#浅谈优化的问题"><span>浅谈优化的问题</span></a></li><li title="优化和未定义行为" data-depth="3"><a href="/blog-backend/现代c编程实战/10.增补篇/04#优化和未定义行为"><span>优化和未定义行为</span></a></li><li title="优化和执行顺序" data-depth="3"><a href="/blog-backend/现代c编程实战/10.增补篇/04#优化和执行顺序"><span>优化和执行顺序</span></a></li><li title="内容小结" data-depth="2"><a href="/blog-backend/现代c编程实战/10.增补篇/04#内容小结"><span>内容小结</span></a></li><li title="课后思考" data-depth="2"><a href="/blog-backend/现代c编程实战/10.增补篇/04#课后思考"><span>课后思考</span></a></li><li title="参考资料" data-depth="2"><a href="/blog-backend/现代c编程实战/10.增补篇/04#参考资料"><span>参考资料</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="33性能测试的正确姿势性能时间和优化"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/04#33性能测试的正确姿势性能时间和优化"><span class="icon icon-link"></span></a>33｜性能测试的正确姿势：性能、时间和优化</h1><p>你好，我是吴咏炜。</p><p>在上一讲讲完后，原本计划是要聊一聊内存池的。不过，要说内存池的好坏，就得讨论性能，而之前并没有专门讲过性能测试这个话题。鉴于这个问题本身有一定的复杂性，我们还是先专门用一讲讨论一下性能测试的相关问题。</p><h2 id="意外的测试结果"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/04#意外的测试结果"><span class="icon icon-link"></span></a>意外的测试结果</h2><p>假设你想测试一下，<code>memset</code> 究竟有没有性能优势。于是，你写下了下面这样的测试代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;stdio.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;string.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;time.h&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      constexpr int LOOPS = 10000000;</span></div><div class="token-line"><span class="token plain">      char buf[80];</span></div><div class="token-line"><span class="token plain">      clock_t t1;</span></div><div class="token-line"><span class="token plain">      clock_t t2;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      t1 = clock();</span></div><div class="token-line"><span class="token plain">      for (int i = 0; i &lt; LOOPS; ++i) {</span></div><div class="token-line"><span class="token plain">        memset(buf, 0, sizeof buf);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      t2 = clock();</span></div><div class="token-line"><span class="token plain">      printf(&quot;%g\n&quot;, (t2 - t1) * 1.0 /</span></div><div class="token-line"><span class="token plain">                       CLOCKS_PER_SEC);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      t1 = clock();</span></div><div class="token-line"><span class="token plain">      for (int i = 0; i &lt; LOOPS; ++i) {</span></div><div class="token-line"><span class="token plain">        for (size_t j = 0;</span></div><div class="token-line"><span class="token plain">             j &lt; sizeof buf; ++j) {</span></div><div class="token-line"><span class="token plain">          buf[j] = 0;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      t2 = clock();</span></div><div class="token-line"><span class="token plain">      printf(&quot;%g\n&quot;, (t2 - t1) * 1.0 /</span></div><div class="token-line"><span class="token plain">                       CLOCKS_PER_SEC);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然后你运行一下，啊哈，使用 <code>memset</code> 要快出 50 倍以上！</p><blockquote><p><code>0.044433</code><br/><code>2.53513</code></p></blockquote><p>好奇如你，也许就会想到，开启优化会不会有区别呢？于是，你加上了 <code>-O2</code> 命令行选项。在某些编译器上，你可能会对类似下面的结果目瞪口呆的：</p><blockquote><p><code>2e-06</code><br/><code>1e-06</code></p></blockquote><p><code>memset</code> 更慢？优化比不优化快了一百万倍？编译器这是疯掉了吗？😱</p><hr/><p>到了这里，我们需要复习一下<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/186708">第 20 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里关于内存模型和优化的这两句话：</p><blockquote><p>为了优化的必要，编译器是可以调整代码的执行顺序的。唯一的要求是，程序的“可观测”外部行为是一致的。</p></blockquote><p>当时我这么写是要说明，单线程下正确的行为可能到了多线程就有问题。但从性能测试的角度，即使单线程也一样会遇到鬼！编译器非常聪明，它看到了：你往内存里写数据了，又没有使用写到内存的数据；同时这是本地变量，你也没有把变量的引用或指针传到其他地方去。所以，外界不会观测到数据的改变。没人看到的东西，干吗需要存在？于是乎，编译器就把写内存的代码彻底优化没了，没了……</p><p>你模模糊糊想起来，<code>volatile</code> 关键字可以影响编译器优化。那加上这个关键字是不是有效呢？经过一番折腾，你把代码改成了下面这个样子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">volatile char buf[80];</span></div><div class="token-line"><span class="token plain">      …</span></div><div class="token-line"><span class="token plain">      for (int i = 0; i &lt; LOOPS; ++i) {</span></div><div class="token-line"><span class="token plain">        memset(const_cast&lt;char*&gt;(buf),</span></div><div class="token-line"><span class="token plain">               0, sizeof buf);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      …</span></div></pre></div><p>运行之后，可能得到下面这样的结果：</p><blockquote><p><code>0.104638</code><br/><code>0.467247</code></p></blockquote><p>哈，这就合理多了！看起来，我们可以得出结论，<code>memset</code> 确实比手工填充数据要快不少啊。</p><hr/><p>不过，这个结论真的正确吗？</p><p>答案为否。</p><p><code>volatile</code> 关键字确实阻止了编译器优化。但这回它反向影响了。<code>volatile</code> 在 C加加 里的语义是，严格按照代码的指示对内存进行读写：你写一次，编译器就产生相应写的代码；你读一次，编译器就产生相应读的代码——一个不多，一个不少。这就导致了对内存操作的性能劣化。通常，你只在进行内存映射的输入输出时才有这么用的必要。</p><p>如果不用 <code>volatile</code>，那编译器至少在理论上是可以对上面的代码做出更好的优化的。我们把 <code>buf</code> 改成一个普通的全局变量，就能测到一个更接近真实的效果了。我们可以看到，GCC 和 Clang 都做出了更好的优化，对 <code>memset</code> 和循环清零产生了完全相同的代码。GCC 在 Core i7 架构（<code>-march=corei7</code>）上产生的汇编代码如下（参见 <a target="_blank" rel="noopener noreferrer" href="https://godbolt.org/z/xeohT4v1P">https://godbolt.org/z/xeohT4v1P<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pxor    xmm0, xmm0</span></div><div class="token-line"><span class="token plain">    movaps  XMMWORD PTR buf[rip], xmm0</span></div><div class="token-line"><span class="token plain">    movaps  XMMWORD PTR buf[rip+16], xmm0</span></div><div class="token-line"><span class="token plain">    movaps  XMMWORD PTR buf[rip+32], xmm0</span></div><div class="token-line"><span class="token plain">    movaps  XMMWORD PTR buf[rip+48], xmm0</span></div><div class="token-line"><span class="token plain">    movaps  XMMWORD PTR buf[rip+64], xmm0</span></div></pre></div><p>也就是说，编译器洞察了你要做的事情是往 <code>buf</code> 里写入 80 个零，因而采取了最高效的方式，一次写 16 个零，连写五次，根本就没有循环了……</p><h2 id="如何进行性能测试"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/04#如何进行性能测试"><span class="icon icon-link"></span></a>如何进行性能测试</h2><p>我上面给出了答案，但我忽略了一些测试细节。很遗憾，这个问题真的有点复杂。我们现在再回过来讨论一下。</p><h3 id="内存屏障问题"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/04#内存屏障问题"><span class="icon icon-link"></span></a>内存屏障问题</h3><p>使用全局变量并不意味着我们一定就能测到真实数据。以上面的这个测试为例，虽然编译器看到我们往全局变量写入，就一定不可能把写入完全忽略掉，但它完全可能会做一些写入的合并。事实上，实测下来 Clang 就做了写入的合并，因此测试的结果数据看起来比 GCC 和 MSVC 要漂亮很多。从测试上面两种写法的区别上讲，问题还不算大，但如果我们想拿这个数据来计算代码的性能数据的话，那就要了命了。</p><p>一种可能的解法是加入内存屏障，告诉编译器到现在为止的内存修改都得给我完成了。全局锁就是一种通用的内存屏障，但在上面的代码里加入全局锁的话，加解锁的开销就会完全掩盖我们要测试部分的开销了。每种处理器架构都有自己的内存屏障指令，这比 C加加 或操作系统的锁要轻量一点，但对于我们上面的测试来讲，仍然是重了（约 10 倍的性能下降）。每一种编译器，基本上也都有非标准的轻量级内存屏障指令，只影响编译器优化，而不影响 CPU 的处理性能。</p><p>最后一种方式看起来最有希望，但遗憾的是，在我们上面的例子里，加入内存屏障本身会影响 GCC 产生的代码。仅针对目前的代码，我们可以写出下面这样一个内存屏障的函数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#ifdef _MSC_VER</span></div><div class="token-line"><span class="token plain">    #include &lt;intrin.h&gt;</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    inline void memory_fence()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    #ifdef _MSC_VER</span></div><div class="token-line"><span class="token plain">      _ReadWriteBarrier();</span></div><div class="token-line"><span class="token plain">    #elif defined(__clang__)</span></div><div class="token-line"><span class="token plain">      __asm__ __volatile__(&quot;&quot; ::: &quot;memory&quot;);</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然后我们在测试代码后调用这个函数，确保对内存的写入会生效。注意我们仍需使用全局变量作为写入目标才行。</p><p>这种解法的问题是，它实在太脆弱了。从原理上来讲，它能不能工作并没有任何人可以保证。对于一个新的编译器，代码很可能会无效；对于当前工作的编译器的一个新版本，代码也可能会变为无效……</p><p>目前最可靠也最跨平台的解决方案仍然是用锁。如果想使用锁，我们需要有一种比 <code>clock()</code> 精度高得多的测量时间的办法。</p><h3 id="时间测量问题"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/04#时间测量问题"><span class="icon icon-link"></span></a>时间测量问题</h3><p>不同的平台有不同的时间测量函数。具体的细节我就不讨论了，直接给出我的测试结果。</p><p>Linux：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimageb3dbb3e38cdc0aa80fc3595cd13b8f5b45db.45e93ba8.jpg" alt=""/></p><p>Windows：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage4db64d14382c890b228aec051e3f1f1865b6.fca641e2.jpg" alt=""/></p><p>精度的测量是取当函数返回的数值变化时的差值。当连续调用某一个计时函数时，它返回的结果是可能不变的。当它变化时，变化的数值就是它的测时精度。表中展示的就是这些精度测量结果的平均值（及方差，如果测试结果不完全一样的话）。</p><p>精度受 API 设计的影响，也受函数实现的影响。比如，Windows 上定义 <code>CLOCKS_PER_SEC</code> 为 1000，显然 <code>clock()</code> 也就不可能获得高于一毫秒的精度了。C加加11 的三种时钟从目前实现的接口上来看都允许实现一纳秒的精度，但实际精度则要远远低于一纳秒。</p><p>测试结果当然跟具体的硬件也可能有关系，但至少这里可以看到一些基本的共性：</p><ul><li>首先，<code>clock()</code> 函数不是个好选择，它的精度可能很差，本身耗时也可能会比较长。</li><li>其次，C加加11 带来的三种时钟不管是精度还是自身开销都还算不错。既然其他方面没有区别，我们就选择使用能提供稳定增长保证的 <code>steady_clock</code>（<code>system_clock</code> 是不稳定的，系统时间被调整时，时钟返回的数值也会变化；<code>high_resolution_clock</code> 的稳定性在标准中没有进行规定）[1]。</li><li>最后，如果时间戳计数器（Time Stamp Counter [2]）可用的话，它能提供最高的精度和最短的耗时。它是处理器上的硬件计数器，精度高，速度快，在多核系统上也能提供正确的读数；但在多 CPU 插槽的系统上则不一定能提供相应的保证，因而在那种情况下可能需要把测试程序绑定到某个核上运行。</li></ul><p><code>rdtsc</code> 返回的数值单位是时钟周期数（但频率可能跟处理器的实际运行频率不同）。上表中测量各个函数的耗时用的就是 <code>rdtsc</code>。</p><p>我目前在<a target="_blank" rel="noopener noreferrer" href="https://github.com/adah1972/geek_time_cpp">代码库<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里加入了 rdtsc.h 文件。它的实现就是优先使用 x86 和 x86-64 平台提供的 <code>rdtsc</code> 的实现，在找不到时转而使用 <code>stead_clock</code> 作为替代。有兴趣的可以自行查看。</p><p>额外提一句，我这边讲的性能测试是微观层面的测试，即所谓的 microbenchmarking，一般以函数为单位。这种测试是单线程的，需要干扰尽可能少。可能的干扰有：</p><ul><li>其他的应用程序——应尽可能关闭其他应用，尤其是会耗 CPU的。</li><li>处理器的自动频率变化——最好关闭这类功能，如 Intel 的 Turbo Boost。</li><li>不同性能核之间的迁移——如果你的测试系统上有所谓的大小核，而你又没办法把程序绑定到某个核上面的话，那这样的系统不适合用来做微观层面的性能测试。</li></ul><h3 id="通用测试方法"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/04#通用测试方法"><span class="icon icon-link"></span></a>通用测试方法</h3><p>下面我们讨论一种我个人经常使用的通用的性能测试方法。由于编译器的很多优化机制并不能由代码来控制，这也只能算是一种最佳实践而已。根据你的特定平台，也许你可以找出更好的测试方法。</p><p>我的基本方法是：</p><ul><li>把待测的代码放到一个函数里，这样容易消除一些其他干扰。</li><li>可选地，把这个函数用 <code>__attribute__((noinline))</code> [3] 或 <code>__declspec(noinline)</code> [4] 标注为不要内联。</li><li>确保有一个依赖函数执行结果的数值会被写到某个全局变量里。根据代码的规模和组织，可以直接在这个函数里写入，或者通过外部传入的一个全局变量的指针或引用来写入。</li><li>在函数的开头和结尾测量时间，并把测得的时长累加到某个地方。</li><li>在循环里反复调用被测函数，并在每次调用函数前后进行加解锁，产生内存屏障。</li></ul><p>比如，<code>memset</code> 的测试代码可能就会变成这个样子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">char buf[80];</span></div><div class="token-line"><span class="token plain">    uint64_t memset_duration;</span></div><div class="token-line"><span class="token plain">    std::mutex mutex;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    void test_memset()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      uint64_t t1 = rdtsc();</span></div><div class="token-line"><span class="token plain">      memset(buf, 0, sizeof buf);</span></div><div class="token-line"><span class="token plain">      uint64_t t2 = rdtsc();</span></div><div class="token-line"><span class="token plain">      memset_duration += (t2 - t1);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      constexpr int LOOPS = 10000000;</span></div><div class="token-line"><span class="token plain">      for (int i = 0; i &lt; LOOPS; ++i) {</span></div><div class="token-line"><span class="token plain">        std::lock_guard guard{mutex};</span></div><div class="token-line"><span class="token plain">        test_memset();</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      printf(&quot;%g\n&quot;, memset_duration * 1.0 / LOOPS);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>使用这种方法，我们确实可以验证出在 GCC 和 Clang 下，两种清零方法在缓冲区大小已知的情况下可以获得相同的性能（如果大小要运行时才能决定，那就是另外一个需要单独测试的问题了）。</p><h3 id="一个小测试框架"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/04#一个小测试框架"><span class="icon icon-link"></span></a>一个小测试框架</h3><p>利用 RAII（<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/169225">第 1 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），我们可以使用一个框架把代码再整理一下，使得测试更加简单和自动。这个框架比较简单，设计和实现我就不讲了。下面给你简单介绍一下它的使用。</p><p>对于当前的例子，首先我们需要声明两个待测函数的索引：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">enum profiled_functions {</span></div><div class="token-line"><span class="token plain">      PF_TEST_MEMSET,</span></div><div class="token-line"><span class="token plain">      PF_TEST_PLAIN_LOOP,</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>然后，我们需要声明函数索引和函数名的关系：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">name_mapper name_map[] = {</span></div><div class="token-line"><span class="token plain">      {PF_TEST_MEMSET, &quot;test_memset&quot;},</span></div><div class="token-line"><span class="token plain">      {PF_TEST_PLAIN_LOOP, &quot;test_plain_loop&quot;},</span></div><div class="token-line"><span class="token plain">      {-1, nullptr}};</span></div></pre></div><p>对于待测函数，我们需要在函数开头插入一行代码，表示要对这个函数进行性能测试（利用一个 RAII 对象）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void test_memset()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      PROFILE_CHECK(PF_TEST_MEMSET);</span></div><div class="token-line"><span class="token plain">      memset(buf, 0, sizeof buf);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样就行了。下面输出的代码也不需要了，程序会在最后进程退出的时候自动打印汇总测试数据（利用另外一个 RAII 对象），如下所示：</p><blockquote><p><code>0 test_memset:</code><br/><code>Call count: 10000000</code><br/><code>Call duration: 240756468</code><br/><code>Average duration: 24.0756</code><br/><code>1 test_plain_loop:</code><br/><code>Call count: 10000000</code><br/><code>Call duration: 241429159</code><br/><code>Average duration: 24.1429</code></p></blockquote><p>完整代码请参考 GitHub 上的<a target="_blank" rel="noopener noreferrer" href="https://github.com/adah1972/geek_time_cpp">代码库<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。如果想检查不同架构下的性能差异的话，可以在 cmake 命令行上指定编译器和附加参数，如：</p><p><code>CXX=&#x27;g++ \-march=corei7&#x27; cmake …</code></p><p>此外，需要说明一下，跟 <code>assert</code> 类似，<code>PROFILE_CHECK</code> 宏在 <code>NDEBUG</code> 宏被定义时就不生效了。所以，上面的输出在使用了 <code>cmake \-DCMAKE_BUILD_TYPE=Release …</code> 时就不会有了。</p><p>最后，注意我举这个例子，主要是为了说明测试的复杂性和测试的方法。对于这个例子本身，由于代码简单、运行时间非常短，测试带来的额外开销过大，因而检查汇编输出可能是最好的检查性能的方式。显然，对于更大更复杂的代码，从汇编代码推断性能就困难多了。在那时候，类似目前的测试框架这样的代码就会非常有用。</p><h2 id="浅谈优化的问题"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/04#浅谈优化的问题"><span class="icon icon-link"></span></a>浅谈优化的问题</h2><p>今天提到的测试困难，很大程度上都是 C加加 编译器的优化造成的。事实上，C加加 里很多未定义行为之所以成为未定义行为，也是跟性能有关的。为了追求性能，C加加 编译器是可谓无所不用其极。有些人觉得编译器忽略了人的意图，感到很不爽，但事实是，C加加 编译器在优化方面确实比大部分程序员做得更好。这也是现在基本上没人写汇编的原因——即使不考虑可移植性，在某一特定平台上要写出超过 C加加 编译器水平的汇编代码，也已经越来越困难了。</p><p>但这种优化，虽然常常对程序有好处，也常常是违背程序员的直觉的。我这里另外举两个简单的例子，来说明一下为什么 C加加 编译器<strong>需要</strong>违反程序员的直觉。</p><h3 id="优化和未定义行为"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/04#优化和未定义行为"><span class="icon icon-link"></span></a>优化和未定义行为</h3><p>假如我们有一个 <code>int</code> 类型的变量 <code>x</code>，那 <code>x * 2 / 2</code> 的结果是几？</p><p>如果 C加加 把有符号整数运算溢出的结果定义为补码的内存表示，也就是说，32 位正整数 <code>0x40&#x27;00&#x27;00&#x27;00</code>（$2^<!-- -->{<!-- -->30<!-- -->}<!-- -->$）乘以 2 的结果就是 <code>0x80&#x27;00&#x27;00&#x27;00</code>（$-2^<!-- -->{<!-- -->31<!-- -->}<!-- -->$），再除以 2 的话，我们就不能得回原先的数值，而是得到了 <code>0xC0&#x27;00&#x27;00&#x27;00</code>（$-2^<!-- -->{<!-- -->30<!-- -->}<!-- -->$）。这样的话，<code>x * 2 / 2</code> 就不能优化为 <code>x</code>！</p><p>那能不能使用异常呢？也不行。跟除零不一样，整数运算溢出不会产生硬件中断。而如果我们在每条加法、减法、乘法、除法（对，除法也可能溢出—— <code>INT_MIN / \-1</code> 就会）上都加入指令来检查是否发生溢出、并在发生溢出时报告异常的话，性能的退步将是不可接受的 [5]。</p><p>所以，C加加 的处理方式就是，规定有符号整数运算溢出为未定义行为 [6]，即程序员需要保证这种情况不会发生，否则后果自负。这在允许编译器把 <code>x * 2 / 2</code> 优化成 <code>x</code> 的同时，也意味着，下面这样的代码返回的结果可能会跟程序员预想的不同（参见 <a target="_blank" rel="noopener noreferrer" href="https://godbolt.org/z/Ex5ad6vM9">https://godbolt.org/z/Ex5ad6vM9<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">bool test(int n)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      return (n + 1) == INT_MIN;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你想的是，如果 <code>n + 1</code> 溢出了，应该会得到 <code>INT_MIN</code> 这个特殊的结果。但编译器可以认为溢出是永远不会发生的（因为正确的程序里不应该有未定义行为），因此可以直接返回 <code>false</code>。——这也是实际可以在 GCC 和 Clang 上测到的结果。</p><h3 id="优化和执行顺序"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/04#优化和执行顺序"><span class="icon icon-link"></span></a>优化和执行顺序</h3><p>假设我们有三个全局 <code>int</code> 变量 <code>x</code>、<code>y</code> 和 <code>a</code>，然后我们执行下面的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">x = a;</span></div><div class="token-line"><span class="token plain">    y = 2;</span></div></pre></div><p>那是不是编译器会产生先写入 <code>x</code>、再写入 <code>y</code> 的代码呢？</p><p>我想你猜到了，答案为“不一定”。下面是某些编译器实际产生的汇编代码（参见 <a target="_blank" rel="noopener noreferrer" href="https://godbolt.org/z/zsfvsf63E">https://godbolt.org/z/zsfvsf63E<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">mov     eax, DWORD PTR a</span></div><div class="token-line"><span class="token plain">    mov     DWORD PTR y, 2</span></div><div class="token-line"><span class="token plain">    mov     DWORD PTR x, eax</span></div></pre></div><p>我们可以看到，编译器产生的代码是：先读入 <code>a</code>，再写入 <code>y</code>，最后写入 <code>x</code>。</p><p>为什么要这样？一样，是因为优化。读入 <code>a</code> 的数值到 eax 寄存器里，跟写入 2 到 <code>y</code> 里是两个不相关操作，可以同时执行。这样的代码，比起完全按程序员指定的执行顺序产生的代码，可望得到更高的性能。</p><h2 id="内容小结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/04#内容小结"><span class="icon icon-link"></span></a>内容小结</h2><p>本讲我们通过一个小例子，讨论了优化跟性能测试的一些问题。希望你在学完这一讲之后，能够了解优化对代码和测试产生的影响，并能正确地测试代码的性能。</p><h2 id="课后思考"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/04#课后思考"><span class="icon icon-link"></span></a>课后思考</h2><p>请尝试修改代码，让编译器没法在编译期得到需要清零的数据块大小。测试这种情况下的性能。（提示：你这次需要上面讲到的要求不内联的标注了。）</p><p>如果对结果有疑惑，建议使用 Compiler Explorer 网站（<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/187980">第 21 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>有介绍）或编译器生成汇编代码（<code>-S</code> 或 <code>/Fa</code>）的选项来仔细检视一下。</p><p>如果有任何疑问，欢迎留言和我讨论。</p><h2 id="参考资料"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/10.增补篇/04#参考资料"><span class="icon icon-link"></span></a>参考资料</h2><p>[1] cppreference.com, “Date and time utilities – Clocks”. <a target="_blank" rel="noopener noreferrer" href="https://en.cppreference.com/w/cpp/chrono#Clocks">https://en.cppreference.com/w/cpp/chrono#Clocks<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[1a] cppreference.com, “日期和时间工具 – 时钟”. <a target="_blank" rel="noopener noreferrer" href="https://zh.cppreference.com/w/cpp/chrono#.E6.97.B6.E9.92.9F">https://zh.cppreference.com/w/cpp/chrono#.E6.97.B6.E9.92.9F<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[2] Wikipedia, “Time Stamp Counter”. <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">https://en.wikipedia.org/wiki/Time_Stamp_Counter<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[3] GCC, “GCC 11.2 Manual – Common Function Attributes”. <a target="_blank" rel="noopener noreferrer" href="https://gcc.gnu.org/onlinedocs/gcc-11.2.0/gcc/Common-Function-Attributes.html">https://gcc.gnu.org/onlinedocs/gcc-11.2.0/gcc/Common-Function-Attributes.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[4] Microsoft, “noinline”. <a target="_blank" rel="noopener noreferrer" href="https://docs.microsoft.com/en-us/cpp/cpp/noinline?view=msvc-170">https://docs.microsoft.com/en-us/cpp/cpp/noinline?view=msvc-170<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[5] Will Dietz, Peng Li, John Regehr, and Vikram Adve, “Understanding Integer Overflow in C/C加加”. <a target="_blank" rel="noopener noreferrer" href="https://www.cs.utah.edu/~regehr/papers/overflow12.pdf">https://www.cs.utah.edu/~regehr/papers/overflow12.pdf<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[6] cppreference.com, “Undefined behavior”. <a target="_blank" rel="noopener noreferrer" href="https://en.cppreference.com/w/cpp/language/ub">https://en.cppreference.com/w/cpp/language/ub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[6a] cppreference.com, “未定义行为”. <a target="_blank" rel="noopener noreferrer" href="http://zh.cppreference.com/w/cpp/language/ub">http://zh.cppreference.com/w/cpp/language/ub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/现代c编程实战/10.增补篇/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
