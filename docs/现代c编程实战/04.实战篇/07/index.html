<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>27 | C加加 REST SDK：使用现代C开发网络应用 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/现代c编程实战/04.实战篇/07" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/现代c编程实战/01.课前必读">01.课前必读</a><ul><li><a href="/blog-backend/现代c编程实战/01.课前必读/01"><span>开篇词 | C加加这么难，为什么我们还要用C加加？</span></a></li><li><a href="/blog-backend/现代c编程实战/01.课前必读/02"><span>课前必读 | 有关术语发音及环境要求</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/02.基础篇">02.基础篇</a><ul><li><a href="/blog-backend/现代c编程实战/02.基础篇/01"><span>01 | 堆、栈、RAII：C加加里该如何管理资源？</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/02"><span>02 | 自己动手，实现C加加的智能指针</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/03"><span>03 | 右值和移动究竟解决了什么问题？</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/04"><span>04 | 容器汇编 I：比较简单的若干容器</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/05"><span>05 | 容器汇编 II：需要函数对象的容器</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/06"><span>06 | 异常：用还是不用，这是个问题</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/07"><span>07 | 迭代器和好用的新for循环</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/08"><span>08 | 易用性改进 I：自动类型推断和初始化</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/09"><span>09 | 易用性改进 II：字面量、静态断言和成员函数说明符</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/03.提高篇">03.提高篇</a><ul><li><a href="/blog-backend/现代c编程实战/03.提高篇/01"><span>10 | 到底应不应该返回对象？</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/02"><span>11 | Unicode：进入多文字支持的世界</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/03"><span>12 | 编译期多态：泛型编程和模板入门</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/04"><span>13 | 编译期能做些什么？一个完整的计算世界</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/05"><span>14 | SFINAE：不是错误的替换失败是怎么回事?</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/06"><span>15 | constexpr：一个常态的世界</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/07"><span>16 | 函数对象和lambda：进入函数式编程</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/08"><span>17 | 函数式编程：一种越来越流行的编程范式</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/09"><span>18 | 应用可变模板和tuple的编译期技巧</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/10"><span>19 | thread和future：领略异步中的未来</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/11"><span>20 | 内存模型和atomic：理解并发的复杂性</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战/04.实战篇">04.实战篇</a><ul><li><a href="/blog-backend/现代c编程实战/04.实战篇/01"><span>21 | 工具漫谈：编译、格式化、代码检查、排错各显身手</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/02"><span>22 | 处理数据类型变化和错误：optional、variant、expected和Herbception</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/03"><span>23 | 数字计算：介绍线性代数和数值计算库</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/04"><span>24 | Boost：你需要的“瑞士军刀”</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/05"><span>25 | 两个单元测试库：C加加里如何进行单元测试?</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/06"><span>26 | Easylogging++和spdlog：两个好用的日志库</span></a></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战/04.实战篇/07"><span>27 | C加加 REST SDK：使用现代C开发网络应用</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/05.新年特别策划">05.新年特别策划</a><ul><li><a href="/blog-backend/现代c编程实战/05.新年特别策划/01"><span>新春寄语 | 35年码龄程序员：人生漫长，走点弯路在所难免</span></a></li><li><a href="/blog-backend/现代c编程实战/05.新年特别策划/02"><span>新春福利 | C加加好书荐读</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/06.未来篇">06.未来篇</a><ul><li><a href="/blog-backend/现代c编程实战/06.未来篇/01"><span>28 | Concepts：如何对模板进行约束?</span></a></li><li><a href="/blog-backend/现代c编程实战/06.未来篇/02"><span>29 | Ranges：无迭代器的迭代和更方便的组合</span></a></li><li><a href="/blog-backend/现代c编程实战/06.未来篇/03"><span>30 | Coroutines：协作式的交叉调度执行</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/07.加餐">07.加餐</a><ul><li><a href="/blog-backend/现代c编程实战/07.加餐/01"><span>加餐 | 部分课后思考题答案合集</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/08.结束语">08.结束语</a><ul><li><a href="/blog-backend/现代c编程实战/08.结束语/01"><span>结束语 | 终点已达，行程还要继续</span></a></li><li><a href="/blog-backend/现代c编程实战/08.结束语/02"><span>结课问卷获奖用户名单</span></a></li><li><a href="/blog-backend/现代c编程实战/08.结束语/03"><span>第二季回归｜拿下Vim，让编程效率神器为我所用</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/09.期末测试">09.期末测试</a><ul><li><a href="/blog-backend/现代c编程实战/09.期末测试/01"><span>期末测试 | 对于现代C，你掌握了多少呢？</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/10.增补篇">10.增补篇</a><ul><li><a href="/blog-backend/现代c编程实战/10.增补篇/01"><span>旅程再启｜那些关于C加加的新认知</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/02"><span>31｜new和delete背后：分配函数和释放函数</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/03"><span>32｜容器里的内存管理：分配器</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/04"><span>33｜性能测试的正确姿势：性能、时间和优化</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/05"><span>34｜快速分配和释放内存：内存池</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/06"><span>35 | 发现和识别内存问题：内存调试实践</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/07"><span>36｜访问对象的代理对象：视图类型</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/summary">现代c编程实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="初识 C加加 REST SDK" data-depth="2"><a href="/blog-backend/现代c编程实战/04.实战篇/07#初识-c加加-rest-sdk"><span>初识 C加加 REST SDK</span></a></li><li title="安装和编译" data-depth="2"><a href="/blog-backend/现代c编程实战/04.实战篇/07#安装和编译"><span>安装和编译</span></a></li><li title="概述" data-depth="2"><a href="/blog-backend/现代c编程实战/04.实战篇/07#概述"><span>概述</span></a></li><li title="异步流" data-depth="2"><a href="/blog-backend/现代c编程实战/04.实战篇/07#异步流"><span>异步流</span></a></li><li title="JSON 支持" data-depth="2"><a href="/blog-backend/现代c编程实战/04.实战篇/07#json-支持"><span>JSON 支持</span></a></li><li title="HTTP 服务器" data-depth="2"><a href="/blog-backend/现代c编程实战/04.实战篇/07#http-服务器"><span>HTTP 服务器</span></a></li><li title="关于线程的细节" data-depth="2"><a href="/blog-backend/现代c编程实战/04.实战篇/07#关于线程的细节"><span>关于线程的细节</span></a></li><li title="内容小结" data-depth="2"><a href="/blog-backend/现代c编程实战/04.实战篇/07#内容小结"><span>内容小结</span></a></li><li title="课后思考" data-depth="2"><a href="/blog-backend/现代c编程实战/04.实战篇/07#课后思考"><span>课后思考</span></a></li><li title="参考资料" data-depth="2"><a href="/blog-backend/现代c编程实战/04.实战篇/07#参考资料"><span>参考资料</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="27--c加加-rest-sdk使用现代c开发网络应用"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/04.实战篇/07#27--c加加-rest-sdk使用现代c开发网络应用"><span class="icon icon-link"></span></a>27 | C加加 REST SDK：使用现代C开发网络应用</h1><p>你好，我是吴咏炜。</p><p>在实战篇，我们最后要讲解的一个库是 C加加 REST SDK（也写作 cpprestsdk）[1]，一个支持 HTTP 协议 [2]、主要用于 RESTful [3] 接口开发的 C加加 库。</p><h2 id="初识-c加加-rest-sdk"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/04.实战篇/07#初识-c加加-rest-sdk"><span class="icon icon-link"></span></a>初识 C加加 REST SDK</h2><p>向你提一个问题，你认为用多少行代码可以写出一个类似于 curl [4] 的 HTTP 客户端？</p><p>使用 C加加 REST SDK 的话，答案是，只需要五十多行有效代码（即使是适配到我们目前的窄小的手机屏幕上）。请看：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;iostream&gt;</span></div><div class="token-line"><span class="token plain">    #ifdef _WIN32</span></div><div class="token-line"><span class="token plain">    #include &lt;fcntl.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;io.h&gt;</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">    #include &lt;cpprest/http_client.h&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    using namespace utility;</span></div><div class="token-line"><span class="token plain">    using namespace web::http;</span></div><div class="token-line"><span class="token plain">    using namespace web::http::client;</span></div><div class="token-line"><span class="token plain">    using std::cerr;</span></div><div class="token-line"><span class="token plain">    using std::endl;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #ifdef _WIN32</span></div><div class="token-line"><span class="token plain">    #define tcout std::wcout</span></div><div class="token-line"><span class="token plain">    #else</span></div><div class="token-line"><span class="token plain">    #define tcout std::cout</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    auto get_headers(http_response resp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      auto headers = resp.to_string();</span></div><div class="token-line"><span class="token plain">      auto end =</span></div><div class="token-line"><span class="token plain">        headers.find(U(&quot;\r\n\r\n&quot;));</span></div><div class="token-line"><span class="token plain">      if (end != string_t::npos) {</span></div><div class="token-line"><span class="token plain">        headers.resize(end + 4);</span></div><div class="token-line"><span class="token plain">      };</span></div><div class="token-line"><span class="token plain">      return headers;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    auto get_request(string_t uri)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      http_client client{uri};</span></div><div class="token-line"><span class="token plain">      // 用 GET 方式发起一个客户端请求</span></div><div class="token-line"><span class="token plain">      auto request =</span></div><div class="token-line"><span class="token plain">        client.request(methods::GET)</span></div><div class="token-line"><span class="token plain">          .then([](http_response resp) {</span></div><div class="token-line"><span class="token plain">            if (resp.status_code() !=</span></div><div class="token-line"><span class="token plain">                status_codes::OK) {</span></div><div class="token-line"><span class="token plain">              // 不 OK，显示当前响应信息</span></div><div class="token-line"><span class="token plain">              auto headers =</span></div><div class="token-line"><span class="token plain">                get_headers(resp);</span></div><div class="token-line"><span class="token plain">              tcout &lt;&lt; headers;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            // 进一步取出完整响应</span></div><div class="token-line"><span class="token plain">            return resp</span></div><div class="token-line"><span class="token plain">              .extract_string();</span></div><div class="token-line"><span class="token plain">          })</span></div><div class="token-line"><span class="token plain">          .then([](string_t str) {</span></div><div class="token-line"><span class="token plain">            // 输出到终端</span></div><div class="token-line"><span class="token plain">            tcout &lt;&lt; str;</span></div><div class="token-line"><span class="token plain">          });</span></div><div class="token-line"><span class="token plain">      return request;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #ifdef _WIN32</span></div><div class="token-line"><span class="token plain">    int wmain(int argc, wchar_t* argv[])</span></div><div class="token-line"><span class="token plain">    #else</span></div><div class="token-line"><span class="token plain">    int main(int argc, char* argv[])</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    #ifdef _WIN32</span></div><div class="token-line"><span class="token plain">      _setmode(_fileno(stdout),</span></div><div class="token-line"><span class="token plain">               _O_WTEXT);</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      if (argc != 2) {</span></div><div class="token-line"><span class="token plain">        cerr &lt;&lt; &quot;A URL is needed\n&quot;;</span></div><div class="token-line"><span class="token plain">        return 1;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 等待请求及其关联处理全部完成</span></div><div class="token-line"><span class="token plain">      try {</span></div><div class="token-line"><span class="token plain">        auto request =</span></div><div class="token-line"><span class="token plain">          get_request(argv[1]);</span></div><div class="token-line"><span class="token plain">        request.wait();</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      // 处理请求过程中产生的异常</span></div><div class="token-line"><span class="token plain">      catch (const std::exception&amp; e) {</span></div><div class="token-line"><span class="token plain">        cerr &lt;&lt; &quot;Error exception: &quot;</span></div><div class="token-line"><span class="token plain">             &lt;&lt; e.what() &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">        return 1;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个代码有点复杂，需要讲解一下：</p><ul><li>第 14–18 行，我们根据平台来定义 <code>tcout</code>，确保多语言的文字能够正确输出。</li><li>第 20–29 行，我们定义了 <code>get_headers</code>，来从 <code>http_response</code> 中取出头部的字符串表示。</li><li>第 36 行，构造了一个客户端请求，并使用 <code>then</code> 方法串联了两个下一步的动作。<code>http_client::request</code> 的返回值是 <code>pplx::task&lt;http_response&gt;</code>。<code>then</code> 是 <code>pplx::task</code> 类模板的成员函数，参数是能接受其类型参数对象的函数对象。除了最后一个 <code>then</code> 块，其他每个 <code>then</code> 里都应该返回一个 <code>pplx::task</code>，而 <code>task</code> 的内部类型就是下一个 <code>then</code> 块里函数对象接受的参数的类型。</li><li>第 37 行开始，是第一段异步处理代码。参数类型是 <code>http_response</code>——因为<code>http_client::request</code> 的返回值是 <code>pplx::task&lt;http_response&gt;</code>。代码中判断如果响应的 HTTP 状态码不是 200 OK，就会显示响应头来帮助调试。然后，进一步取出所有的响应内容（可能需要进一步的异步处理，等待后续的 HTTP 响应到达）。</li><li>第 49 行开始，是第二段异步处理代码。参数类型是 <code>string_t</code>——因为上一段 <code>then</code> 块的返回值是 <code>pplx::task&lt;string_t&gt;</code>。代码中就是简单地把需要输出的内容输出到终端。</li><li>第 56–60 行，我们根据平台来定义合适的程序入口，确保命令行参数的正确处理。</li><li>第 62–65 行，在 Windows 上我们把标准输出设置成宽字符模式，来确保宽字符（串）能正确输出（参考<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/179357">[第 11 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ）。注意 <code>string_t</code> 在 Windows 上是 <code>wstring</code>，在其他平台上是 <code>string</code>。</li><li>第 72–83 行，如注释所言，产生 HTTP 请求、等待 HTTP 请求完成，并处理相关的异常。</li></ul><p>整体而言，这个代码还是很简单的，虽然这种代码风格，对于之前没有接触过这种函数式编程风格的人来讲会有点奇怪——这被称作持续传递风格（continuation-passing style），显式地把上一段处理的结果传递到下一个函数中。这个代码已经处理了 Windows 环境和 Unix 环境的差异，底下是相当复杂的。</p><p>另外提醒一下，在 Windows 上如果你把源代码存成 UTF-8 的话，需要确保文件以 BOM 字符打头。Windows 的编辑器通常缺省就会做到；在 Vim 里，可以通过 <code>set bomb</code> 命令做到这一点。</p><h2 id="安装和编译"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/04.实战篇/07#安装和编译"><span class="icon icon-link"></span></a>安装和编译</h2><p>上面的代码本身虽然简单，但要把它编译成可执行文件比我们之前讲的代码都要复杂——C加加 REST SDK 有外部依赖，在 Windows 上和 Unix 上还不太一样。它的编译和安装也略复杂，如果你没有这方面的经验的话，建议尽量使用平台推荐的二进制包的安装方式。</p><p>由于其依赖较多，使用它的编译命令行也较为复杂。正式项目中绝对是需要使用项目管理软件的（如 cmake）。此处，我给出手工编译的典型命令行，仅供你尝试编译上面的例子作参考。</p><p>Windows MSVC：</p><blockquote><p><code>cl /EHsc /std:C加加17 test.cpp cpprest.lib zlib.lib libeay32.lib ssleay32.lib winhttp.lib httpapi.lib bcrypt.lib crypt32.lib advapi32.lib gdi32.lib user32.lib</code></p></blockquote><p>Linux GCC：</p><blockquote><p><code>g++ \-std=C加加17 \-pthread test.cpp \-lcpprest \-lcrypto \-lssl \-lboost_thread \-lboost_chrono \-lboost_system</code></p></blockquote><p>macOS Clang：</p><blockquote><p><code>clang++ \-std=C加加17 test.cpp \-lcpprest \-lcrypto \-lssl \-lboost_thread-mt \-lboost_chrono-mt</code></p></blockquote><h2 id="概述"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/04.实战篇/07#概述"><span class="icon icon-link"></span></a>概述</h2><p>有了初步印象之后，现在我们可以回过头看看 C加加 REST SDK 到底是什么了。它是一套用来开发 HTTP 客户端和服务器的现代异步 C加加 代码库，支持以下特性（随平台不同会有所区别）：</p><ul><li>HTTP 客户端</li><li>HTTP 服务器</li><li>任务</li><li>JSON</li><li>URI</li><li>异步流</li><li>WebSocket 客户端</li><li>OAuth 客户端</li></ul><p>上面的例子里用到了 HTTP 客户端、任务和 URI（实际上是由 <code>string_t</code> 隐式构造了 <code>uri</code>），我们下面再介绍一下异步流、JSON 和 HTTP 服务器。</p><h2 id="异步流"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/04.实战篇/07#异步流"><span class="icon icon-link"></span></a>异步流</h2><p>C加加 REST SDK 里实现了一套异步流，能够实现对文件的异步读写。下面的例子展示了我们如何把网络请求的响应异步地存储到文件 results.html 中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;iostream&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;utility&gt;</span></div><div class="token-line"><span class="token plain">    #ifdef _WIN32</span></div><div class="token-line"><span class="token plain">    #include &lt;fcntl.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;io.h&gt;</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">    #include &lt;stddef.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;cpprest/http_client.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;cpprest/filestream.h&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    using namespace utility;</span></div><div class="token-line"><span class="token plain">    using namespace web::http;</span></div><div class="token-line"><span class="token plain">    using namespace web::http::client;</span></div><div class="token-line"><span class="token plain">    using namespace concurrency::streams;</span></div><div class="token-line"><span class="token plain">    using std::cerr;</span></div><div class="token-line"><span class="token plain">    using std::endl;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #ifdef _WIN32</span></div><div class="token-line"><span class="token plain">    #define tcout std::wcout</span></div><div class="token-line"><span class="token plain">    #else</span></div><div class="token-line"><span class="token plain">    #define tcout std::cout</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    auto get_headers(http_response resp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      auto headers = resp.to_string();</span></div><div class="token-line"><span class="token plain">      auto end =</span></div><div class="token-line"><span class="token plain">        headers.find(U(&quot;\r\n\r\n&quot;));</span></div><div class="token-line"><span class="token plain">      if (end != string_t::npos) {</span></div><div class="token-line"><span class="token plain">        headers.resize(end + 4);</span></div><div class="token-line"><span class="token plain">      };</span></div><div class="token-line"><span class="token plain">      return headers;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    auto get_request(string_t uri)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      http_client client{uri};</span></div><div class="token-line"><span class="token plain">      // 用 GET 方式发起一个客户端请求</span></div><div class="token-line"><span class="token plain">      auto request =</span></div><div class="token-line"><span class="token plain">        client.request(methods::GET)</span></div><div class="token-line"><span class="token plain">          .then([](http_response resp) {</span></div><div class="token-line"><span class="token plain">            if (resp.status_code() ==</span></div><div class="token-line"><span class="token plain">                status_codes::OK) {</span></div><div class="token-line"><span class="token plain">              // 正常的话</span></div><div class="token-line"><span class="token plain">              tcout &lt;&lt; U(&quot;Saving...\n&quot;);</span></div><div class="token-line"><span class="token plain">              ostream fs;</span></div><div class="token-line"><span class="token plain">              fstream::open_ostream(</span></div><div class="token-line"><span class="token plain">                U(&quot;results.html&quot;),</span></div><div class="token-line"><span class="token plain">                std::ios_base::out |</span></div><div class="token-line"><span class="token plain">                  std::ios_base::trunc)</span></div><div class="token-line"><span class="token plain">                .then(</span></div><div class="token-line"><span class="token plain">                  [&amp;fs,</span></div><div class="token-line"><span class="token plain">                   resp](ostream os) {</span></div><div class="token-line"><span class="token plain">                    fs = os;</span></div><div class="token-line"><span class="token plain">                    // 读取网页内容到流</span></div><div class="token-line"><span class="token plain">                    return resp.body()</span></div><div class="token-line"><span class="token plain">                      .read_to_end(</span></div><div class="token-line"><span class="token plain">                        fs.streambuf());</span></div><div class="token-line"><span class="token plain">                  })</span></div><div class="token-line"><span class="token plain">                .then(</span></div><div class="token-line"><span class="token plain">                  [&amp;fs](size_t size) {</span></div><div class="token-line"><span class="token plain">                    // 然后关闭流</span></div><div class="token-line"><span class="token plain">                    fs.close();</span></div><div class="token-line"><span class="token plain">                    tcout</span></div><div class="token-line"><span class="token plain">                      &lt;&lt; size</span></div><div class="token-line"><span class="token plain">                      &lt;&lt; U(&quot; bytes &quot;</span></div><div class="token-line"><span class="token plain">                           &quot;saved\n&quot;);</span></div><div class="token-line"><span class="token plain">                  })</span></div><div class="token-line"><span class="token plain">                .wait();</span></div><div class="token-line"><span class="token plain">            } else {</span></div><div class="token-line"><span class="token plain">              // 否则显示当前响应信息</span></div><div class="token-line"><span class="token plain">              auto headers =</span></div><div class="token-line"><span class="token plain">                get_headers(resp);</span></div><div class="token-line"><span class="token plain">              tcout &lt;&lt; headers;</span></div><div class="token-line"><span class="token plain">              tcout</span></div><div class="token-line"><span class="token plain">                &lt;&lt; resp.extract_string()</span></div><div class="token-line"><span class="token plain">                     .get();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">          });</span></div><div class="token-line"><span class="token plain">      return request;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #ifdef _WIN32</span></div><div class="token-line"><span class="token plain">    int wmain(int argc, wchar_t* argv[])</span></div><div class="token-line"><span class="token plain">    #else</span></div><div class="token-line"><span class="token plain">    int main(int argc, char* argv[])</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    #ifdef _WIN32</span></div><div class="token-line"><span class="token plain">      _setmode(_fileno(stdout),</span></div><div class="token-line"><span class="token plain">               _O_WTEXT);</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      if (argc != 2) {</span></div><div class="token-line"><span class="token plain">        cerr &lt;&lt; &quot;A URL is needed\n&quot;;</span></div><div class="token-line"><span class="token plain">        return 1;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 等待请求及其关联处理全部完成</span></div><div class="token-line"><span class="token plain">      try {</span></div><div class="token-line"><span class="token plain">        auto request =</span></div><div class="token-line"><span class="token plain">          get_request(argv[1]);</span></div><div class="token-line"><span class="token plain">        request.wait();</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      // 处理请求过程中产生的异常</span></div><div class="token-line"><span class="token plain">      catch (const std::exception&amp; e) {</span></div><div class="token-line"><span class="token plain">        cerr &lt;&lt; &quot;Error exception: &quot;</span></div><div class="token-line"><span class="token plain">             &lt;&lt; e.what() &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>跟上一个例子比，我们去掉了原先的第二段处理统一输出的异步处理代码，但加入了一段嵌套的异步代码。有几个地方需要注意一下：</p><ul><li>C加加 REST SDK 的对象基本都是基于 <code>shared_ptr</code> 用引用计数实现的，因而可以轻松大胆地进行复制。</li><li>虽然 <code>string_t</code> 在 Windows 上是 <code>wstring</code>，但文件流无论在哪个平台上都是以 UTF-8 的方式写入，符合目前的主流处理方式（<code>wofstream</code> 的行为跟平台和环境相关）。</li><li><code>extract_string</code> 的结果这次没有传递到下一段，而是直接用 <code>get</code> 获得了最终结果（类似于<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/186689">[第 19 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中的 <code>future</code>）。</li></ul><p>这个例子的代码是基于 <a target="_blank" rel="noopener noreferrer" href="https://github.com/Microsoft/cpprestsdk/wiki/Getting-Started-Tutorial">cpprestsdk 官方的例子<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>改编的。但我做的下面这些更动值得提一下：</p><ul><li>去除了不必要的 <code>shared_ptr</code> 的使用。</li><li><code>fstream::open_ostream</code> 缺省的文件打开方式是 <code>std::ios_base::out</code>，官方例子没有用 <code>std::ios_base::trunc</code>，导致不能清除文件中的原有内容。此处 C加加 REST SDK 的 <code>file_stream</code> 行为跟标准 C加加 的 <code>ofstream</code> 是不一样的：后者缺省打开方式也是 <code>std::ios_base::out</code>，但此时文件内容<strong>会</strong>被自动清除。</li><li>沿用我的前一个例子，先进行请求再打开文件流，而不是先打开文件流再发送网络请求，符合实际流程。</li><li>这样做的一个结果就是 <code>then</code> 不完全是顺序的了，有嵌套，增加了复杂度，但展示了实际可能的情况。</li></ul><h2 id="json-支持"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/04.实战篇/07#json-支持"><span class="icon icon-link"></span></a>JSON 支持</h2><p>在基于网页的开发中，JSON [5] 早已取代 XML 成了最主流的数据交换方式。REST 接口本身就是基于 JSON 的，自然，C加加 REST SDK 需要对 JSON 有很好的支持。</p><p>JSON 本身可以在网上找到很多介绍的文章，我这儿就不多讲了。有几个 C加加 相关的关键点需要提一下：</p><ul><li>JSON 的基本类型是空值类型、布尔类型、数字类型和字符串类型。其中空值类型和数字类型在 C加加 里是没有直接对应物的。数字类型在 C加加 里可能映射到 <code>double</code>，也可能是 <code>int32_t</code> 或 <code>int64_t</code>。</li><li>JSON 的复合类型是数组（array）和对象（object）。JSON 数组像 C加加 的 <code>vector</code>，但每个成员的类型可以是任意 JSON 类型，而不像 <code>vector</code> 通常是同质的——所有成员属于同一类型。JSON 对象像 C加加 的 <code>map</code>，键类型为 JSON 字符串，值类型则为任意 JSON 类型。JSON 标准不要求对象的各项之间有顺序，不过，从实际项目的角度，我个人觉得保持顺序还是非常有用的。</li></ul><p>如果你去搜索“C加加 json”的话，还是可以找到一些不同的 JSON 实现的。功能最完整、名声最响的目前似乎是 nlohmann/json [6]，而腾讯释出的 RapidJSON [7] 则以性能闻名 [8]。需要注意一下各个实现之间的区别：</p><ul><li>nlohmann/json 不支持对 JSON 的对象（object）保持赋值顺序；RapidJSON 保持赋值顺序；C加加 REST SDK 可选保持赋值顺序（通过 <code>web::json::keep_object_element_order</code> 和 <code>web::json::value::object</code> 的参数）。</li><li>nlohmann/json 支持最友好的初始化语法，可以使用初始化列表和 JSON 字面量；C加加 REST SDK 只能逐项初始化，并且一般应显式调用 <code>web::json::value</code> 的构造函数（接受布尔类型和字符串类型的构造函数有 <code>explicit</code> 标注）；RapidJSON 介于中间，不支持初始化列表和字面量，但赋值可以直接进行。</li><li>nlohmann/json 和 C加加 REST SDK 支持直接在用方括号 <code>[]</code> 访问不存在的 JSON 数组（array）成员时改变数组的大小；RapidJSON 的接口不支持这种用法，要向 JSON 数组里添加成员要麻烦得多。</li><li>作为性能的代价，RapidJSON 里在初始化字符串值时，只会传递指针值；用户需要保证字符串在 JSON 值使用过程中的有效性。要复制字符串的话，接口要麻烦得多。</li><li>RapidJSON 的 JSON 对象没有 <code>begin</code> 和 <code>end</code> 方法，因而无法使用标准的基于范围的 for 循环。总体而言，RapidJSON 的接口显得最特别、不通用。</li></ul><p>如果你使用 C加加 REST SDK 的其他功能，你当然也没有什么选择；否则，你可以考虑一下其他的 JSON 实现。下面，我们就只讨论 C加加 REST SDK 里的 JSON 了。</p><p>在 C加加 REST SDK 里，核心的类型是 <code>web::json::value</code>，这就对应到我前面说的“任意 JSON 类型”了。还是拿例子说话（改编自 RapidJSON 的例子）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;iostream&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;string&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;utility&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;assert.h&gt;</span></div><div class="token-line"><span class="token plain">    #ifdef _WIN32</span></div><div class="token-line"><span class="token plain">    #include &lt;fcntl.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;io.h&gt;</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">    #include &lt;cpprest/json.h&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    using namespace std;</span></div><div class="token-line"><span class="token plain">    using namespace utility;</span></div><div class="token-line"><span class="token plain">    using namespace web;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #ifdef _WIN32</span></div><div class="token-line"><span class="token plain">    #define tcout std::wcout</span></div><div class="token-line"><span class="token plain">    #else</span></div><div class="token-line"><span class="token plain">    #define tcout std::cout</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    #ifdef _WIN32</span></div><div class="token-line"><span class="token plain">      _setmode(_fileno(stdout),</span></div><div class="token-line"><span class="token plain">               _O_WTEXT);</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 测试的 JSON 字符串</span></div><div class="token-line"><span class="token plain">      string_t json_str = U(R&quot;(</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">          &quot;s&quot;: &quot;你好，世界&quot;,</span></div><div class="token-line"><span class="token plain">          &quot;t&quot;: true,</span></div><div class="token-line"><span class="token plain">          &quot;f&quot;: false,</span></div><div class="token-line"><span class="token plain">          &quot;n&quot;: null,</span></div><div class="token-line"><span class="token plain">          &quot;i&quot;: 123,</span></div><div class="token-line"><span class="token plain">          &quot;d&quot;: 3.1416,</span></div><div class="token-line"><span class="token plain">          &quot;a&quot;: [1, 2, 3]</span></div><div class="token-line"><span class="token plain">        })&quot;);</span></div><div class="token-line"><span class="token plain">      tcout &lt;&lt; &quot;Original JSON:&quot;</span></div><div class="token-line"><span class="token plain">            &lt;&lt; json_str &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 保持元素顺序并分析 JSON 字符串</span></div><div class="token-line"><span class="token plain">      json::keep_object_element_order(</span></div><div class="token-line"><span class="token plain">        true);</span></div><div class="token-line"><span class="token plain">      auto document =</span></div><div class="token-line"><span class="token plain">        json::value::parse(json_str);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 遍历对象成员并输出类型</span></div><div class="token-line"><span class="token plain">      static const char* type_names[] =</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">          &quot;Number&quot;, &quot;Boolean&quot;, &quot;String&quot;,</span></div><div class="token-line"><span class="token plain">          &quot;Object&quot;, &quot;Array&quot;,   &quot;Null&quot;,</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">      for (auto&amp;&amp; value :</span></div><div class="token-line"><span class="token plain">           document.as_object()) {</span></div><div class="token-line"><span class="token plain">        tcout &lt;&lt; &quot;Type of member &quot;</span></div><div class="token-line"><span class="token plain">              &lt;&lt; value.first &lt;&lt; &quot; is &quot;</span></div><div class="token-line"><span class="token plain">              &lt;&lt; type_names[value.second</span></div><div class="token-line"><span class="token plain">                              .type()]</span></div><div class="token-line"><span class="token plain">              &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 检查 document 是对象</span></div><div class="token-line"><span class="token plain">      assert(document.is_object());</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 检查 document[&quot;s&quot;] 是字符串</span></div><div class="token-line"><span class="token plain">      assert(document.has_field(U(&quot;s&quot;)));</span></div><div class="token-line"><span class="token plain">      assert(</span></div><div class="token-line"><span class="token plain">        document[U(&quot;s&quot;)].is_string());</span></div><div class="token-line"><span class="token plain">      tcout &lt;&lt; &quot;s = &quot;</span></div><div class="token-line"><span class="token plain">            &lt;&lt; document[U(&quot;s&quot;)] &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 检查 document[&quot;t&quot;] 是字符串</span></div><div class="token-line"><span class="token plain">      assert(</span></div><div class="token-line"><span class="token plain">        document[U(&quot;t&quot;)].is_boolean());</span></div><div class="token-line"><span class="token plain">      tcout</span></div><div class="token-line"><span class="token plain">        &lt;&lt; &quot;t = &quot;</span></div><div class="token-line"><span class="token plain">        &lt;&lt; (document[U(&quot;t&quot;)].as_bool()</span></div><div class="token-line"><span class="token plain">              ? &quot;true&quot;</span></div><div class="token-line"><span class="token plain">              : &quot;false&quot;)</span></div><div class="token-line"><span class="token plain">        &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 检查 document[&quot;f&quot;] 是字符串</span></div><div class="token-line"><span class="token plain">      assert(</span></div><div class="token-line"><span class="token plain">        document[U(&quot;f&quot;)].is_boolean());</span></div><div class="token-line"><span class="token plain">      tcout</span></div><div class="token-line"><span class="token plain">        &lt;&lt; &quot;f = &quot;</span></div><div class="token-line"><span class="token plain">        &lt;&lt; (document[U(&quot;f&quot;)].as_bool()</span></div><div class="token-line"><span class="token plain">              ? &quot;true&quot;</span></div><div class="token-line"><span class="token plain">              : &quot;false&quot;)</span></div><div class="token-line"><span class="token plain">        &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 检查 document[&quot;f&quot;] 是空值</span></div><div class="token-line"><span class="token plain">      tcout</span></div><div class="token-line"><span class="token plain">        &lt;&lt; &quot;n = &quot;</span></div><div class="token-line"><span class="token plain">        &lt;&lt; (document[U(&quot;n&quot;)].is_null()</span></div><div class="token-line"><span class="token plain">              ? &quot;null&quot;</span></div><div class="token-line"><span class="token plain">              : &quot;?&quot;)</span></div><div class="token-line"><span class="token plain">        &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 检查 document[&quot;i&quot;] 是整数</span></div><div class="token-line"><span class="token plain">      assert(</span></div><div class="token-line"><span class="token plain">        document[U(&quot;i&quot;)].is_number());</span></div><div class="token-line"><span class="token plain">      assert(</span></div><div class="token-line"><span class="token plain">        document[U(&quot;i&quot;)].is_integer());</span></div><div class="token-line"><span class="token plain">      tcout &lt;&lt; &quot;i = &quot;</span></div><div class="token-line"><span class="token plain">            &lt;&lt; document[U(&quot;i&quot;)] &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 检查 document[&quot;d&quot;] 是浮点数</span></div><div class="token-line"><span class="token plain">      assert(</span></div><div class="token-line"><span class="token plain">        document[U(&quot;d&quot;)].is_number());</span></div><div class="token-line"><span class="token plain">      assert(</span></div><div class="token-line"><span class="token plain">        document[U(&quot;d&quot;)].is_double());</span></div><div class="token-line"><span class="token plain">      tcout &lt;&lt; &quot;d = &quot;</span></div><div class="token-line"><span class="token plain">            &lt;&lt; document[U(&quot;d&quot;)] &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      {</span></div><div class="token-line"><span class="token plain">        // 检查 document[&quot;a&quot;] 是数组</span></div><div class="token-line"><span class="token plain">        auto&amp; a = document[U(&quot;a&quot;)];</span></div><div class="token-line"><span class="token plain">        assert(a.is_array());</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 测试读取数组元素并转换成整数</span></div><div class="token-line"><span class="token plain">        int y = a[0].as_integer();</span></div><div class="token-line"><span class="token plain">        (void)y;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 遍历数组成员并输出</span></div><div class="token-line"><span class="token plain">        tcout &lt;&lt; &quot;a = &quot;;</span></div><div class="token-line"><span class="token plain">        for (auto&amp;&amp; value :</span></div><div class="token-line"><span class="token plain">             a.as_array()) {</span></div><div class="token-line"><span class="token plain">          tcout &lt;&lt; value &lt;&lt; &#x27; &#x27;;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        tcout &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 修改 document[&quot;i&quot;] 为长整数</span></div><div class="token-line"><span class="token plain">      {</span></div><div class="token-line"><span class="token plain">        uint64_t bignum = 65000;</span></div><div class="token-line"><span class="token plain">        bignum *= bignum;</span></div><div class="token-line"><span class="token plain">        bignum *= bignum;</span></div><div class="token-line"><span class="token plain">        document[U(&quot;i&quot;)] = bignum;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        assert(!document[U(&quot;i&quot;)]</span></div><div class="token-line"><span class="token plain">                  .as_number()</span></div><div class="token-line"><span class="token plain">                  .is_int32());</span></div><div class="token-line"><span class="token plain">        assert(document[U(&quot;i&quot;)]</span></div><div class="token-line"><span class="token plain">                 .as_number()</span></div><div class="token-line"><span class="token plain">                 .to_uint64() ==</span></div><div class="token-line"><span class="token plain">               bignum);</span></div><div class="token-line"><span class="token plain">        tcout &lt;&lt; &quot;i is changed to &quot;</span></div><div class="token-line"><span class="token plain">              &lt;&lt; document[U(&quot;i&quot;)]</span></div><div class="token-line"><span class="token plain">              &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 在数组里添加数值</span></div><div class="token-line"><span class="token plain">      {</span></div><div class="token-line"><span class="token plain">        auto&amp; a = document[U(&quot;a&quot;)];</span></div><div class="token-line"><span class="token plain">        a[3] = 4;</span></div><div class="token-line"><span class="token plain">        a[4] = 5;</span></div><div class="token-line"><span class="token plain">        tcout &lt;&lt; &quot;a is changed to &quot;</span></div><div class="token-line"><span class="token plain">              &lt;&lt; document[U(&quot;a&quot;)]</span></div><div class="token-line"><span class="token plain">              &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 在 JSON 文档里添加布尔值：等号</span></div><div class="token-line"><span class="token plain">      // 右侧 json::value 不能省</span></div><div class="token-line"><span class="token plain">      document[U(&quot;b&quot;)] =</span></div><div class="token-line"><span class="token plain">        json::value(true);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 构造新对象，保持多个值的顺序</span></div><div class="token-line"><span class="token plain">      auto temp =</span></div><div class="token-line"><span class="token plain">        json::value::object(true);</span></div><div class="token-line"><span class="token plain">      // 在新对象里添加字符串：等号右侧</span></div><div class="token-line"><span class="token plain">      // json::value 不能省</span></div><div class="token-line"><span class="token plain">      temp[U(&quot;from&quot;)] =</span></div><div class="token-line"><span class="token plain">        json::value(U(&quot;rapidjson&quot;));</span></div><div class="token-line"><span class="token plain">      temp[U(&quot;changed for&quot;)] =</span></div><div class="token-line"><span class="token plain">        json::value(U(&quot;geekbang&quot;));</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 把对象赋到文档里；json::value</span></div><div class="token-line"><span class="token plain">      // 内部使用 unique_ptr，因而使用</span></div><div class="token-line"><span class="token plain">      // move 可以减少拷贝</span></div><div class="token-line"><span class="token plain">      document[U(&quot;adapted&quot;)] =</span></div><div class="token-line"><span class="token plain">        std::move(temp);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 完整输出目前的 JSON 对象</span></div><div class="token-line"><span class="token plain">      tcout &lt;&lt; document &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>例子里我加了不少注释，应当可以帮助你看清 JSON 对象的基本用法了。唯一遗憾的是宏 <code>U</code>（类似于<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/179357">[第 11 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 里提到过的 <code>_T</code>）的使用有点碍眼：要确保代码在 Windows 下和 Unix 下都能工作，目前这还是必要的。</p><p>建议你测试一下这个例子。查看一下结果。</p><p>C加加 REST SDK 里的 <code>http_request</code> 和 <code>http_response</code> 都对 JSON 有原生支持，如可以使用 <code>extract_json</code> 成员函数来异步提取 HTTP 请求或响应体中的 JSON 内容。</p><h2 id="http-服务器"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/04.实战篇/07#http-服务器"><span class="icon icon-link"></span></a>HTTP 服务器</h2><p>前面我们提到了如何使用 C加加 REST SDK 来快速搭建一个 HTTP 客户端。同样，我们也可以使用 C加加 REST SDK 来快速搭建一个 HTTP 服务器。在三种主流的操作系统上，C加加 REST SDK 的 <code>http_listener</code> 会通过调用 Boost.Asio [9] 和操作系统的底层接口（IOCP、epoll 或 kqueue）来完成功能，向使用者隐藏这些细节、提供一个简单的编程接口。</p><p>我们将搭建一个最小的 REST 服务器，只能处理一个 sayHi 请求。客户端应当向服务器发送一个 HTTP 请求，URI 是：</p><blockquote><p><code>/sayHi?name=…</code></p></blockquote><p>“…”部分代表一个名字，而服务器应当返回一个 JSON 的回复，形如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">{&quot;msg&quot;: &quot;Hi, …!&quot;}</span></div></pre></div><p>这个服务器的有效代码行同样只有六十多行，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;exception&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;iostream&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;map&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;string&gt;</span></div><div class="token-line"><span class="token plain">    #ifdef _WIN32</span></div><div class="token-line"><span class="token plain">    #include &lt;fcntl.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;io.h&gt;</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">    #include &lt;cpprest/http_listener.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;cpprest/json.h&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    using namespace std;</span></div><div class="token-line"><span class="token plain">    using namespace utility;</span></div><div class="token-line"><span class="token plain">    using namespace web;</span></div><div class="token-line"><span class="token plain">    using namespace web::http;</span></div><div class="token-line"><span class="token plain">    using namespace web::http::</span></div><div class="token-line"><span class="token plain">      experimental::listener;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #ifdef _WIN32</span></div><div class="token-line"><span class="token plain">    #define tcout std::wcout</span></div><div class="token-line"><span class="token plain">    #else</span></div><div class="token-line"><span class="token plain">    #define tcout std::cout</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    void handle_get(http_request req)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      auto&amp; uri = req.request_uri();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      if (uri.path() != U(&quot;/sayHi&quot;)) {</span></div><div class="token-line"><span class="token plain">        req.reply(</span></div><div class="token-line"><span class="token plain">          status_codes::NotFound);</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      tcout &lt;&lt; uri::decode(uri.query())</span></div><div class="token-line"><span class="token plain">            &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      auto query =</span></div><div class="token-line"><span class="token plain">        uri::split_query(uri.query());</span></div><div class="token-line"><span class="token plain">      auto it = query.find(U(&quot;name&quot;));</span></div><div class="token-line"><span class="token plain">      if (it == query.end()) {</span></div><div class="token-line"><span class="token plain">        req.reply(</span></div><div class="token-line"><span class="token plain">          status_codes::BadRequest,</span></div><div class="token-line"><span class="token plain">          U(&quot;Missing query info&quot;));</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      auto answer =</span></div><div class="token-line"><span class="token plain">        json::value::object(true);</span></div><div class="token-line"><span class="token plain">      answer[U(&quot;msg&quot;)] = json::value(</span></div><div class="token-line"><span class="token plain">        string_t(U(&quot;Hi, &quot;)) +</span></div><div class="token-line"><span class="token plain">        uri::decode(it-&gt;second) +</span></div><div class="token-line"><span class="token plain">        U(&quot;!&quot;));</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      req.reply(status_codes::OK,</span></div><div class="token-line"><span class="token plain">                answer);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    #ifdef _WIN32</span></div><div class="token-line"><span class="token plain">      _setmode(_fileno(stdout),</span></div><div class="token-line"><span class="token plain">               _O_WTEXT);</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      http_listener listener(</span></div><div class="token-line"><span class="token plain">        U(&quot;http://127.0.0.1:8008/&quot;));</span></div><div class="token-line"><span class="token plain">      listener.support(methods::GET,</span></div><div class="token-line"><span class="token plain">                       handle_get);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      try {</span></div><div class="token-line"><span class="token plain">        listener.open().wait();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        tcout &lt;&lt; &quot;Listening. Press &quot;</span></div><div class="token-line"><span class="token plain">                 &quot;ENTER to exit.\n&quot;;</span></div><div class="token-line"><span class="token plain">        string line;</span></div><div class="token-line"><span class="token plain">        getline(cin, line);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        listener.close().wait();</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      catch (const exception&amp; e) {</span></div><div class="token-line"><span class="token plain">        cerr &lt;&lt; e.what() &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">        return 1;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果你熟悉 HTTP 协议的话，上面的代码应当是相当直白的。只有少数几个细节我需要说明一下：</p><ul><li>我们调用 <code>http_request::reply</code> 的第二个参数是 <code>json::value</code> 类型，这会让 HTTP 的内容类型（Content-Type）自动置成“application/json”。</li><li><code>http_request::request_uri</code> 函数返回的是 <code>uri</code> 的引用，因此我用 <code>auto&amp;</code> 来接收。<code>uri::split_query</code> 函数返回的是一个普通的 <code>std::map</code>，因此我用 <code>auto</code> 来接收。</li><li><code>http_listener::open</code> 和 <code>http_listener::close</code> 返回的是 <code>pplx::task&lt;void&gt;</code>；当这个任务完成时（<code>wait</code> 调用返回），表示 HTTP 监听器上的对应操作（打开或关闭）真正完成了。</li></ul><p>运行程序，然后在另外一个终端里使用我们的第一个例子生成的可执行文件（或 curl）：</p><blockquote><p><code>curl &quot;http://127.0.0.1:8008/sayHi?name=Peter&quot;</code></p></blockquote><p>我们就应该会得到正确的结果：</p><blockquote><p><code>{<!-- -->&quot;msg&quot;:&quot;Hi, Peter!&quot;<!-- -->}</code></p></blockquote><p>你也可以尝试把路径和参数写错，查看一下程序对出错的处理。</p><h2 id="关于线程的细节"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/04.实战篇/07#关于线程的细节"><span class="icon icon-link"></span></a>关于线程的细节</h2><p>C加加 REST SDK 使用异步的编程模式，使得写不阻塞的代码变得相当容易。不过，底层它是使用一个线程池来实现的——在 C加加20 的协程能被使用之前，并没有什么更理想的跨平台方式可用。</p><p>C加加 REST SDK 缺省会开启 40 个线程。在目前的实现里，如果这些线程全部被用完了，会导致系统整体阻塞。反过来，如果你只是用 C加加 REST SDK 的 HTTP 客户端，你就不需要这么多线程。这个线程数量目前在代码里是可以控制的。比如，下面的代码会把线程池的大小设为 10：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;pplx/threadpool.h&gt;</span></div><div class="token-line"><span class="token plain">    …</span></div><div class="token-line"><span class="token plain">    crossplat::threadpool::</span></div><div class="token-line"><span class="token plain">      initialize_with_threads(10);</span></div></pre></div><p>如果你使用 C加加 REST SDK 开发一个服务器，则不仅应当增加线程池的大小，还应当对并发数量进行统计，在并发数接近线程数时主动拒绝新的连接——一般可返回 <code>status_codes::ServiceUnavailable</code>——以免造成整个系统的阻塞。</p><h2 id="内容小结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/04.实战篇/07#内容小结"><span class="icon icon-link"></span></a>内容小结</h2><p>今天我们对 C加加 REST SDK 的主要功能作了一下概要的讲解和演示，让你了解了它的主要功能和这种异步的编程方式。还有很多功能没有讲，但你应该可以通过查文档了解如何使用了。</p><p>这只能算是我们旅程中的一站——因为随着 C加加20 的到来，我相信一定会有更多好用的网络开发库出现的。</p><h2 id="课后思考"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/04.实战篇/07#课后思考"><span class="icon icon-link"></span></a>课后思考</h2><p>作为实战篇的最后一讲，内容还是略有点复杂的。如果你一下子消化不了，可以复习前面的相关内容。</p><p>如果对这讲的内容本身没有问题，则可以考虑一下，你觉得 C加加 REST SDK 的接口好用吗？如果好用，原因是什么？如果不好用，你有什么样的改进意见？</p><h2 id="参考资料"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/04.实战篇/07#参考资料"><span class="icon icon-link"></span></a>参考资料</h2><p>[1] Microsoft, cpprestsdk. <a target="_blank" rel="noopener noreferrer" href="https://github.com/microsoft/cpprestsdk">https://github.com/microsoft/cpprestsdk<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[2] Wikipedia, “Hypertext Transfer Protocol”. <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[2a] 维基百科, “超文本传输协议”. <a target="_blank" rel="noopener noreferrer" href="https://zh.m.wikipedia.org/zh-hans/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">https://zh.m.wikipedia.org/zh-hans/超文本传输协议<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[3] RESTful. <a target="_blank" rel="noopener noreferrer" href="https://restfulapi.net/">https://restfulapi.net/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[4] curl. <a target="_blank" rel="noopener noreferrer" href="https://curl.haxx.se/">https://curl.haxx.se/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[5] JSON. <a target="_blank" rel="noopener noreferrer" href="https://www.json.org/">https://www.json.org/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[6] Niels Lohmann, json. <a target="_blank" rel="noopener noreferrer" href="https://github.com/nlohmann/json">https://github.com/nlohmann/json<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[7] Tencent, rapidjson. <a target="_blank" rel="noopener noreferrer" href="https://github.com/Tencent/rapidjson">https://github.com/Tencent/rapidjson<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[8] Milo Yip, nativejson-benchmark. <a target="_blank" rel="noopener noreferrer" href="https://github.com/miloyip/nativejson-benchmark">https://github.com/miloyip/nativejson-benchmark<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[9] Christopher Kohlhoff, Boost.Asio. <a target="_blank" rel="noopener noreferrer" href="https://www.boost.org/doc/libs/release/doc/html/boost_asio.html">https://www.boost.org/doc/libs/release/doc/html/boost_asio.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/现代c编程实战/04.实战篇/07.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
