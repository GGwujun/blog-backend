<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>15 | constexpr：一个常态的世界 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/现代c编程实战/03.提高篇/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/现代c编程实战/01.课前必读">01.课前必读</a><ul><li><a href="/blog-backend/现代c编程实战/01.课前必读/01"><span>开篇词 | C加加这么难，为什么我们还要用C加加？</span></a></li><li><a href="/blog-backend/现代c编程实战/01.课前必读/02"><span>课前必读 | 有关术语发音及环境要求</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/02.基础篇">02.基础篇</a><ul><li><a href="/blog-backend/现代c编程实战/02.基础篇/01"><span>01 | 堆、栈、RAII：C加加里该如何管理资源？</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/02"><span>02 | 自己动手，实现C加加的智能指针</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/03"><span>03 | 右值和移动究竟解决了什么问题？</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/04"><span>04 | 容器汇编 I：比较简单的若干容器</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/05"><span>05 | 容器汇编 II：需要函数对象的容器</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/06"><span>06 | 异常：用还是不用，这是个问题</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/07"><span>07 | 迭代器和好用的新for循环</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/08"><span>08 | 易用性改进 I：自动类型推断和初始化</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/09"><span>09 | 易用性改进 II：字面量、静态断言和成员函数说明符</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战/03.提高篇">03.提高篇</a><ul><li><a href="/blog-backend/现代c编程实战/03.提高篇/01"><span>10 | 到底应不应该返回对象？</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/02"><span>11 | Unicode：进入多文字支持的世界</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/03"><span>12 | 编译期多态：泛型编程和模板入门</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/04"><span>13 | 编译期能做些什么？一个完整的计算世界</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/05"><span>14 | SFINAE：不是错误的替换失败是怎么回事?</span></a></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战/03.提高篇/06"><span>15 | constexpr：一个常态的世界</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/07"><span>16 | 函数对象和lambda：进入函数式编程</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/08"><span>17 | 函数式编程：一种越来越流行的编程范式</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/09"><span>18 | 应用可变模板和tuple的编译期技巧</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/10"><span>19 | thread和future：领略异步中的未来</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/11"><span>20 | 内存模型和atomic：理解并发的复杂性</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/04.实战篇">04.实战篇</a><ul><li><a href="/blog-backend/现代c编程实战/04.实战篇/01"><span>21 | 工具漫谈：编译、格式化、代码检查、排错各显身手</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/02"><span>22 | 处理数据类型变化和错误：optional、variant、expected和Herbception</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/03"><span>23 | 数字计算：介绍线性代数和数值计算库</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/04"><span>24 | Boost：你需要的“瑞士军刀”</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/05"><span>25 | 两个单元测试库：C加加里如何进行单元测试?</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/06"><span>26 | Easylogging++和spdlog：两个好用的日志库</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/07"><span>27 | C加加 REST SDK：使用现代C开发网络应用</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/05.新年特别策划">05.新年特别策划</a><ul><li><a href="/blog-backend/现代c编程实战/05.新年特别策划/01"><span>新春寄语 | 35年码龄程序员：人生漫长，走点弯路在所难免</span></a></li><li><a href="/blog-backend/现代c编程实战/05.新年特别策划/02"><span>新春福利 | C加加好书荐读</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/06.未来篇">06.未来篇</a><ul><li><a href="/blog-backend/现代c编程实战/06.未来篇/01"><span>28 | Concepts：如何对模板进行约束?</span></a></li><li><a href="/blog-backend/现代c编程实战/06.未来篇/02"><span>29 | Ranges：无迭代器的迭代和更方便的组合</span></a></li><li><a href="/blog-backend/现代c编程实战/06.未来篇/03"><span>30 | Coroutines：协作式的交叉调度执行</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/07.加餐">07.加餐</a><ul><li><a href="/blog-backend/现代c编程实战/07.加餐/01"><span>加餐 | 部分课后思考题答案合集</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/08.结束语">08.结束语</a><ul><li><a href="/blog-backend/现代c编程实战/08.结束语/01"><span>结束语 | 终点已达，行程还要继续</span></a></li><li><a href="/blog-backend/现代c编程实战/08.结束语/02"><span>结课问卷获奖用户名单</span></a></li><li><a href="/blog-backend/现代c编程实战/08.结束语/03"><span>第二季回归｜拿下Vim，让编程效率神器为我所用</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/09.期末测试">09.期末测试</a><ul><li><a href="/blog-backend/现代c编程实战/09.期末测试/01"><span>期末测试 | 对于现代C，你掌握了多少呢？</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/10.增补篇">10.增补篇</a><ul><li><a href="/blog-backend/现代c编程实战/10.增补篇/01"><span>旅程再启｜那些关于C加加的新认知</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/02"><span>31｜new和delete背后：分配函数和释放函数</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/03"><span>32｜容器里的内存管理：分配器</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/04"><span>33｜性能测试的正确姿势：性能、时间和优化</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/05"><span>34｜快速分配和释放内存：内存池</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/06"><span>35 | 发现和识别内存问题：内存调试实践</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/07"><span>36｜访问对象的代理对象：视图类型</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/summary">现代c编程实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="初识 constexpr" data-depth="2"><a href="/blog-backend/现代c编程实战/03.提高篇/06#初识-constexpr"><span>初识 constexpr</span></a></li><li title="constexpr 和编译期计算" data-depth="2"><a href="/blog-backend/现代c编程实战/03.提高篇/06#constexpr-和编译期计算"><span>constexpr 和编译期计算</span></a></li><li title="constexpr 和 const" data-depth="2"><a href="/blog-backend/现代c编程实战/03.提高篇/06#constexpr-和-const"><span>constexpr 和 const</span></a></li><li title="内联变量" data-depth="3"><a href="/blog-backend/现代c编程实战/03.提高篇/06#内联变量"><span>内联变量</span></a></li><li title="constexpr 变量模板" data-depth="3"><a href="/blog-backend/现代c编程实战/03.提高篇/06#constexpr-变量模板"><span>constexpr 变量模板</span></a></li><li title="constexpr 变量仍是 const" data-depth="3"><a href="/blog-backend/现代c编程实战/03.提高篇/06#constexpr-变量仍是-const"><span>constexpr 变量仍是 const</span></a></li><li title="constexpr 构造函数和字面类型" data-depth="2"><a href="/blog-backend/现代c编程实战/03.提高篇/06#constexpr-构造函数和字面类型"><span>constexpr 构造函数和字面类型</span></a></li><li title="if constexpr" data-depth="2"><a href="/blog-backend/现代c编程实战/03.提高篇/06#if-constexpr"><span>if constexpr</span></a></li><li title="output_container.h 解读" data-depth="2"><a href="/blog-backend/现代c编程实战/03.提高篇/06#output_containerh-解读"><span>output_container.h 解读</span></a></li><li title="内容小结" data-depth="2"><a href="/blog-backend/现代c编程实战/03.提高篇/06#内容小结"><span>内容小结</span></a></li><li title="课后思考" data-depth="2"><a href="/blog-backend/现代c编程实战/03.提高篇/06#课后思考"><span>课后思考</span></a></li><li title="参考资料" data-depth="2"><a href="/blog-backend/现代c编程实战/03.提高篇/06#参考资料"><span>参考资料</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="15--constexpr一个常态的世界"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/06#15--constexpr一个常态的世界"><span class="icon icon-link"></span></a>15 | constexpr：一个常态的世界</h1><p>你好，我是吴咏炜。</p><p>我们已经连续讲了几讲比较累人的编译期编程了。今天我们还是继续这个话题，但是，相信今天学完之后，你会感觉比之前几讲要轻松很多。C加加 语言里的很多改进，让我们做编译期编程也变得越来越简单了。</p><h2 id="初识-constexpr"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/06#初识-constexpr"><span class="icon icon-link"></span></a>初识 constexpr</h2><p>我们先来看一些例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int sqr(int n)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      return n * n;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      int a[sqr(3)];</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>想一想，这个代码合法吗？</p><p>看过之后，再想想这个代码如何？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int sqr(int n)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      return n * n;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      const int n = sqr(3);</span></div><div class="token-line"><span class="token plain">      int a[n];</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>还有这个？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;array&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int sqr(int n)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      return n * n;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      std::array&lt;int, sqr(3)&gt; a;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>此外，我们前面模板元编程里的那些类里的 <code>static const int</code> 什么的，你认为它们能用在上面的几种情况下吗？</p><p>如果以上问题你都知道正确的答案，那恭喜你，你对 C加加 的理解已经到了一个不错的层次了。但问题依然在那里：这些问题的答案不直观。并且，我们需要一个比模板元编程更方便的进行编译期计算的方法。</p><p>在 C加加11 引入、在 C加加14 得到大幅改进的 <code>constexpr</code> 关键字就是为了解决这些问题而诞生的。它的字面意思是 constant expression，常量表达式。存在两类 <code>constexpr</code> 对象：</p><ul><li><code>constexpr</code> 变量（唉……😓）</li><li><code>constexpr</code> 函数</li></ul><p>一个 <code>constexpr</code> 变量是一个编译时完全确定的常数。一个 <code>constexpr</code> 函数至少对于某一组实参可以在编译期间产生一个编译期常数。</p><p>注意一个 <code>constexpr</code> 函数不保证在所有情况下都会产生一个编译期常数（因而也是可以作为普通函数来使用的）。编译器也没法通用地检查这点。编译器唯一强制的是：</p><ul><li><code>constexpr</code> 变量必须立即初始化</li><li>初始化只能使用字面量或常量表达式，后者不允许调用任何非 <code>constexpr</code> 函数</li></ul><p><code>constexpr</code> 的实际规则当然稍微更复杂些，而且随着 C加加 标准的演进也有着一些变化，特别是对 <code>constexpr</code> 函数如何实现的要求在慢慢放宽。要了解具体情况包括其在不同 C加加 标准中的限制，可以查看参考资料 [1]。下面我们也会回到这个问题略作展开。</p><p>拿 <code>constexpr</code> 来改造开头的例子，下面的代码就完全可以工作了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;array&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    constexpr int sqr(int n)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      return n * n;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      constexpr int n = sqr(3);</span></div><div class="token-line"><span class="token plain">      std::array&lt;int, n&gt; a;</span></div><div class="token-line"><span class="token plain">      int b[n];</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>要检验一个 <code>constexpr</code> 函数能不能产生一个真正的编译期常量，可以把结果赋给一个 <code>constexpr</code> 变量。成功的话，我们就确认了，至少在这种调用情况下，我们能真正得到一个编译期常量。</p><h2 id="constexpr-和编译期计算"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/06#constexpr-和编译期计算"><span class="icon icon-link"></span></a>constexpr 和编译期计算</h2><p>上面这些当然有点用。但如果只有这点用的话，就不值得我专门来写一讲了。更强大的地方在于，使用编译期常量，就跟我们之前的那些类模板里的 <code>static const int</code> 变量一样，是可以进行编译期计算的。</p><p>以<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/181608">[第 13 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 提到的阶乘函数为例，和那个版本基本等价的写法是：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">constexpr int factorial(int n)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      if (n == 0) {</span></div><div class="token-line"><span class="token plain">        return 1;</span></div><div class="token-line"><span class="token plain">      } else {</span></div><div class="token-line"><span class="token plain">        return n * factorial(n - 1);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然后，我们用下面的代码可以验证我们确实得到了一个编译期常量：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int main()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      constexpr int n = factorial(10);</span></div><div class="token-line"><span class="token plain">      printf(&quot;%d\n&quot;, n);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>编译可以通过，同时，如果我们看产生的汇编代码的话，一样可以直接看到常量 3628800。</p><p>这里有一个问题：在这个 <code>constexpr</code> 函数里，是不能写 <code>static_assert(n &gt;= 0)</code> 的。一个 <code>constexpr</code> 函数仍然可以作为普通函数使用——显然，传入一个普通 <code>int</code> 是不能使用静态断言的。替换方法是在 <code>factorial</code> 的实现开头加入：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if (n &lt; 0) {</span></div><div class="token-line"><span class="token plain">        throw std::invalid_argument(</span></div><div class="token-line"><span class="token plain">          &quot;Arg must be non-negative&quot;);</span></div><div class="token-line"><span class="token plain">      }</span></div></pre></div><p>如果你在 <code>main</code> 里写 <code>constexpr int n = factorial(-1);</code> 的话，就会看到编译器报告抛出异常导致无法得到一个常量表达式。建议你自己尝试一下。</p><h2 id="constexpr-和-const"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/06#constexpr-和-const"><span class="icon icon-link"></span></a>constexpr 和 const</h2><p>初学 <code>constexpr</code> 时，一个很可能有的困惑是，它跟 <code>const</code> 用法上的区别到底是什么。产生这种困惑是正常的，毕竟 <code>const</code> 是个重载了很多不同含义的关键字。</p><p><code>const</code> 的原本和基础的含义，自然是表示它修饰的内容不会变化，如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const int n = 1:</span></div><div class="token-line"><span class="token plain">    n = 2;  // 出错！</span></div></pre></div><p>注意 <code>const</code> 在类型声明的不同位置会产生不同的结果。对于常见的 <code>const char*</code> 这样的类型声明，意义和 <code>char const*</code> 相同，是指向常字符的指针，指针指向的内容不可更改；但和 <code>char * const</code> 不同，那代表指向字符的常指针，指针本身不可更改。本质上，<code>const</code> 用来表示一个<strong>运行时常量</strong>。</p><p>在 C加加 里，<code>const</code> 后面渐渐带上了现在的 <code>constexpr</code> 用法，也代表<strong>编译期常数</strong>。现在——在有了 <code>constexpr</code> 之后——我们应该使用 <code>constexpr</code> 在这些用法中替换 <code>const</code> 了。从编译器的角度，为了向后兼容性，<code>const</code> 和 <code>constexpr</code> 在很多情况下还是等价的。但有时候，它们也有些细微的区别，其中之一为是否内联的问题。</p><h3 id="内联变量"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/06#内联变量"><span class="icon icon-link"></span></a>内联变量</h3><p>C加加17 引入了内联（inline）变量的概念，允许在头文件中定义内联变量，然后像内联函数一样，只要所有的定义都相同，那变量的定义出现多次也没有关系。对于类的静态数据成员，<code>const</code> 缺省是不内联的，而 <code>constexpr</code> 缺省就是内联的。这种区别在你用 <code>&amp;</code> 去取一个 <code>const int</code> 值的地址、或将其传到一个形参类型为 <code>const int&amp;</code> 的函数去的时候（这在 C加加 文档里的行话叫 ODR-use），就会体现出来。</p><p>下面是个合法的完整程序：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;iostream&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct magic {</span></div><div class="token-line"><span class="token plain">      static const int number = 42;</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      std::cout &lt;&lt; magic::number</span></div><div class="token-line"><span class="token plain">                &lt;&lt; std::endl;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们稍微改一点：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;iostream&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;vector&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct magic {</span></div><div class="token-line"><span class="token plain">      static const int number = 42;</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      std::vector&lt;int&gt; v;</span></div><div class="token-line"><span class="token plain">      // 调用 push_back(const T&amp;)</span></div><div class="token-line"><span class="token plain">      v.push_back(magic::number);</span></div><div class="token-line"><span class="token plain">      std::cout &lt;&lt; v[0] &lt;&lt; std::endl;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>程序在链接时就会报错了，说找不到 <code>magic::number</code>（注意：MSVC 缺省不报错，但使用标准模式——<code>/Za</code> 命令行选项——也会出现这个问题）。这是因为 ODR-use 的类静态常量也需要有一个定义，在没有内联变量之前需要在某一个源代码文件（非头文件）中这样写：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const int magic::number = 42;</span></div></pre></div><p>必须正正好好一个，多了少了都不行，所以叫 one definition rule。内联函数，现在又有了内联变量，以及模板，则不受这条规则限制。</p><p>修正这个问题的简单方法是把 <code>magic</code> 里的 <code>static const</code> 改成 <code>static constexpr</code> 或 <code>static inline const</code>。前者可行的原因是，类的静态 constexpr 成员变量默认就是内联的。const 常量和类外面的 constexpr 变量不默认内联，需要手工加 <code>inline</code> 关键字才会变成内联。</p><h3 id="constexpr-变量模板"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/06#constexpr-变量模板"><span class="icon icon-link"></span></a>constexpr 变量模板</h3><p>变量模板是 C加加14 引入的新概念。之前我们需要用类静态数据成员来表达的东西，使用变量模板可以更简洁地表达。<code>constexpr</code> 很合适用在变量模板里，表达一个和某个类型相关的编译期常量。由此，type traits 都获得了一种更简单的表示方式。再看一下我们在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/181608">[第 13 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 用过的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;class T&gt;</span></div><div class="token-line"><span class="token plain">    inline constexpr bool</span></div><div class="token-line"><span class="token plain">      is_trivially_destructible_v =</span></div><div class="token-line"><span class="token plain">        is_trivially_destructible&lt;</span></div><div class="token-line"><span class="token plain">          T&gt;::value;</span></div></pre></div><p>了解了变量也可以是模板之后，上面这个代码就很容易看懂了吧？这只是一个小小的语法糖，允许我们把 <code>is_trivially_destructible&lt;T&gt;::value</code> 写成 <code>is_trivially_destructible_v&lt;T&gt;</code>。</p><h3 id="constexpr-变量仍是-const"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/06#constexpr-变量仍是-const"><span class="icon icon-link"></span></a>constexpr 变量仍是 const</h3><p>一个 <code>constexpr</code> 变量仍然是 const 常类型。需要注意的是，就像 <code>const char*</code> 类型是指向常量的指针、自身不是 const 常量一样，下面这个表达式里的 <code>const</code> 也是不能缺少的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">constexpr int a = 42;</span></div><div class="token-line"><span class="token plain">    constexpr const int&amp; b = a;</span></div></pre></div><p>第二行里，<code>constexpr</code> 表示 <code>b</code> 是一个编译期常量，<code>const</code> 表示这个引用是常量引用。去掉这个 <code>const</code> 的话，编译器就会认为你是试图将一个普通引用绑定到一个常数上，报一个类似下面的错误信息：</p><blockquote><p><strong>error:</strong> binding reference of type ‘<strong>int&amp;</strong>’ to ‘<strong>const int</strong>’ discards qualifiers</p></blockquote><p>如果按照 const 位置的规则，<code>constexpr const int&amp; b</code> 实际该写成 <code>const int&amp; constexpr b</code>。不过，<code>constexpr</code> 不需要像 <code>const</code> 一样有复杂的组合，因此永远是写在类型前面的。</p><h2 id="constexpr-构造函数和字面类型"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/06#constexpr-构造函数和字面类型"><span class="icon icon-link"></span></a>constexpr 构造函数和字面类型</h2><p>一个合理的 <code>constexpr</code> 函数，应当至少对于某一组编译期常量的输入，能得到编译期常量的结果。为此，对这个函数也是有些限制的：</p><ul><li>最早，<code>constexpr</code> 函数里连循环都不能有，但在 C加加14 放开了。</li><li>目前，<code>constexpr</code> 函数仍不能有 <code>try … catch</code> 语句和 <code>asm</code> 声明，但到 C加加20 会放开。</li><li><code>constexpr</code> 函数里不能使用 <code>goto</code> 语句。</li><li>等等。</li></ul><p>一个有意思的情况是一个类的构造函数。如果一个类的构造函数里面只包含常量表达式、满足对 <code>constexpr</code> 函数的限制的话（这也意味着，里面不可以有任何动态内存分配），并且类的析构函数是平凡的，那这个类就可以被称为是一个字面类型。换一个角度想，对 <code>constexpr</code> 函数——包括字面类型构造函数——的要求是，得让编译器能在编译期进行计算，而不会产生任何“副作用”，比如内存分配、输入、输出等等。</p><p>为了全面支持编译期计算，C加加14 开始，很多标准类的构造函数和成员函数已经被标为 <code>constexpr</code>，以便在编译期使用。当然，大部分的容器类，因为用到了动态内存分配，不能成为字面类型。下面这些不使用动态内存分配的字面类型则可以在常量表达式中使用：</p><ul><li><code>array</code></li><li><code>initializer_list</code></li><li><code>pair</code></li><li><code>tuple</code></li><li><code>string_view</code></li><li><code>optional</code></li><li><code>variant</code></li><li><code>bitset</code></li><li><code>complex</code></li><li><code>chrono::duration</code></li><li><code>chrono::time_point</code></li><li>…</li></ul><p>下面这个玩具例子，可以展示上面的若干类及其成员函数的行为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;array&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;iostream&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;memory&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;string_view&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    using namespace std;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      constexpr string_view sv{&quot;hi&quot;};</span></div><div class="token-line"><span class="token plain">      constexpr pair pr{sv[0], sv[1]};</span></div><div class="token-line"><span class="token plain">      constexpr array a{pr.first, pr.second};</span></div><div class="token-line"><span class="token plain">      constexpr int n1 = a[0];</span></div><div class="token-line"><span class="token plain">      constexpr int n2 = a[1];</span></div><div class="token-line"><span class="token plain">      cout &lt;&lt; n1 &lt;&lt; &#x27; &#x27; &lt;&lt; n2 &lt;&lt; &#x27;\n&#x27;;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>编译器可以在编译期即决定 <code>n1</code> 和 <code>n2</code> 的数值；从最后结果的角度，上面程序就是输出了两个整数而已。</p><h2 id="if-constexpr"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/06#if-constexpr"><span class="icon icon-link"></span></a>if constexpr</h2><p>上一讲的结尾，我们给出了一个在类型参数 <code>C</code> 没有 <code>reserve</code> 成员函数时不能编译的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;typename C, typename T&gt;</span></div><div class="token-line"><span class="token plain">    void append(C&amp; container, T* ptr,</span></div><div class="token-line"><span class="token plain">                size_t size)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      if (has_reserve&lt;C&gt;::value) {</span></div><div class="token-line"><span class="token plain">        container.reserve(</span></div><div class="token-line"><span class="token plain">          container.size() + size);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      for (size_t i = 0; i &lt; size;</span></div><div class="token-line"><span class="token plain">           ++i) {</span></div><div class="token-line"><span class="token plain">        container.push_back(ptr[i]);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在 C加加17 里，我们只要在 <code>if</code> 后面加上 <code>constexpr</code>，代码就能工作了 [2]。当然，它要求括号里的条件是个编译期常量。满足这个条件后，标签分发、<code>enable_if</code> 那些技巧就不那么有用了。显然，使用 <code>if constexpr</code> 能比使用其他那些方式，写出更可读的代码……</p><h2 id="output_containerh-解读"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/06#output_containerh-解读"><span class="icon icon-link"></span></a>output_container.h 解读</h2><p>到了今天，我们终于把 output_container.h（[3]）用到的 C加加 语法特性都讲过了，我们就拿里面的代码来讲解一下，让你加深对这些特性的理解。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Type trait to detect std::pair</span></div><div class="token-line"><span class="token plain">    template &lt;typename T&gt;</span></div><div class="token-line"><span class="token plain">    struct is_pair : std::false_type {};</span></div><div class="token-line"><span class="token plain">    template &lt;typename T, typename U&gt;</span></div><div class="token-line"><span class="token plain">    struct is_pair&lt;std::pair&lt;T, U&gt;&gt;</span></div><div class="token-line"><span class="token plain">      : std::true_type {};</span></div><div class="token-line"><span class="token plain">    template &lt;typename T&gt;</span></div><div class="token-line"><span class="token plain">    inline constexpr bool is_pair_v =</span></div><div class="token-line"><span class="token plain">      is_pair&lt;T&gt;::value;</span></div></pre></div><p>这段代码利用模板特化（<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/179363">[第 12 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 、<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/181636">[第 14 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）和 <code>false_type</code>、<code>true_type</code> 类型（<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/181608">[第 13 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），定义了 <code>is_pair</code>，用来检测一个类型是不是 <code>pair</code>。随后，我们定义了内联 <code>constexpr</code> 变量（本讲）<code>is_pair_v</code>，用来简化表达。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Type trait to detect whether an</span></div><div class="token-line"><span class="token plain">    // output function already exists</span></div><div class="token-line"><span class="token plain">    template &lt;typename T&gt;</span></div><div class="token-line"><span class="token plain">    struct has_output_function {</span></div><div class="token-line"><span class="token plain">      template &lt;class U&gt;</span></div><div class="token-line"><span class="token plain">      static auto output(U* ptr)</span></div><div class="token-line"><span class="token plain">        -&gt; decltype(</span></div><div class="token-line"><span class="token plain">          std::declval&lt;std::ostream&amp;&gt;()</span></div><div class="token-line"><span class="token plain">            &lt;&lt; *ptr,</span></div><div class="token-line"><span class="token plain">          std::true_type());</span></div><div class="token-line"><span class="token plain">      template &lt;class U&gt;</span></div><div class="token-line"><span class="token plain">      static std::false_type</span></div><div class="token-line"><span class="token plain">      output(...);</span></div><div class="token-line"><span class="token plain">      static constexpr bool value =</span></div><div class="token-line"><span class="token plain">        decltype(</span></div><div class="token-line"><span class="token plain">          output&lt;T&gt;(nullptr))::value;</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    template &lt;typename T&gt;</span></div><div class="token-line"><span class="token plain">    inline constexpr bool</span></div><div class="token-line"><span class="token plain">      has_output_function_v =</span></div><div class="token-line"><span class="token plain">        has_output_function&lt;T&gt;::value;</span></div></pre></div><p>这段代码使用 SFINAE 技巧（<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/181636">[第 14 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），来检测模板参数 <code>T</code> 的对象是否已经可以直接输出到 <code>ostream</code>。然后，一样用一个内联 <code>constexpr</code> 变量来简化表达。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Output function for std::pair</span></div><div class="token-line"><span class="token plain">    template &lt;typename T, typename U&gt;</span></div><div class="token-line"><span class="token plain">    std::ostream&amp; operator&lt;&lt;(</span></div><div class="token-line"><span class="token plain">      std::ostream&amp; os,</span></div><div class="token-line"><span class="token plain">      const std::pair&lt;T, U&gt;&amp; pr);</span></div></pre></div><p>再然后我们声明了一个 <code>pair</code> 的输出函数（标准库没有提供这个功能）。我们这儿只是声明，是因为我们这儿有两个输出函数，且可能互相调用。所以，我们要先声明其中之一。</p><p>下面会看到，<code>pair</code> 的通用输出形式是“(x, y)”。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Element output function for</span></div><div class="token-line"><span class="token plain">    // containers that define a key_type</span></div><div class="token-line"><span class="token plain">    // and have its value type as</span></div><div class="token-line"><span class="token plain">    // std::pair</span></div><div class="token-line"><span class="token plain">    template &lt;typename T, typename Cont&gt;</span></div><div class="token-line"><span class="token plain">    auto output_element(</span></div><div class="token-line"><span class="token plain">      std::ostream&amp; os,</span></div><div class="token-line"><span class="token plain">      const T&amp; element, const Cont&amp;,</span></div><div class="token-line"><span class="token plain">      const std::true_type)</span></div><div class="token-line"><span class="token plain">      -&gt; decltype(</span></div><div class="token-line"><span class="token plain">        std::declval&lt;</span></div><div class="token-line"><span class="token plain">          typename Cont::key_type&gt;(),</span></div><div class="token-line"><span class="token plain">        os);</span></div><div class="token-line"><span class="token plain">    // Element output function for other</span></div><div class="token-line"><span class="token plain">    // containers</span></div><div class="token-line"><span class="token plain">    template &lt;typename T, typename Cont&gt;</span></div><div class="token-line"><span class="token plain">    auto output_element(</span></div><div class="token-line"><span class="token plain">      std::ostream&amp; os,</span></div><div class="token-line"><span class="token plain">      const T&amp; element, const Cont&amp;,</span></div><div class="token-line"><span class="token plain">      ...) -&gt; decltype(os);</span></div></pre></div><p>对于容器成员的输出，我们也声明了两个不同的重载。我们的意图是，如果元素的类型是 <code>pair</code> 并且容器定义了一个 <code>key_type</code> 类型，我们就认为遇到了关联容器，输出形式为“x =&gt; y”（而不是“(x, y)”）。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Main output function, enabled</span></div><div class="token-line"><span class="token plain">    // only if no output function</span></div><div class="token-line"><span class="token plain">    // already exists</span></div><div class="token-line"><span class="token plain">    template &lt;</span></div><div class="token-line"><span class="token plain">      typename T,</span></div><div class="token-line"><span class="token plain">      typename = std::enable_if_t&lt;</span></div><div class="token-line"><span class="token plain">        !has_output_function_v&lt;T&gt;&gt;&gt;</span></div><div class="token-line"><span class="token plain">    auto operator&lt;&lt;(std::ostream&amp; os,</span></div><div class="token-line"><span class="token plain">                    const T&amp; container)</span></div><div class="token-line"><span class="token plain">      -&gt; decltype(container.begin(),</span></div><div class="token-line"><span class="token plain">                  container.end(), os)</span></div><div class="token-line"><span class="token plain">    …</span></div></pre></div><p>主输出函数的定义。注意这儿这个函数的启用有两个不同的 SFINAE 条件：</p><ul><li>用 <code>decltype</code> 返回值的方式规定了被输出的类型必须有 <code>begin()</code> 和 <code>end()</code> 成员函数。</li><li>用 <code>enable_if_t</code> 规定了只在被输出的类型没有输出函数时才启用这个输出函数。否则，对于 <code>string</code> 这样的类型，编译器发现有两个可用的输出函数，就会导致编译出错。</li></ul><p>我们可以看到，用 <code>decltype</code> 返回值的方式比较简单，不需要定义额外的模板。但表达否定的条件还是要靠 <code>enable_if</code>。此外，因为此处是需要避免有二义性的重载，constexpr 条件语句帮不了什么忙。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">using element_type =</span></div><div class="token-line"><span class="token plain">        decay_t&lt;decltype(</span></div><div class="token-line"><span class="token plain">          *container.begin())&gt;;</span></div><div class="token-line"><span class="token plain">      constexpr bool is_char_v =</span></div><div class="token-line"><span class="token plain">        is_same_v&lt;element_type, char&gt;;</span></div><div class="token-line"><span class="token plain">      if constexpr (!is_char_v) {</span></div><div class="token-line"><span class="token plain">        os &lt;&lt; &quot;{ &quot;;</span></div><div class="token-line"><span class="token plain">      }</span></div></pre></div><p>对非字符类型，我们在开始输出时，先输出“<!-- -->{<!-- --> ”。这儿使用了 <code>decay_t</code>，是为了把类型里的引用和 const/volatile 修饰去掉，只剩下值类型。如果容器里的成员是 <code>char</code>，这儿会把 <code>char&amp;</code> 和 <code>const char&amp;</code> 还原成 <code>char</code>。</p><p>后面的代码就比较简单了。可能唯一需要留意的是下面这句：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">output_element(</span></div><div class="token-line"><span class="token plain">        os, *it, container,</span></div><div class="token-line"><span class="token plain">        is_pair&lt;element_type&gt;());</span></div></pre></div><p>这儿我们使用了标签分发技巧来输出容器里的元素。要记得，<code>output_element</code> 不纯粹使用标签分发，还会检查容器是否有 <code>key_type</code> 成员类型。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;typename T, typename Cont&gt;</span></div><div class="token-line"><span class="token plain">    auto output_element(</span></div><div class="token-line"><span class="token plain">      std::ostream&amp; os,</span></div><div class="token-line"><span class="token plain">      const T&amp; element, const Cont&amp;,</span></div><div class="token-line"><span class="token plain">      const std::true_type)</span></div><div class="token-line"><span class="token plain">      -&gt; decltype(</span></div><div class="token-line"><span class="token plain">        std::declval&lt;</span></div><div class="token-line"><span class="token plain">          typename Cont::key_type&gt;(),</span></div><div class="token-line"><span class="token plain">        os)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      os &lt;&lt; element.first &lt;&lt; &quot; =&gt; &quot;</span></div><div class="token-line"><span class="token plain">         &lt;&lt; element.second;</span></div><div class="token-line"><span class="token plain">      return os;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    template &lt;typename T, typename Cont&gt;</span></div><div class="token-line"><span class="token plain">    auto output_element(</span></div><div class="token-line"><span class="token plain">      std::ostream&amp; os,</span></div><div class="token-line"><span class="token plain">      const T&amp; element, const Cont&amp;,</span></div><div class="token-line"><span class="token plain">      ...) -&gt; decltype(os)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      os &lt;&lt; element;</span></div><div class="token-line"><span class="token plain">      return os;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><code>output_element</code> 的两个重载的实现都非常简单，应该不需要解释了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;typename T, typename U&gt;</span></div><div class="token-line"><span class="token plain">    std::ostream&amp; operator&lt;&lt;(</span></div><div class="token-line"><span class="token plain">      std::ostream&amp; os,</span></div><div class="token-line"><span class="token plain">      const std::pair&lt;T, U&gt;&amp; pr)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      os &lt;&lt; &#x27;(&#x27; &lt;&lt; pr.first &lt;&lt; &quot;, &quot;</span></div><div class="token-line"><span class="token plain">         &lt;&lt; pr.second &lt;&lt; &#x27;)&#x27;;</span></div><div class="token-line"><span class="token plain">      return os;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>同样，<code>pair</code> 的输出的实现也非常简单。</p><p>唯一需要留意的，是上面三个函数的输出内容可能还是容器，因此我们要将其实现放在后面，确保它能看到我们的通用输出函数。</p><p>要看一下用到 output_container 的例子，可以回顾<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/173167">[第 4 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/174434">[第 5 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><h2 id="内容小结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/06#内容小结"><span class="icon icon-link"></span></a>内容小结</h2><p>本讲我们介绍了编译期常量表达式和编译期条件语句，可以看到，这两种新特性对编译期编程有了很大的改进，可以让代码变得更直观。最后我们讨论了我们之前用到的容器输出函数 output_container 的实现，里面用到了多种我们目前讨论过的编译期编程技巧。</p><h2 id="课后思考"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/06#课后思考"><span class="icon icon-link"></span></a>课后思考</h2><p>请你仔细想一想：</p><ol><li>如果没有 constexpr 条件语句，这个容器输出函数需要怎样写？</li><li>这种不使用 constexpr 的写法有什么样的缺点？推而广之，constexpr 条件语句的意义是什么？</li></ol><h2 id="参考资料"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/06#参考资料"><span class="icon icon-link"></span></a>参考资料</h2><p>[1] cppreference.com, “constexpr specifier”. <a target="_blank" rel="noopener noreferrer" href="https://en.cppreference.com/w/cpp/language/constexpr">https://en.cppreference.com/w/cpp/language/constexpr<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[1a] cppreference.com, “constexpr 说明符”. <a target="_blank" rel="noopener noreferrer" href="https://zh.cppreference.com/w/cpp/language/constexpr">https://zh.cppreference.com/w/cpp/language/constexpr<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[2] cppreference.com, “if statement”, section “constexpr if”. <a target="_blank" rel="noopener noreferrer" href="https://en.cppreference.com/w/cpp/language/if">https://en.cppreference.com/w/cpp/language/if<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[2a] cppreference.com, “if 语句”, “constexpr if” 部分. <a target="_blank" rel="noopener noreferrer" href="https://zh.cppreference.com/w/cpp/language/if">https://zh.cppreference.com/w/cpp/language/if<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[3] 吴咏炜, output_container. <a target="_blank" rel="noopener noreferrer" href="https://github.com/adah1972/output_container/blob/geektime/output_container.h">https://github.com/adah1972/output_container/blob/geektime/output_container.h<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/现代c编程实战/03.提高篇/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
