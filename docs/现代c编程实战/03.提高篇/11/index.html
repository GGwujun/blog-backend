<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>20 | 内存模型和atomic：理解并发的复杂性 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/现代c编程实战/03.提高篇/11" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/现代c编程实战/01.课前必读">01.课前必读</a><ul><li><a href="/blog-backend/现代c编程实战/01.课前必读/01"><span>开篇词 | C加加这么难，为什么我们还要用C加加？</span></a></li><li><a href="/blog-backend/现代c编程实战/01.课前必读/02"><span>课前必读 | 有关术语发音及环境要求</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/02.基础篇">02.基础篇</a><ul><li><a href="/blog-backend/现代c编程实战/02.基础篇/01"><span>01 | 堆、栈、RAII：C加加里该如何管理资源？</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/02"><span>02 | 自己动手，实现C加加的智能指针</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/03"><span>03 | 右值和移动究竟解决了什么问题？</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/04"><span>04 | 容器汇编 I：比较简单的若干容器</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/05"><span>05 | 容器汇编 II：需要函数对象的容器</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/06"><span>06 | 异常：用还是不用，这是个问题</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/07"><span>07 | 迭代器和好用的新for循环</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/08"><span>08 | 易用性改进 I：自动类型推断和初始化</span></a></li><li><a href="/blog-backend/现代c编程实战/02.基础篇/09"><span>09 | 易用性改进 II：字面量、静态断言和成员函数说明符</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战/03.提高篇">03.提高篇</a><ul><li><a href="/blog-backend/现代c编程实战/03.提高篇/01"><span>10 | 到底应不应该返回对象？</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/02"><span>11 | Unicode：进入多文字支持的世界</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/03"><span>12 | 编译期多态：泛型编程和模板入门</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/04"><span>13 | 编译期能做些什么？一个完整的计算世界</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/05"><span>14 | SFINAE：不是错误的替换失败是怎么回事?</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/06"><span>15 | constexpr：一个常态的世界</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/07"><span>16 | 函数对象和lambda：进入函数式编程</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/08"><span>17 | 函数式编程：一种越来越流行的编程范式</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/09"><span>18 | 应用可变模板和tuple的编译期技巧</span></a></li><li><a href="/blog-backend/现代c编程实战/03.提高篇/10"><span>19 | thread和future：领略异步中的未来</span></a></li><li><a aria-current="page" class="active" href="/blog-backend/现代c编程实战/03.提高篇/11"><span>20 | 内存模型和atomic：理解并发的复杂性</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/04.实战篇">04.实战篇</a><ul><li><a href="/blog-backend/现代c编程实战/04.实战篇/01"><span>21 | 工具漫谈：编译、格式化、代码检查、排错各显身手</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/02"><span>22 | 处理数据类型变化和错误：optional、variant、expected和Herbception</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/03"><span>23 | 数字计算：介绍线性代数和数值计算库</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/04"><span>24 | Boost：你需要的“瑞士军刀”</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/05"><span>25 | 两个单元测试库：C加加里如何进行单元测试?</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/06"><span>26 | Easylogging++和spdlog：两个好用的日志库</span></a></li><li><a href="/blog-backend/现代c编程实战/04.实战篇/07"><span>27 | C加加 REST SDK：使用现代C开发网络应用</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/05.新年特别策划">05.新年特别策划</a><ul><li><a href="/blog-backend/现代c编程实战/05.新年特别策划/01"><span>新春寄语 | 35年码龄程序员：人生漫长，走点弯路在所难免</span></a></li><li><a href="/blog-backend/现代c编程实战/05.新年特别策划/02"><span>新春福利 | C加加好书荐读</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/06.未来篇">06.未来篇</a><ul><li><a href="/blog-backend/现代c编程实战/06.未来篇/01"><span>28 | Concepts：如何对模板进行约束?</span></a></li><li><a href="/blog-backend/现代c编程实战/06.未来篇/02"><span>29 | Ranges：无迭代器的迭代和更方便的组合</span></a></li><li><a href="/blog-backend/现代c编程实战/06.未来篇/03"><span>30 | Coroutines：协作式的交叉调度执行</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/07.加餐">07.加餐</a><ul><li><a href="/blog-backend/现代c编程实战/07.加餐/01"><span>加餐 | 部分课后思考题答案合集</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/08.结束语">08.结束语</a><ul><li><a href="/blog-backend/现代c编程实战/08.结束语/01"><span>结束语 | 终点已达，行程还要继续</span></a></li><li><a href="/blog-backend/现代c编程实战/08.结束语/02"><span>结课问卷获奖用户名单</span></a></li><li><a href="/blog-backend/现代c编程实战/08.结束语/03"><span>第二季回归｜拿下Vim，让编程效率神器为我所用</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/09.期末测试">09.期末测试</a><ul><li><a href="/blog-backend/现代c编程实战/09.期末测试/01"><span>期末测试 | 对于现代C，你掌握了多少呢？</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/10.增补篇">10.增补篇</a><ul><li><a href="/blog-backend/现代c编程实战/10.增补篇/01"><span>旅程再启｜那些关于C加加的新认知</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/02"><span>31｜new和delete背后：分配函数和释放函数</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/03"><span>32｜容器里的内存管理：分配器</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/04"><span>33｜性能测试的正确姿势：性能、时间和优化</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/05"><span>34｜快速分配和释放内存：内存池</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/06"><span>35 | 发现和识别内存问题：内存调试实践</span></a></li><li><a href="/blog-backend/现代c编程实战/10.增补篇/07"><span>36｜访问对象的代理对象：视图类型</span></a></li></ul></li><li><a href="/blog-backend/现代c编程实战/summary">现代c编程实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="C加加98 的执行顺序问题" data-depth="2"><a href="/blog-backend/现代c编程实战/03.提高篇/11#c加加98-的执行顺序问题"><span>C加加98 的执行顺序问题</span></a></li><li title="双重检查锁定" data-depth="3"><a href="/blog-backend/现代c编程实战/03.提高篇/11#双重检查锁定"><span>双重检查锁定</span></a></li><li title="volatile" data-depth="3"><a href="/blog-backend/现代c编程实战/03.提高篇/11#volatile"><span>volatile</span></a></li><li title="C加加11 的内存模型" data-depth="2"><a href="/blog-backend/现代c编程实战/03.提高篇/11#c加加11-的内存模型"><span>C加加11 的内存模型</span></a></li><li title="内存屏障和获得、释放语义" data-depth="3"><a href="/blog-backend/现代c编程实战/03.提高篇/11#内存屏障和获得释放语义"><span>内存屏障和获得、释放语义</span></a></li><li title="atomic" data-depth="3"><a href="/blog-backend/现代c编程实战/03.提高篇/11#atomic"><span>atomic</span></a></li><li title="mutex" data-depth="3"><a href="/blog-backend/现代c编程实战/03.提高篇/11#mutex"><span>mutex</span></a></li><li title="并发队列的接口" data-depth="2"><a href="/blog-backend/现代c编程实战/03.提高篇/11#并发队列的接口"><span>并发队列的接口</span></a></li><li title="内容小结" data-depth="2"><a href="/blog-backend/现代c编程实战/03.提高篇/11#内容小结"><span>内容小结</span></a></li><li title="课后思考" data-depth="2"><a href="/blog-backend/现代c编程实战/03.提高篇/11#课后思考"><span>课后思考</span></a></li><li title="参考资料" data-depth="2"><a href="/blog-backend/现代c编程实战/03.提高篇/11#参考资料"><span>参考资料</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="20--内存模型和atomic理解并发的复杂性"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/11#20--内存模型和atomic理解并发的复杂性"><span class="icon icon-link"></span></a>20 | 内存模型和atomic：理解并发的复杂性</h1><p>你好，我是吴咏炜。</p><p>上一讲我们讨论了一些并发编程的基本概念，今天我们来讨论一个略有点绕的问题，C加加 里的内存模型和原子量。</p><h2 id="c加加98-的执行顺序问题"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/11#c加加98-的执行顺序问题"><span class="icon icon-link"></span></a>C加加98 的执行顺序问题</h2><p>C加加98 的年代里，开发者们已经了解了线程的概念，但 C加加 的标准里则完全没有提到线程。从实践上，估计大家觉得不提线程，C加加 也一样能实现多线程的应用程序吧。不过，很多聪明人都忽略了，下面的事实可能会产生不符合直觉预期的结果：</p><ul><li>为了优化的必要，编译器是可以调整代码的执行顺序的。唯一的要求是，程序的“可观测”外部行为是一致的。</li><li>处理器也会对代码的执行顺序进行调整（所谓的 CPU 乱序执行）。在单处理器的情况下，这种乱序无法被程序观察到；但在多处理器的情况下，在另外一个处理器上运行的另一个线程就可能会察觉到这种不同顺序的后果了。</li></ul><p>对于上面的后一点，大部分开发者并没有意识到。原因有好几个方面：</p><ul><li>多处理器的系统在那时还不常见</li><li>主流的 x86 体系架构仍保持着较严格的内存访问顺序</li><li>只有在数据竞争（data race）激烈的情况下才能看到“意外”的后果</li></ul><p>举一个例子，假设我们有两个全局变量：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int x = 0;</span></div><div class="token-line"><span class="token plain">    int y = 0;</span></div></pre></div><p>然后我们在一个线程里执行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">x = 1;</span></div><div class="token-line"><span class="token plain">    y = 2;</span></div></pre></div><p>在另一个线程里执行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if (y == 2) {</span></div><div class="token-line"><span class="token plain">      x = 3;</span></div><div class="token-line"><span class="token plain">      y = 4;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>想一下，你认为上面的代码运行完之后，<code>x</code>、<code>y</code> 的数值有几种可能？</p><p>你如果认为有两种可能，1、2 和 3、4 的话，那说明你是按典型程序员的思维模式看问题的——没有像编译器和处理器一样处理问题。事实上，1、4 也是一种结果的可能。有两个基本的原因可以造成这一后果：</p><ul><li>编译器没有义务一定按代码里给出的顺序产生代码。事实上，跟据上下文调整代码的执行顺序，使其最有利于处理器的架构，是优化中很重要的一步。就单个线程而言，先执行 <code>x = 1</code> 还是先执行 <code>y = 2</code> 完全是件无关紧要的事：它们没有外部“可观察”的区别。</li><li>在多处理器架构中，各个处理器可能存在缓存不一致性问题。取决于具体的处理器类型、缓存策略和变量地址，对变量 <code>y</code> 的写入有可能先反映到主内存中去。之所以这个问题似乎并不常见，是因为常见的 x86 和 x86-64 处理器是在顺序执行方面做得最保守的——大部分其他处理器，如 ARM、DEC Alpha、PA-RISC、IBM Power、IBM z架构和 Intel Itanium 在内存序问题上都比较“松散”。x86 使用的内存模型基本提供了顺序一致性（sequential consistency）；相对的，ARM 使用的内存模型就只是松散一致性（relaxed consistency）。较为严格的描述，请查看参考资料 [1] 和里面提供的进一步资料。</li></ul><p>虽说 Intel 架构处理器的顺序一致性比较好，但在多处理器（包括多核）的情况下仍然能够出现写读序列变成读写序列的情况，产生意料之外的后果。参考资料 [2] 中提供了完整的例子，包括示例代码。对于缓存不一致性问题的一般中文介绍，可以查看参考资料 [3]。</p><h3 id="双重检查锁定"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/11#双重检查锁定"><span class="icon icon-link"></span></a>双重检查锁定</h3><p>在多线程可能对同一个单件进行初始化的情况下，有一个双重检查锁定的技巧，可基本示意如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 头文件</span></div><div class="token-line"><span class="token plain">    class singleton {</span></div><div class="token-line"><span class="token plain">    public:</span></div><div class="token-line"><span class="token plain">      static singleton* instance();</span></div><div class="token-line"><span class="token plain">      …</span></div><div class="token-line"><span class="token plain">    private:</span></div><div class="token-line"><span class="token plain">      static singleton* inst_ptr_;</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 实现文件</span></div><div class="token-line"><span class="token plain">    singleton* singleton::inst_ptr_ =</span></div><div class="token-line"><span class="token plain">      nullptr;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    singleton* singleton::instance()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      if (inst_ptr_ == nullptr) {</span></div><div class="token-line"><span class="token plain">        lock_guard lock;  // 加锁</span></div><div class="token-line"><span class="token plain">        if (inst_ptr_ == nullptr) {</span></div><div class="token-line"><span class="token plain">          inst_ptr_ = new singleton();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      return inst_ptr_;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个代码的目的是消除大部分执行路径上的加锁开销。原本的意图是：如果 <code>inst_ptr_</code> 没有被初始化，执行才会进入加锁的路径，防止单件被构造多次；如果 <code>inst_ptr_</code> 已经被初始化，那它就会被直接返回，不会产生额外的开销。虽然看上去很美，但它一样有着上面提到的问题。Scott Meyers 和 Andrei Alexandrecu 详尽地分析了这个用法 [4]，然后得出结论：即使花上再大的力气，这个用法仍然有着非常多的难以填补的漏洞。本质上还是上面说的，优化编译器会努力击败你试图想防止优化的努力，而多处理器会以令人意外的方式让代码走到错误的执行路径上去。他们分析得非常详细，建议你可以花时间学习一下。</p><h3 id="volatile"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/11#volatile"><span class="icon icon-link"></span></a>volatile</h3><p>在某些编译器里，使用 <code>volatile</code> 关键字可以达到内存同步的效果。但我们必须记住，这不是 <code>volatile</code> 的设计意图，也不能通用地达到内存同步的效果。<code>volatile</code> 的语义只是防止编译器“优化”掉对内存的读写而已。它的合适用法，目前主要是用来读写映射到内存地址上的 I/O 操作。</p><p>由于 <code>volatile</code> 不能在多处理器的环境下确保多个线程能看到同样顺序的数据变化，在今天的通用应用程序中，不应该再看到 <code>volatile</code> 的出现。</p><h2 id="c加加11-的内存模型"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/11#c加加11-的内存模型"><span class="icon icon-link"></span></a>C加加11 的内存模型</h2><p>为了从根本上消除这些漏洞，C加加11 里引入了适合多线程的内存模型。我们可以在参考资料 [5] 里了解更多的细节。跟我们开发密切相关的是：现在我们有了原子对象（atomic）和使用原子对象的获得（acquire）、释放（release）语义，可以真正精确地控制内存访问的顺序性，保证我们需要的内存序。</p><h3 id="内存屏障和获得释放语义"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/11#内存屏障和获得释放语义"><span class="icon icon-link"></span></a>内存屏障和获得、释放语义</h3><p>拿刚才的那个例子来说，如果我们希望结果只能是 1、2 或 3、4，即满足程序员心中的完全存储序（total store ordering），我们需要在 <code>x = 1</code> 和 <code>y = 2</code> 两句语句之间加入内存屏障，禁止这两句语句交换顺序。我们在此种情况下最常用的两个概念是“获得”和“释放”：</p><ul><li><strong>获得</strong>是一个对内存的<strong>读</strong>操作，当前线程的任何后面的读写操作都不允许重排到这个操作的<strong>前面</strong>去。</li><li><strong>释放</strong>是一个对内存的<strong>写</strong>操作，当前线程的任何前面的读写操作都不允许重排到这个操作的<strong>后面</strong>去。</li></ul><p>具体到我们上面的第一个例子，我们需要把 <code>y</code> 声明成 <code>atomic&lt;int&gt;</code>。然后，我们在线程 1 需要使用释放语义：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">x = 1;</span></div><div class="token-line"><span class="token plain">    y.store(2, memory_order_release);</span></div></pre></div><p>在线程 2 我们对 <code>y</code> 的读取应当使用获得语义，但存储只需要松散内存序即可：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if (y.load(memory_order_acquire) ==</span></div><div class="token-line"><span class="token plain">        2) {</span></div><div class="token-line"><span class="token plain">      x = 3;</span></div><div class="token-line"><span class="token plain">      y.store(4, memory_order_relaxed);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们可以用下图示意一下，每一边的代码都不允许重排越过黄色区域，且如果 <code>y</code> 上的释放早于 <code>y</code> 上的获取的话，释放前对内存的修改都在另一个线程的获取操作后可见：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage331433484c6762bb98d91ce8d30a752e2614.1927033f.png" alt=""/></p><p>事实上，在我们把 <code>y</code> 改成 <code>atomic&lt;int&gt;</code> 之后，两个线程的代码一行不改，执行结果都会是符合我们的期望的。因为 <code>atomic</code> 变量的写操作缺省就是释放语义，读操作缺省就是获得语义（不严格的说法，精确表述见下面的内存序部分）。即</p><ul><li><code>y = 2</code> 相当于 <code>y.store(2, memory_order_release)</code></li><li><code>y == 2</code> 相当于 <code>y.load(memory_order_acquire) == 2</code></li></ul><p>但是，缺省行为可能是对性能不利的：我们并不需要在任何情况下都保证操作的顺序性。</p><p>另外，我们应当注意一下，acquire 和 release 通常都是配对出现的，目的是保证如果对同一个原子对象的 release 发生在 acquire 之前的话，release 之前发生的内存修改能够被 acquire 之后的内存读取全部看到。</p><h3 id="atomic"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/11#atomic"><span class="icon icon-link"></span></a>atomic</h3><p>刚才是对 atomic 用法的一个非正式介绍。下面我们对 atomic 做一个稍完整些的说明（更完整的见 [6]）。</p><p>C加加11 在 &lt;atomic&gt; 头文件中引入了 <code>atomic</code> 模板，对原子对象进行了封装。我们可以将其应用到任何类型上去。当然对于不同的类型效果还是有所不同的：对于整型量和指针等简单类型，通常结果是无锁的原子对象；而对于另外一些类型，比如 64 位机器上大小不是 1、2、4、8（有些平台/编译器也支持对更大的数据进行无锁原子操作）的类型，编译器会自动为这些原子对象的操作加上锁。编译器提供了一个原子对象的成员函数 <code>is_lock_free</code>，可以检查这个原子对象上的操作是否是无锁的。</p><p>原子操作有三类：</p><ul><li>读：在读取的过程中，读取位置的内容不会发生任何变动。</li><li>写：在写入的过程中，其他执行线程不会看到部分写入的结果。</li><li>读‐修改‐写：读取内存、修改数值、然后写回内存，整个操作的过程中间不会有其他写入操作插入，其他执行线程不会看到部分写入的结果。</li></ul><p>&lt;atomic&gt; 头文件中还定义了内存序，分别是：</p><ul><li><code>memory_order_relaxed</code>：松散内存序，只用来保证对原子对象的操作是原子的</li><li><code>memory_order_consume</code>：目前不鼓励使用，我就不说明了</li><li><code>memory_order_acquire</code>：获得操作，在读取某原子对象时，当前线程的任何后面的读写操作都不允许重排到这个操作的前面去，并且其他线程在对同一个原子对象释放之前的所有内存写入都在当前线程可见</li><li><code>memory_order_release</code>：释放操作，在写入某原子对象时，当前线程的任何前面的读写操作都不允许重排到这个操作的后面去，并且当前线程的所有内存写入都在对同一个原子对象进行获取的其他线程可见</li><li><code>memory_order_acq_rel</code>：获得释放操作，一个读‐修改‐写操作同时具有获得语义和释放语义，即它前后的任何读写操作都不允许重排，并且其他线程在对同一个原子对象释放之前的所有内存写入都在当前线程可见，当前线程的所有内存写入都在对同一个原子对象进行获取的其他线程可见</li><li><code>memory_order_seq_cst</code>：顺序一致性语义，对于读操作相当于获取，对于写操作相当于释放，对于读‐修改‐写操作相当于获得释放，<strong>是所有原子操作的默认内存序</strong>（除此之外，顺序一致性还保证了多个原子量的修改在所有线程里观察到的修改顺序都相同；我们目前的讨论暂不涉及多个原子量的修改）</li></ul><p><code>atomic</code> 有下面这些常用的成员函数：</p><ul><li>默认构造函数（只支持零初始化）</li><li>拷贝构造函数被删除</li><li>使用内置对象类型的构造函数（不是原子操作）</li><li>可以从内置对象类型赋值到原子对象（相当于 <code>store</code>）</li><li>可以从原子对象隐式转换成内置对象（相当于 <code>load</code>）</li><li><code>store</code>，写入对象到原子对象里，第二个可选参数是内存序类型</li><li><code>load</code>，从原子对象读取内置对象，有个可选参数是内存序类型</li><li><code>is_lock_free</code>，判断对原子对象的操作是否无锁（是否可以用处理器的指令直接完成原子操作）</li><li><code>exchange</code>，交换操作，第二个可选参数是内存序类型（这是读‐修改‐写操作）</li><li><code>compare_exchange_weak</code> 和 <code>compare_exchange_strong</code>，两个比较加交换（CAS）的版本，你可以分别指定成功和失败时的内存序，也可以只指定一个，或使用默认的最安全内存序（这是读‐修改‐写操作）</li><li><code>fetch_add</code> 和 <code>fetch_sub</code>，仅对整数和指针内置对象有效，对目标原子对象执行加或减操作，返回其原始值，第二个可选参数是内存序类型（这是读‐修改‐写操作）</li><li><code>++</code> 和 <code>--</code>（前置和后置），仅对整数和指针内置对象有效，对目标原子对象执行增一或减一，操作使用顺序一致性语义，并注意返回的不是原子对象的引用（这是读‐修改‐写操作）</li><li><code>+=</code> 和 <code>-=</code>，仅对整数和指针内置对象有效，对目标原子对象执行加或减操作，返回操作之后的数值，操作使用顺序一致性语义，并注意返回的不是原子对象的引用（这是读‐修改‐写操作）</li></ul><p>有了原子对象之后，我们可以轻而易举地把<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/169263">[第 2 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中的 <code>shared_count</code> 变成线程安全。我们只需要包含 &lt;atomic&gt; 头文件，并把下面这行</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">long count_;</span></div></pre></div><p>修改成</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">std::atomic_long count_;</span></div></pre></div><p>即可（<code>atomic_long</code> 是 <code>atomic&lt;long&gt;</code> 的类型别名）。不过，由于我们并不需要 <code>++</code> 之后计数值影响其他行为，在 <code>add_count</code> 中执行简单的 <code>++</code>、使用顺序一致性语义略有浪费。更好的做法是将其实现成：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void add_count() noexcept</span></div><div class="token-line"><span class="token plain">      {</span></div><div class="token-line"><span class="token plain">        count_.fetch_add(</span></div><div class="token-line"><span class="token plain">          1, std::memory_order_relaxed);</span></div><div class="token-line"><span class="token plain">      }</span></div></pre></div><h4 id="is_lock_free-的可能问题"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/11#is_lock_free-的可能问题"><span class="icon icon-link"></span></a>is_lock_free 的可能问题</h4><p>注意，macOS 上在使用 Clang 时似乎不支持对需要加锁的对象使用 <code>is_lock_free</code> 成员函数，此时链接会出错。而 GCC 在这种情况下，需要确保系统上装了 libatomic。以 CentOS 7 下的 GCC 7 为例，我们可以使用下面的语句来安装：</p><blockquote><p><code>sudo yum install devtoolset-7-libatomic-devel</code></p></blockquote><p>然后，用下面的语句编译可以通过：</p><blockquote><p><code>g++ \-pthread test.cpp \-latomic</code></p></blockquote><p>Windows 下使用 MSVC 则没有问题。</p><h3 id="mutex"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/11#mutex"><span class="icon icon-link"></span></a>mutex</h3><p>上一讲我们已经讨论了互斥量。今天，我们只需要补充两点：</p><ul><li>互斥量的加锁操作（<code>lock</code>）具有获得语义</li><li>互斥量的解锁操作（<code>unlock</code>）具有释放语义</li></ul><p>有了目前讲过的这些知识，我们终于可以实现一个真正安全的双重检查锁定了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 头文件</span></div><div class="token-line"><span class="token plain">    class singleton {</span></div><div class="token-line"><span class="token plain">    public:</span></div><div class="token-line"><span class="token plain">      static singleton* instance();</span></div><div class="token-line"><span class="token plain">      …</span></div><div class="token-line"><span class="token plain">    private:</span></div><div class="token-line"><span class="token plain">      static mutex lock_;</span></div><div class="token-line"><span class="token plain">      static atomic&lt;singleton*&gt;</span></div><div class="token-line"><span class="token plain">        inst_ptr_;</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 实现文件</span></div><div class="token-line"><span class="token plain">    mutex singleton::lock_;</span></div><div class="token-line"><span class="token plain">    atomic&lt;singleton*&gt;</span></div><div class="token-line"><span class="token plain">      singleton::inst_ptr_;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    singleton* singleton::instance()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      singleton* ptr = inst_ptr_.load(</span></div><div class="token-line"><span class="token plain">        memory_order_acquire);</span></div><div class="token-line"><span class="token plain">      if (ptr == nullptr) {</span></div><div class="token-line"><span class="token plain">        lock_guard&lt;mutex&gt; guard{lock_};</span></div><div class="token-line"><span class="token plain">        ptr = inst_ptr_.load(</span></div><div class="token-line"><span class="token plain">          memory_order_relaxed);</span></div><div class="token-line"><span class="token plain">        if (ptr == nullptr) {</span></div><div class="token-line"><span class="token plain">          ptr = new singleton();</span></div><div class="token-line"><span class="token plain">          inst_ptr_.store(</span></div><div class="token-line"><span class="token plain">            ptr, memory_order_release);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      return inst_ptr_;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="并发队列的接口"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/11#并发队列的接口"><span class="icon icon-link"></span></a>并发队列的接口</h2><p>在结束这一讲之前，我们来检查一下并发对编程接口的冲击。回想我们之前讲到标准库里 <code>queue</code> 有下面这样的接口：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;typename T&gt;</span></div><div class="token-line"><span class="token plain">    class queue {</span></div><div class="token-line"><span class="token plain">    public:</span></div><div class="token-line"><span class="token plain">      …</span></div><div class="token-line"><span class="token plain">      T&amp; front();</span></div><div class="token-line"><span class="token plain">      const T&amp; front() const;</span></div><div class="token-line"><span class="token plain">      void pop();</span></div><div class="token-line"><span class="token plain">      …</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们之前还问过为什么 <code>pop</code> 不直接返回第一个元素。可到了并发的年代，我们不禁要问，这样的接口设计到底明智吗？</p><p><strong>会不会在我们正在访问 <code>front()</code> 的时候，这个元素就被 <code>pop</code> 掉了？</strong></p><p>事实上，上面这样的接口是不可能做到并发安全的。并发安全的接口大概长下面这个样子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;typename T&gt;</span></div><div class="token-line"><span class="token plain">    class queue {</span></div><div class="token-line"><span class="token plain">    public:</span></div><div class="token-line"><span class="token plain">      …</span></div><div class="token-line"><span class="token plain">      void wait_and_pop(T&amp; dest)</span></div><div class="token-line"><span class="token plain">      bool try_pop(T&amp; dest);</span></div><div class="token-line"><span class="token plain">      …</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>换句话说，要准备好位置去接收；然后如果接收成功了，才安安静静地在自己的线程里处理已经被弹出队列的对象。接收方式还得分两种，阻塞式的和非阻塞式的……</p><p>那我为什么要在内存模型和原子量这一讲里讨论这个问题呢？因为并发队列的实现，经常是用原子量来达到无锁和高性能的。单生产者、单消费者的并发队列，用原子量和获得、释放语义就能简单实现。对于多生产者或多消费者的情况，那实现就比较复杂了，一般会使用 <code>compare_exchange_strong</code> 或 <code>compare_exchange_weak</code>。讨论这个话题的复杂性，就大大超出了本专栏的范围了。你如果感兴趣的话，可以查看下面几项内容：</p><ul><li>nvwa::fc_queue [7] 给出了一个单生产者、单消费者的无锁并发定长环形队列，代码长度是几百行的量级。</li><li>moodycamel::ConcurrentQueue [8] 给出了一个多生产者、多消费者的无锁通用并发队列，代码长度是几千行的量级。</li><li>陈皓给出了一篇很棒的对无锁队列的中文描述 [9]，推荐阅读。</li></ul><h2 id="内容小结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/11#内容小结"><span class="icon icon-link"></span></a>内容小结</h2><p>在这一讲里，我们讨论了 C加加 对并发的底层支持，特别是内存模型和原子量。这些底层概念，是在 C加加 里写出高性能并发代码的基础。</p><h2 id="课后思考"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/11#课后思考"><span class="icon icon-link"></span></a>课后思考</h2><p>在传统 PC 上开发的程序员，应当比较少接触具有松散或弱内存一致性的系统，但原子量和普通变量的区别还是很容易在代码中表现出来的。请你尝试一下多个线程对一个原子量和一个普通全局变量做多次增一操作，观察最后的结果。</p><p>在 Intel 处理器架构上，唯一可见的重排是多处理器下的写读操作。大力推荐你尝试一下参考资料 [2] 中的例子（Windows 和 Linux 下可直接运行；macOS 下需要使用我的<a target="_blank" rel="noopener noreferrer" href="https://gist.github.com/adah1972/8ee7484647ea9a1795089219a3704574">修改版本<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>或备用<a target="_blank" rel="noopener noreferrer" href="http://wyw.dcweb.cn/download.asp?path=&amp;file=ordering.cpp">下载链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>来覆盖下载代码中的 gcc/ordering.cpp），并修改预定义宏。另外一种改法就是把代码中的 <code>X</code>、<code>Y</code> 的类型改成 <code>atomic_int</code>，重排也就消失了。</p><p>如果遇到任何特别问题，欢迎留言与我交流。</p><h2 id="参考资料"><a aria-hidden="true" tabindex="-1" href="/blog-backend/现代c编程实战/03.提高篇/11#参考资料"><span class="icon icon-link"></span></a>参考资料</h2><p>[1] Wikipedia, “Memory ordering”. <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Memory_ordering">https://en.wikipedia.org/wiki/Memory_ordering<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[1a] 维基百科, “内存排序”. <a target="_blank" rel="noopener noreferrer" href="https://zh.wikipedia.org/zh-cn/%E5%86%85%E5%AD%98%E6%8E%92%E5%BA%8F">https://zh.wikipedia.org/zh-cn/内存排序<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[2] Jeff Preshing, “Memory reordering caught in the act”. <a target="_blank" rel="noopener noreferrer" href="https://preshing.com/20120515/memory-reordering-caught-in-the-act/">https://preshing.com/20120515/memory-reordering-caught-in-the-act/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[3] 王欢明, 《多处理器编程：从缓存一致性到内存模型》. <a target="_blank" rel="noopener noreferrer" href="https://zhuanlan.zhihu.com/p/35386457">https://zhuanlan.zhihu.com/p/35386457<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[4] Scott Meyers and Andrei Alexandrescu, “C加加 and the perils of double-checked locking”. <a target="_blank" rel="noopener noreferrer" href="https://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf">https://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[5] cppreference.com, “Memory model”. <a target="_blank" rel="noopener noreferrer" href="https://en.cppreference.com/w/cpp/language/memory_model">https://en.cppreference.com/w/cpp/language/memory_model<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[5a] cppreference.com, “内存模型”. <a target="_blank" rel="noopener noreferrer" href="https://zh.cppreference.com/w/cpp/language/memory_model">https://zh.cppreference.com/w/cpp/language/memory_model<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[6] cppreference.com, “std::atomic”. <a target="_blank" rel="noopener noreferrer" href="https://en.cppreference.com/w/cpp/atomic/atomic">https://en.cppreference.com/w/cpp/atomic/atomic<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[6a] cppreference.com, “std::atomic”. <a target="_blank" rel="noopener noreferrer" href="https://zh.cppreference.com/w/cpp/atomic/atomic">https://zh.cppreference.com/w/cpp/atomic/atomic<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[7] 吴咏炜, nvwa. <a target="_blank" rel="noopener noreferrer" href="https://github.com/adah1972/nvwa">https://github.com/adah1972/nvwa<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[8] Cameron Desrochers, moodycamel::ConcurrentQueue. <a target="_blank" rel="noopener noreferrer" href="https://github.com/cameron314/concurrentqueue">https://github.com/cameron314/concurrentqueue<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>[9] 陈皓, 《无锁队列的实现》. <a target="_blank" rel="noopener noreferrer" href="https://coolshell.cn/articles/8239.html">https://coolshell.cn/articles/8239.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/现代c编程实战/03.提高篇/11.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
