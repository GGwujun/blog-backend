<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>28 | 读写分离有哪些坑？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/mysql实战45讲/03.实践篇/20" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a aria-current="page" class="active" href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a aria-current="page" class="active" href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/mysql实战45讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog-backend/mysql实战45讲/01.开篇词/01"><span>开篇词 | 这一次，让我们一起来搞懂MySQL</span></a></li></ul></li><li><a href="/blog-backend/mysql实战45讲/02.基础篇">02.基础篇</a><ul><li><a href="/blog-backend/mysql实战45讲/02.基础篇/01"><span>01 | 基础架构：一条SQL查询语句是如何执行的？</span></a></li><li><a href="/blog-backend/mysql实战45讲/02.基础篇/02"><span>02  | 日志系统：一条SQL更新语句是如何执行的？</span></a></li><li><a href="/blog-backend/mysql实战45讲/02.基础篇/03"><span>03 | 事务隔离：为什么你改了我还看不见？</span></a></li><li><a href="/blog-backend/mysql实战45讲/02.基础篇/04"><span>04 | 深入浅出索引（上）</span></a></li><li><a href="/blog-backend/mysql实战45讲/02.基础篇/05"><span>05 | 深入浅出索引（下）</span></a></li><li><a href="/blog-backend/mysql实战45讲/02.基础篇/06"><span>06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</span></a></li><li><a href="/blog-backend/mysql实战45讲/02.基础篇/07"><span>07 | 行锁功过：怎么减少行锁对性能的影响？</span></a></li><li><a href="/blog-backend/mysql实战45讲/02.基础篇/08"><span>08 | 事务到底是隔离的还是不隔离的？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/mysql实战45讲/03.实践篇">03.实践篇</a><ul><li><a href="/blog-backend/mysql实战45讲/03.实践篇/01"><span>09 | 普通索引和唯一索引，应该怎么选择？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/02"><span>10 | MySQL为什么有时候会选错索引？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/03"><span>11 |  怎么给字符串字段加索引？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/04"><span>12 | 为什么我的MySQL会“抖”一下？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/05"><span>13 | 为什么表数据删掉一半，表文件大小不变？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/06"><span>14 | count(*)这么慢，我该怎么办？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/07"><span>15 | 答疑文章（一）：日志和索引相关问题</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/08"><span>16 | “order by”是怎么工作的？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/09"><span>17 | 如何正确地显示随机消息？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/10"><span>18 | 为什么这些SQL语句逻辑相同，性能却差异巨大？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/11"><span>19 | 为什么我只查一行的语句，也执行这么慢？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/12"><span>20 | 幻读是什么，幻读有什么问题？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/13"><span>21 | 为什么我只改一行的语句，锁这么多？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/14"><span>22 | MySQL有哪些“饮鸩止渴”提高性能的方法？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/15"><span>23 | MySQL是怎么保证数据不丢的？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/16"><span>24 | MySQL是怎么保证主备一致的？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/17"><span>25 | MySQL是怎么保证高可用的？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/18"><span>26 | 备库为什么会延迟好几个小时？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/19"><span>27 | 主库出问题了，从库怎么办？</span></a></li><li><a aria-current="page" class="active" href="/blog-backend/mysql实战45讲/03.实践篇/20"><span>28 | 读写分离有哪些坑？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/21"><span>29 | 如何判断一个数据库是不是出问题了？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/22"><span>30 | 答疑文章（二）：用动态的观点看加锁</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/23"><span>31 | 误删数据后除了跑路，还能怎么办？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/24"><span>32 | 为什么还有kill不掉的语句？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/25"><span>33 | 我查这么多数据，会不会把数据库内存打爆？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/26"><span>34 | 到底可不可以使用join？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/27"><span>35 | join语句怎么优化？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/28"><span>36 | 为什么临时表可以重名？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/29"><span>37 | 什么时候会使用内部临时表？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/30"><span>38 | 都说InnoDB好，那还要不要使用Memory引擎？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/31"><span>39 | 自增主键为什么不是连续的？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/32"><span>40 | insert语句的锁为什么这么多？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/33"><span>41 | 怎么最快地复制一张表？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/34"><span>42 | grant之后要跟着flush privileges吗？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/35"><span>43 | 要不要使用分区表？</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/36"><span>44 | 答疑文章（三）：说一说这些好问题</span></a></li><li><a href="/blog-backend/mysql实战45讲/03.实践篇/37"><span>45 | 自增id用完怎么办？</span></a></li></ul></li><li><a href="/blog-backend/mysql实战45讲/04.特别放送">04.特别放送</a><ul><li><a href="/blog-backend/mysql实战45讲/04.特别放送/01"><span>直播回顾 | 林晓斌：我的 MySQL 心路历程</span></a></li></ul></li><li><a href="/blog-backend/mysql实战45讲/05.结束语">05.结束语</a><ul><li><a href="/blog-backend/mysql实战45讲/05.结束语/01"><span>结束语 | 点线网面，一起构建MySQL知识网络</span></a></li></ul></li><li><a href="/blog-backend/mysql实战45讲/summary">mysql实战45讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="28--读写分离有哪些坑"><a aria-hidden="true" tabindex="-1" href="/blog-backend/mysql实战45讲/03.实践篇/20#28--读写分离有哪些坑"><span class="icon icon-link"></span></a>28 | 读写分离有哪些坑？</h1><p>在上一篇文章中，我和你介绍了一主多从的结构以及切换流程。今天我们就继续聊聊一主多从架构的应用场景：读写分离，以及怎么处理主备延迟导致的读写分离问题。</p><p>我们在上一篇文章中提到的一主多从的结构，其实就是读写分离的基本结构了。这里，我再把这张图贴过来，方便你理解。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage13aa1334b9c08b8fd837832fdb2d82e6b0aa.46ce4c1e.png" alt=""/></p><p>图1 读写分离基本结构</p><p>读写分离的主要目标就是分摊主库的压力。图1中的结构是客户端（client）主动做负载均衡，这种模式下一般会把数据库的连接信息放在客户端的连接层。也就是说，由客户端来选择后端数据库进行查询。</p><p>还有一种架构是，在MySQL和客户端之间有一个中间代理层proxy，客户端只连接proxy， 由proxy根据请求类型和上下文决定请求的分发路由。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage1b451b1ea74a48e1a16409e9b4d02172b945.158031f6.jpg" alt=""/></p><p>图2 带proxy的读写分离架构</p><p>接下来，我们就看一下客户端直连和带proxy的读写分离架构，各有哪些特点。</p><ol><li><p>客户端直连方案，因为少了一层proxy转发，所以查询性能稍微好一点儿，并且整体架构简单，排查问题更方便。但是这种方案，由于要了解后端部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。<br/>你可能会觉得这样客户端也太麻烦了，信息大量冗余，架构很丑。其实也未必，一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如Zookeeper，尽量让业务端只专注于业务逻辑开发。</p></li><li><p>带proxy的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由proxy完成的。但这样的话，对后端维护团队的要求会更高。而且，proxy也需要有高可用架构。因此，带proxy架构的整体就相对比较复杂。</p></li></ol><p>理解了这两种方案的优劣，具体选择哪个方案就取决于数据库团队提供的能力了。但目前看，趋势是往带proxy的架构方向发展的。</p><p>但是，不论使用哪种架构，你都会碰到我们今天要讨论的问题：由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。</p><p><strong>这种“在从库上会读到系统的一个过期状态”的现象，在这篇文章里，我们暂且称之为“过期读”。</strong></p><p>前面我们说过了几种可能导致主备延迟的原因，以及对应的优化策略，但是主从延迟还是不能100%避免的。</p><p>不论哪种结构，客户端都希望查询从库的数据结果，跟查主库的数据结果是一样的。</p><p>接下来，我们就来讨论怎么处理过期读问题。</p><p>这里，我先把文章中涉及到的处理过期读的方案汇总在这里，以帮助你更好地理解和掌握全文的知识脉络。这些方案包括：</p><ul><li>强制走主库方案；</li><li>sleep方案；</li><li>判断主备无延迟方案；</li><li>配合semi-sync方案；</li><li>等主库位点方案；</li><li>等GTID方案。</li></ul><h1 id="强制走主库方案"><a aria-hidden="true" tabindex="-1" href="/blog-backend/mysql实战45讲/03.实践篇/20#强制走主库方案"><span class="icon icon-link"></span></a>强制走主库方案</h1><p>强制走主库方案其实就是，将查询请求做分类。通常情况下，我们可以将查询请求分为这么两类：</p><ol><li><p>对于必须要拿到最新结果的请求，强制将其发到主库上。比如，在一个交易平台上，卖家发布商品以后，马上要返回主页面，看商品是否发布成功。那么，这个请求需要拿到最新的结果，就必须走主库。</p></li><li><p>对于可以读到旧数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的。那么，这类请求就可以走从库。</p></li></ol><p>你可能会说，这个方案是不是有点畏难和取巧的意思，但其实这个方案是用得最多的。</p><p>当然，这个方案最大的问题在于，有时候你会碰到“所有查询都不能是过期读”的需求，比如一些金融类的业务。这样的话，你就要放弃读写分离，所有读写压力都在主库，等同于放弃了扩展性。</p><p>因此接下来，我们来讨论的话题是：可以支持读写分离的场景下，有哪些解决过期读的方案，并分析各个方案的优缺点。</p><h1 id="sleep-方案"><a aria-hidden="true" tabindex="-1" href="/blog-backend/mysql实战45讲/03.实践篇/20#sleep-方案"><span class="icon icon-link"></span></a>Sleep 方案</h1><p>主库更新后，读从库之前先sleep一下。具体的方案就是，类似于执行一条select sleep(1)命令。</p><p>这个方案的假设是，大多数情况下主备延迟在1秒之内，做一个sleep可以有很大概率拿到最新的数据。</p><p>这个方案给你的第一感觉，很可能是不靠谱儿，应该不会有人用吧？并且，你还可能会说，直接在发起查询时先执行一条sleep语句，用户体验很不友好啊。</p><p>但，这个思路确实可以在一定程度上解决问题。为了看起来更靠谱儿，我们可以换一种方式。</p><p>以卖家发布商品为例，商品发布后，用Ajax（Asynchronous JavaScript + XML，异步JavaScript和XML）直接把客户端输入的内容作为“新的商品”显示在页面上，而不是真正地去数据库做查询。</p><p>这样，卖家就可以通过这个显示，来确认产品已经发布成功了。等到卖家再刷新页面，去查看商品的时候，其实已经过了一段时间，也就达到了sleep的目的，进而也就解决了过期读的问题。</p><p>也就是说，这个sleep方案确实解决了类似场景下的过期读问题。但，从严格意义上来说，这个方案存在的问题就是不精确。这个不精确包含了两层意思：</p><ol><li><p>如果这个查询请求本来0.5秒就可以在从库上拿到正确结果，也会等1秒；</p></li><li><p>如果延迟超过1秒，还是会出现过期读。</p></li></ol><p>看到这里，你是不是有一种“你是不是在逗我”的感觉，这个改进方案虽然可以解决类似Ajax场景下的过期读问题，但还是怎么看都不靠谱儿。别着急，接下来我就和你介绍一些更准确的方案。</p><h1 id="判断主备无延迟方案"><a aria-hidden="true" tabindex="-1" href="/blog-backend/mysql实战45讲/03.实践篇/20#判断主备无延迟方案"><span class="icon icon-link"></span></a>判断主备无延迟方案</h1><p>要确保备库无延迟，通常有三种做法。</p><p>通过前面的<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/76795">第25篇<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>文章，我们知道show slave status结果里的seconds_behind_master参数的值，可以用来衡量主备延迟时间的长短。</p><p>所以**第一种确保主备无延迟的方法是，**每次从库执行查询请求前，先判断seconds_behind_master是否已经等于0。如果还不等于0 ，那就必须等到这个参数变为0才能执行查询请求。</p><p>seconds_behind_master的单位是秒，如果你觉得精度不够的话，还可以采用对比位点和GTID的方法来确保主备无延迟，也就是我们接下来要说的第二和第三种方法。</p><p>如图3所示，是一个show slave status结果的部分截图。</p><p><img src="data:image/png;base64,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" alt=""/></p><p>图3 show slave status结果</p><p>现在，我们就通过这个结果，来看看具体如何通过对比位点和GTID来确保主备无延迟。</p><p>**第二种方法，**对比位点确保主备无延迟：</p><ul><li>Master_Log_File和Read_Master_Log_Pos，表示的是读到的主库的最新位点；</li><li>Relay_Master_Log_File和Exec_Master_Log_Pos，表示的是备库执行的最新位点。</li></ul><p>如果Master_Log_File和Relay_Master_Log_File、Read_Master_Log_Pos和Exec_Master_Log_Pos这两组值完全相同，就表示接收到的日志已经同步完成。</p><p>**第三种方法，**对比GTID集合确保主备无延迟：</p><ul><li>Auto_Position=1 ，表示这对主备关系使用了GTID协议。</li><li>Retrieved_Gtid_Set，是备库收到的所有日志的GTID集合；</li><li>Executed_Gtid_Set，是备库所有已经执行完成的GTID集合。</li></ul><p>如果这两个集合相同，也表示备库接收到的日志都已经同步完成。</p><p>可见，对比位点和对比GTID这两种方法，都要比判断seconds_behind_master是否为0更准确。</p><p>在执行查询请求之前，先判断从库是否同步完成的方法，相比于sleep方案，准确度确实提升了不少，但还是没有达到“精确”的程度。为什么这么说呢？</p><p>我们现在一起来回顾下，一个事务的binlog在主备库之间的状态：</p><ol><li><p>主库执行完成，写入binlog，并反馈给客户端；</p></li><li><p>binlog被从主库发送给备库，备库收到；</p></li><li><p>在备库执行binlog完成。</p></li></ol><p>我们上面判断主备无延迟的逻辑，是“备库收到的日志都执行完成了”。但是，从binlog在主备之间状态的分析中，不难看出还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态。</p><p>如图4所示就是这样的一个状态。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage559e557445207b57d6c0f2747509d7d6619e.c996edef.png" alt=""/></p><p>图4 备库还没收到trx3</p><p>这时，主库上执行完成了三个事务trx1、trx2和trx3，其中：</p><ol><li><p>trx1和trx2已经传到从库，并且已经执行完成了；</p></li><li><p>trx3在主库执行完成，并且已经回复给客户端，但是还没有传到从库中。</p></li></ol><p>如果这时候你在从库B上执行查询请求，按照我们上面的逻辑，从库认为已经没有同步延迟，但还是查不到trx3的。严格地说，就是出现了过期读。</p><p>那么，这个问题有没有办法解决呢？</p><h1 id="配合semi-sync"><a aria-hidden="true" tabindex="-1" href="/blog-backend/mysql实战45讲/03.实践篇/20#配合semi-sync"><span class="icon icon-link"></span></a>配合semi-sync</h1><p>要解决这个问题，就要引入半同步复制，也就是semi-sync replication。</p><p>semi-sync做了这样的设计：</p><ol><li><p>事务提交的时候，主库把binlog发给从库；</p></li><li><p>从库收到binlog以后，发回给主库一个ack，表示收到了；</p></li><li><p>主库收到这个ack以后，才能给客户端返回“事务完成”的确认。</p></li></ol><p>也就是说，如果启用了semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。</p><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/76795">第25篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的评论区，有同学问到：如果主库掉电的时候，有些binlog还来不及发给从库，会不会导致系统数据丢失？</p><p>答案是，如果使用的是普通的异步复制模式，就可能会丢失，但semi-sync就可以解决这个问题。</p><p>这样，semi-sync配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过期读。</p><p>但是，semi-sync+位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只要等到一个从库的ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情况：</p><ol><li><p>如果查询是落在这个响应了ack的从库上，是能够确保读到最新数据；</p></li><li><p>但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。</p></li></ol><p>其实，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者GTID集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。</p><p>实际上，回到我们最初的业务逻辑里，当发起一个查询请求以后，我们要得到准确的结果，其实并不需要等到“主备完全同步”。</p><p>为什么这么说呢？我们来看一下这个时序图。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage9c099cf54f3e91dc8f7b8947d7d8e384aa09.6f165816.png" alt=""/></p><p>图5 主备持续延迟一个事务</p><p>图5所示，就是等待位点方案的一个bad case。图中备库B下的虚线框，分别表示relaylog和binlog中的事务。可以看到，图5中从状态1 到状态4，一直处于延迟一个事务的状态。</p><p>备库B一直到状态4都和主库A存在延迟，如果用上面必须等到无延迟才能查询的方案，select语句直到状态4都不能被执行。</p><p>但是，其实客户端是在发完trx1更新后发起的select语句，我们只需要确保trx1已经执行完成就可以执行select语句了。也就是说，如果在状态3执行查询请求，得到的就是预期结果了。</p><p>到这里，我们小结一下，semi-sync配合判断主备无延迟的方案，存在两个问题：</p><ol><li><p>一主多从的时候，在某些从库执行查询请求会存在过期读的现象；</p></li><li><p>在持续延迟的情况下，可能出现过度等待的问题。</p></li></ol><p>接下来，我要和你介绍的等主库位点方案，就可以解决这两个问题。</p><h1 id="等主库位点方案"><a aria-hidden="true" tabindex="-1" href="/blog-backend/mysql实战45讲/03.实践篇/20#等主库位点方案"><span class="icon icon-link"></span></a>等主库位点方案</h1><p>要理解等主库位点方案，我需要先和你介绍一条命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">select master_pos_wait(file, pos[, timeout]);</span></div></pre></div><p>这条命令的逻辑如下：</p><ol><li><p>它是在从库执行的；</p></li><li><p>参数file和pos指的是主库上的文件名和位置；</p></li><li><p>timeout可选，设置为正整数N表示这个函数最多等待N秒。</p></li></ol><p>这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。</p><p>当然，除了正常返回一个正整数M外，这条命令还会返回一些其他结果，包括：</p><ol><li><p>如果执行期间，备库同步线程发生异常，则返回NULL；</p></li><li><p>如果等待超过N秒，就返回-1；</p></li><li><p>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回0。</p></li></ol><p>对于图5中先执行trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据，我们可以使用这个逻辑：</p><ol><li><p>trx1事务更新完成后，马上执行show master status得到当前主库执行到的File和Position；</p></li><li><p>选定一个从库执行查询语句；</p></li><li><p>在从库上执行select master_pos_wait(File, Position, 1)；</p></li><li><p>如果返回值是&gt;=0的正整数，则在这个从库执行查询语句；</p></li><li><p>否则，到主库执行查询语句。</p></li></ol><p>我把上面这个流程画出来。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimageb257b20ae91ea46803df1b63ed683e1de357.e431f0a7.png" alt=""/></p><p>图6 master_pos_wait方案</p><p>这里我们假设，这条select查询最多在从库上等待1秒。那么，如果1秒内master_pos_wait返回一个大于等于0的整数，就确保了从库上执行的这个查询结果一定包含了trx1的数据。</p><p>步骤5到主库执行查询语句，是这类方案常用的退化机制。因为从库的延迟时间不可控，不能无限等待，所以如果等待超时，就应该放弃，然后到主库去查。</p><p>你可能会说，如果所有的从库都延迟超过1秒了，那查询压力不就都跑到主库上了吗？确实是这样。</p><p>但是，按照我们设定不允许过期读的要求，就只有两种选择，一种是超时放弃，一种是转到主库查询。具体怎么选择，就需要业务开发同学做好限流策略了。</p><h1 id="gtid方案"><a aria-hidden="true" tabindex="-1" href="/blog-backend/mysql实战45讲/03.实践篇/20#gtid方案"><span class="icon icon-link"></span></a>GTID方案</h1><p>如果你的数据库开启了GTID模式，对应的也有等待GTID的方案。</p><p>MySQL中同样提供了一个类似的命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">select wait_for_executed_gtid_set(gtid_set, 1);</span></div></pre></div><p>这条命令的逻辑是：</p><ol><li><p>等待，直到这个库执行的事务中包含传入的gtid_set，返回0；</p></li><li><p>超时返回1。</p></li></ol><p>在前面等位点的方案中，我们执行完事务后，还要主动去主库执行show master status。而MySQL 5.7.6版本开始，允许在执行完更新类事务后，把这个事务的GTID返回给客户端，这样等GTID的方案就可以减少一次查询。</p><p>这时，等GTID的执行流程就变成了：</p><ol><li><p>trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1；</p></li><li><p>选定一个从库执行查询语句；</p></li><li><p>在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；</p></li><li><p>如果返回值是0，则在这个从库执行查询语句；</p></li><li><p>否则，到主库执行查询语句。</p></li></ol><p>跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。</p><p>我把这个流程图画出来。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimaged539d521de8017297aff59db2f68170ee739.543d0df6.png" alt=""/></p><p>图7 wait_for_executed_gtid_set方案</p><p>在上面的第一步中，trx1事务更新完成后，从返回包直接获取这个事务的GTID。问题是，怎么能够让MySQL在执行事务后，返回包中带上GTID呢？</p><p>你只需要将参数session_track_gtids设置为OWN_GTID，然后通过API接口mysql_session_track_get_first从返回包解析出GTID的值即可。</p><p>在专栏的<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/68319">第一篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中，我介绍mysql_reset_connection的时候，评论区有同学留言问这类接口应该怎么使用。</p><p>这里我再回答一下。其实，MySQL并没有提供这类接口的SQL用法，是提供给程序的API(<a target="_blank" rel="noopener noreferrer" href="https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html">https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)。</p><p>比如，为了让客户端在事务提交后，返回的GITD能够在客户端显示出来，我对MySQL客户端代码做了点修改，如下所示：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage9763973bdd8741f830acebe005cbf37a7663.776d430c.png" alt=""/></p><p>图8 显示更新事务的GTID--代码</p><p>这样，就可以看到语句执行完成，显示出GITD的值。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage25fe253106d31d9d97aaa2846b2015f593fe.db1ebe14.png" alt=""/></p><p>图9 显示更新事务的GTID--效果</p><p>当然了，这只是一个例子。你要使用这个方案的时候，还是应该在你的客户端代码中调用mysql_session_track_get_first这个函数。</p><h1 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/mysql实战45讲/03.实践篇/20#小结"><span class="icon icon-link"></span></a>小结</h1><p>在今天这篇文章中，我跟你介绍了一主多从做读写分离时，可能碰到过期读的原因，以及几种应对的方案。</p><p>这几种方案中，有的方案看上去是做了妥协，有的方案看上去不那么靠谱儿，但都是有实际应用场景的，你需要根据业务需求选择。</p><p>即使是最后等待位点和等待GTID这两个方案，虽然看上去比较靠谱儿，但仍然存在需要权衡的情况。如果所有的从库都延迟，那么请求就会全部落到主库上，这时候会不会由于压力突然增大，把主库打挂了呢？</p><p>其实，在实际应用中，这几个方案是可以混合使用的。</p><p>比如，先在客户端对请求做分类，区分哪些请求可以接受过期读，而哪些请求完全不能接受过期读；然后，对于不能接受过期读的语句，再使用等GTID或等位点的方案。</p><p>但话说回来，过期读在本质上是由一写多读导致的。在实际应用中，可能会有别的不需要等待就可以水平扩展的数据库方案，但这往往是用牺牲写性能换来的，也就是需要在读性能和写性能中取权衡。</p><p>最后 ，我给你留下一个问题吧。</p><p>假设你的系统采用了我们文中介绍的最后一个方案，也就是等GTID的方案，现在你要对主库的一张大表做DDL，可能会出现什么情况呢？为了避免这种情况，你会怎么做呢？</p><p>你可以把你的分析和方案设计写在评论区，我会在下一篇文章跟你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1 id="上期问题时间"><a aria-hidden="true" tabindex="-1" href="/blog-backend/mysql实战45讲/03.实践篇/20#上期问题时间"><span class="icon icon-link"></span></a>上期问题时间</h1><p>上期给你留的问题是，在GTID模式下，如果一个新的从库接上主库，但是需要的binlog已经没了，要怎么做？</p><p>@某、人同学给了很详细的分析，我把他的回答略做修改贴过来。</p><ol><li><p>如果业务允许主从不一致的情况，那么可以在主库上先执行show global variables like ‘gtid_purged’，得到主库已经删除的GTID集合，假设是gtid_purged1；然后先在从库上执行reset master，再执行set global gtid_purged =‘gtid_purged1’；最后执行start slave，就会从主库现存的binlog开始同步。binlog缺失的那一部分，数据在从库上就可能会有丢失，造成主从不一致。</p></li><li><p>如果需要主从数据一致的话，最好还是通过重新搭建从库来做。</p></li><li><p>如果有其他的从库保留有全量的binlog的话，可以把新的从库先接到这个保留了全量binlog的从库，追上日志以后，如果有需要，再接回主库。</p></li><li><p>如果binlog有备份的情况，可以先在从库上应用缺失的binlog，然后再执行start slave。</p></li></ol><p>评论区留言点赞板：</p><blockquote><p>@悟空 同学级联实验，验证了seconds_behind_master的计算逻辑。</p></blockquote><blockquote><p>@_CountingStars 问了一个好问题：MySQL是怎么快速定位binlog里面的某一个GTID位置的？答案是，在binlog文件头部的Previous_gtids可以解决这个问题。</p></blockquote><blockquote><p>@王朋飞 同学问了一个好问题，sql_slave_skip_counter跳过的是一个event，由于MySQL总不能执行一半的事务，所以既然跳过了一个event，就会跳到这个事务的末尾，因此set global sql_slave_skip_counter=1;start slave是可以跳过整个事务的。</p></blockquote></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/mysql实战45讲/03.实践篇/20.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
