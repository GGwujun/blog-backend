<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>16 | 网络通信：我不想写原生Socket - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/罗剑锋的c实战笔记/05.技能进阶/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a aria-current="page" class="active" href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a aria-current="page" class="active" href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/01.课前导读">01.课前导读</a><ul><li><a href="/blog-backend/罗剑锋的c实战笔记/01.课前导读/01"><span>开篇词 | 把C加加从“神坛”上拉下来，这次咱这么学</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/01.课前导读/02"><span>课前准备 | 搭建实验环境</span></a></li></ul></li><li><a href="/blog-backend/罗剑锋的c实战笔记/02.概论">02.概论</a><ul><li><a href="/blog-backend/罗剑锋的c实战笔记/02.概论/01"><span>01 | 重新认识C加加：生命周期和编程范式</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/02.概论/02"><span>02 | 编码阶段能做什么：秀出好的code style</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/02.概论/03"><span>03 | 预处理阶段能做什么：宏定义和条件编译</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/02.概论/04"><span>04 | 编译阶段能做什么：属性和静态断言</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/02.概论/05"><span>05 | 面向对象编程：怎样才能写出一个“好”的类？</span></a></li></ul></li><li><a href="/blog-backend/罗剑锋的c实战笔记/03.语言特性">03.语言特性</a><ul><li><a href="/blog-backend/罗剑锋的c实战笔记/03.语言特性/01"><span>06 | auto/decltype：为什么要有自动类型推导？</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/03.语言特性/02"><span>07 | const/volatile/mutable：常量/变量究竟是怎么回事？</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/03.语言特性/03"><span>08 | smart_ptr：智能指针到底“智能”在哪里？</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/03.语言特性/04"><span>09 | exception：怎样才能用好异常？</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/03.语言特性/05"><span>10 | lambda：函数式编程带来了什么？</span></a></li></ul></li><li><a href="/blog-backend/罗剑锋的c实战笔记/04.标准库">04.标准库</a><ul><li><a href="/blog-backend/罗剑锋的c实战笔记/04.标准库/01"><span>11 | 一枝独秀的字符串：C加加也能处理文本？</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/04.标准库/02"><span>12 | 三分天下的容器：恰当选择，事半功倍</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/04.标准库/03"><span>13 | 五花八门的算法：不要再手写for循环了</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/04.标准库/04"><span>14 | 十面埋伏的并发：多线程真的很难吗？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/罗剑锋的c实战笔记/05.技能进阶">05.技能进阶</a><ul><li><a href="/blog-backend/罗剑锋的c实战笔记/05.技能进阶/01"><span>15 | 序列化：简单通用的数据交换格式有哪些？</span></a></li><li><a aria-current="page" class="active" href="/blog-backend/罗剑锋的c实战笔记/05.技能进阶/02"><span>16 | 网络通信：我不想写原生Socket</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/05.技能进阶/03"><span>17 | 脚本语言：搭建高性能的混合系统</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/05.技能进阶/04"><span>18 | 性能分析：找出程序的瓶颈</span></a></li></ul></li><li><a href="/blog-backend/罗剑锋的c实战笔记/06.总结篇">06.总结篇</a><ul><li><a href="/blog-backend/罗剑锋的c实战笔记/06.总结篇/01"><span>19 | 设计模式（上）：C加加与设计模式有啥关系？</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/06.总结篇/02"><span>20 | 设计模式（下）：C加加是怎么应用设计模式的？</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/06.总结篇/03"><span>21 | 知识串讲（上）：带你开发一个书店应用</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/06.总结篇/04"><span>22 | 知识串讲（下）：带你开发一个书店应用</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/06.总结篇/05"><span>期末测试 | 这些C加加核心知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-backend/罗剑锋的c实战笔记/07.结束语">07.结束语</a><ul><li><a href="/blog-backend/罗剑锋的c实战笔记/07.结束语/01"><span>结束语 | 路远，未有穷期</span></a></li></ul></li><li><a href="/blog-backend/罗剑锋的c实战笔记/08.轻松话题">08.轻松话题</a><ul><li><a href="/blog-backend/罗剑锋的c实战笔记/08.轻松话题/01"><span>轻松话题（一） | 4本值得一读再读的经典好书</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/08.轻松话题/02"><span>轻松话题（二） | 给你分享我的工作百宝箱</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/08.轻松话题/03"><span>轻松话题（三） | 提高生活质量的App</span></a></li><li><a href="/blog-backend/罗剑锋的c实战笔记/08.轻松话题/04"><span>轻松话题（四） | 真正高效的生活，是张弛有度</span></a></li></ul></li><li><a href="/blog-backend/罗剑锋的c实战笔记/09.特别放送">09.特别放送</a><ul><li><a href="/blog-backend/罗剑锋的c实战笔记/09.特别放送/01"><span>特别放送 | 和你聊聊现代C里的“特殊容器”</span></a></li></ul></li><li><a href="/blog-backend/罗剑锋的c实战笔记/summary">罗剑锋的c实战笔记</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="libcurl：高可移植、功能丰富的通信库" data-depth="2"><a href="/blog-backend/罗剑锋的c实战笔记/05.技能进阶/02#libcurl高可移植功能丰富的通信库"><span>libcurl：高可移植、功能丰富的通信库</span></a></li><li title="cpr：更现代、更易用的通信库" data-depth="2"><a href="/blog-backend/罗剑锋的c实战笔记/05.技能进阶/02#cpr更现代更易用的通信库"><span>cpr：更现代、更易用的通信库</span></a></li><li title="ZMQ：高效、快速、多功能的通信库" data-depth="2"><a href="/blog-backend/罗剑锋的c实战笔记/05.技能进阶/02#zmq高效快速多功能的通信库"><span>ZMQ：高效、快速、多功能的通信库</span></a></li><li title="小结" data-depth="2"><a href="/blog-backend/罗剑锋的c实战笔记/05.技能进阶/02#小结"><span>小结</span></a></li><li title="课下作业" data-depth="2"><a href="/blog-backend/罗剑锋的c实战笔记/05.技能进阶/02#课下作业"><span>课下作业</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="16--网络通信我不想写原生socket"><a aria-hidden="true" tabindex="-1" href="/blog-backend/罗剑锋的c实战笔记/05.技能进阶/02#16--网络通信我不想写原生socket"><span class="icon icon-link"></span></a>16 | 网络通信：我不想写原生Socket</h1><p>你好，我是Chrono。</p><p>在上一节课，我讲了JSON、MessagePack和ProtoBuffer这三种数据交换格式。现在，我们手里有了这些跨语言、跨平台的通用数据，该怎么与外部通信交换呢？</p><p>你肯定首先想到的就是Socket网络编程，使用TCP/IP协议栈收发数据，这样不仅可以在本地的进程间通信，也可以在主机、机房之间异地通信。</p><p>大方向上这是没错的，但你也肯定知道，原生的Socket API非常底层，要考虑很多细节，比如TIME_WAIT、CLOSE_WAIT、REUSEADDR等，如果再加上异步就更复杂了。</p><p>虽然你可能看过、学过不少这方面的资料，对如何处理这些问题“胸有成竹”，但无论如何，像Socket建连/断连、协议格式解析、网络参数调整等，都要自己动手做，想要“凭空”写出一个健壮可靠的网络应用程序还是相当麻烦的。</p><p>所以，今天我就来谈谈C加加里的几个好用的网络通信库：libcurl、cpr和ZMQ，让你摆脱使用原生Socket编程的烦恼。</p><h2 id="libcurl高可移植功能丰富的通信库"><a aria-hidden="true" tabindex="-1" href="/blog-backend/罗剑锋的c实战笔记/05.技能进阶/02#libcurl高可移植功能丰富的通信库"><span class="icon icon-link"></span></a>libcurl：高可移植、功能丰富的通信库</h2><p>第一个要说的库是libcurl，它来源于著名的<a target="_blank" rel="noopener noreferrer" href="https://curl.haxx.se/">curl项目<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，也是curl的底层核心。</p><p>libcurl经过了多年的开发和实际项目的验证，非常稳定可靠，拥有上百万的用户，其中不乏Apple、Facebook、Google、Netflix等大公司。</p><p>它最早只支持HTTP协议，但现在已经扩展到支持所有的应用层协议，比如HTTPS、FTP、LDAP、SMTP等，功能强大。</p><p>libcurl使用纯C语言开发，兼容性、可移植性非常好，基于C接口可以很容易写出各种语言的封装，所以Python、PHP等语言都有libcurl相关的库。</p><p>因为C加加兼容C，所以我们也可以在C加加程序里直接调用libcurl来收发数据。</p><p>在使用libcurl之前，你需要用apt-get或者yum等工具安装开发库：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apt-get install libcurl4-openssl-dev</span></div></pre></div><p>虽然libcurl支持很多协议，但最常用的还是HTTP。所以接下来，我也主要介绍libcurl的HTTP使用方法，这样对其他的协议你也可以做到“触类旁通”。</p><p>libcurl的接口可以粗略地分成两大类：easy系列和multi系列。其中，easy系列是同步调用，比较简单；multi系列是异步的多线程调用，比较复杂。通常情况下，我们用easy系列就足够了。</p><p>使用libcurl收发HTTP数据的基本步骤有4个：</p><ol><li>使用curl_easy_init()创建一个句柄，类型是CURL*。但我们完全没有必要关心句柄的类型，直接用auto推导就行。</li><li>使用curl_easy_setopt()设置请求的各种参数，比如请求方法、URL、header/body数据、超时、回调函数等。这是最关键的操作。</li><li>使用curl_easy_perform()发送数据，返回的数据会由回调函数处理。</li><li>使用curl_easy_cleanup()清理句柄相关的资源，结束会话。</li></ol><p>下面我用个简短的例子来示范一下这4步：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;curl/curl.h&gt;               // 包含头文件</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    auto curl = curl_easy_init();        // 创建CURL句柄</span></div><div class="token-line"><span class="token plain">    assert(curl);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    curl_easy_setopt(curl, CURLOPT_URL, &quot;http://nginx.org&quot;); // 设置请求URI</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    auto res = curl_easy_perform(curl);   // 发送数据</span></div><div class="token-line"><span class="token plain">    if (res != CURLE_OK) {                // 检查是否执行成功</span></div><div class="token-line"><span class="token plain">        cout &lt;&lt; curl_easy_strerror(res) &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    curl_easy_cleanup(curl);             // 清理句柄相关的资源</span></div></pre></div><p>这段代码非常简单，重点是调用curl_easy_setopt()设置了URL，请求Nginx官网的首页，其他的都使用默认值即可。</p><p>由于没有设置你自己的回调函数，所以libcurl会使用内部的默认回调，把得到的HTTP响应数据输出到标准流，也就是直接打印到屏幕上。</p><p>这个处理结果显然不是我们所期待的，所以如果想要自己处理返回的HTTP报文，就得写一个回调函数，在里面实现业务逻辑。</p><p>因为libcurl是C语言实现的，所以回调函数必须是函数指针。不过，C加加11允许你写lambda表达式，这利用了一个特别规定：<strong>无捕获的lambda表达式可以显式转换成一个函数指针</strong>。注意一定要是“无捕获”，也就是说lambda引出符“[]”必须是空的，不能捕获任何外部变量。</p><p>所以，只要多做一个简单的转型动作，你就可以用lambda表达式直接写libcurl的回调，还是熟悉的函数式编程风格：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 回调函数的原型</span></div><div class="token-line"><span class="token plain">    size_t write_callback(char* , size_t , size_t , void* );</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION,        // 设置回调函数</span></div><div class="token-line"><span class="token plain">      (decltype(&amp;write_callback))      // decltype获取函数指针类型，显式转换</span></div><div class="token-line"><span class="token plain">      [](char *ptr, size_t size, size_t nmemb, void *userdata)// lambda</span></div><div class="token-line"><span class="token plain">      {</span></div><div class="token-line"><span class="token plain">          cout &lt;&lt; &quot;size = &quot; &lt;&lt; size * nmemb &lt;&lt; endl;   // 简单的处理</span></div><div class="token-line"><span class="token plain">          return size * nmemb;                // 返回接收的字节数</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    );</span></div></pre></div><p>libcurl的用法大概就是这个样子了，开头的准备和结尾的清理工作都很简单，关键的就是curl_easy_setopt()这一步的参数设置。我们必须通过查文档知道该用哪些标志宏，写一些单调重复的代码。</p><p>你可能想到了，可以自己用C加加包装出一个类，就能够少敲点键盘。但不要着急，因为我们有一个更好的选择，就是cpr。</p><h2 id="cpr更现代更易用的通信库"><a aria-hidden="true" tabindex="-1" href="/blog-backend/罗剑锋的c实战笔记/05.技能进阶/02#cpr更现代更易用的通信库"><span class="icon icon-link"></span></a>cpr：更现代、更易用的通信库</h2><p>cpr是对libcurl的一个C加加11封装，使用了很多现代C加加的高级特性，对外的接口模仿了Python的requests库，非常简单易用。</p><p>你可以从<a target="_blank" rel="noopener noreferrer" href="https://github.com/whoshuu/cpr">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上获取cpr的源码，再用cmake编译安装：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">git clone git@github.com:whoshuu/cpr.git</span></div><div class="token-line"><span class="token plain">    cmake . -DUSE_SYSTEM_CURL=ON -DBUILD_CPR_TESTS=OFF</span></div><div class="token-line"><span class="token plain">    make &amp;&amp; make install</span></div></pre></div><p>和libcurl相比，cpr用起来真的是太轻松了，不需要考虑什么初始化、设置参数、清理等杂事，一句话就能发送HTTP请求：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;cpr/cpr.h&gt;                            // 包含头文件</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    auto res = cpr::Get(                           // GET请求    </span></div><div class="token-line"><span class="token plain">               cpr::Url{&quot;http://openresty.org&quot;}   // 传递URL</span></div><div class="token-line"><span class="token plain">    );</span></div></pre></div><p>你也不用写回调函数，HTTP响应就是函数的返回值，用成员变量url、header、status_code、text就能够得到报文的各个组成部分：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">cout &lt;&lt; res.elapsed &lt;&lt; endl;            // 请求耗费的时间</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    cout &lt;&lt; res.url &lt;&lt; endl;               // 请求的URL</span></div><div class="token-line"><span class="token plain">    cout &lt;&lt; res.status_code &lt;&lt; endl;       // 响应的状态码</span></div><div class="token-line"><span class="token plain">    cout &lt;&lt; res.text.length() &lt;&lt; endl;     // 响应的body数据</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    for(auto&amp; x : res.header) {            // 响应的头字段</span></div><div class="token-line"><span class="token plain">        cout &lt;&lt; x.first &lt;&lt; &quot;=&gt;&quot;            // 类似map的结构</span></div><div class="token-line"><span class="token plain">             &lt;&lt; x.second &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在cpr里，HTTP协议的概念都被实现为相应的函数或者类，内部再转化为libcurl操作，主要的有：</p><ul><li>GET/HEAD/POST等请求方法，使用同名的Get/Head/Post函数；</li><li>URL使用Url类，它其实是string的别名；</li><li>URL参数使用Parameters类，KV结构，近似map；</li><li>请求头字段使用Header类，它其实是map的别名，使用定制的函数实现了大小写无关比较；</li><li>Cookie使用Cookies类，也是KV结构，近似map；</li><li>请求体使用Body类；</li><li>超时设置使用Timeout类。</li></ul><p>这些函数和类的用法都非常自然、符合思维习惯，而且因为可以使用C加加11的花括号“<!-- -->{<!-- -->}<!-- -->”初始化语法，如果你以前用过Python reqeusts库的话一定会感到很亲切：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const auto url = &quot;http://openresty.org&quot;s;  // 访问的URL</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    auto res1 = cpr::Head(                    // 发送HEAD请求</span></div><div class="token-line"><span class="token plain">                cpr::Url{url}                 // 传递URL</span></div><div class="token-line"><span class="token plain">    );</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    auto res2 = cpr::Get(                     // 发送GET请求</span></div><div class="token-line"><span class="token plain">                cpr::Url{url},               // 传递URL</span></div><div class="token-line"><span class="token plain">                cpr::Parameters{             // 传递URL参数</span></div><div class="token-line"><span class="token plain">                    {&quot;a&quot;, &quot;1&quot;}, {&quot;b&quot;, &quot;2&quot;}}</span></div><div class="token-line"><span class="token plain">    );</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    auto res3 = cpr::Post(                  // 发送POST请求</span></div><div class="token-line"><span class="token plain">                cpr::Url{url},             // 传递URL</span></div><div class="token-line"><span class="token plain">                cpr::Header{                // 定制请求头字段</span></div><div class="token-line"><span class="token plain">                  {&quot;x&quot;, &quot;xxx&quot;},{&quot;expect&quot;,&quot;&quot;}},</span></div><div class="token-line"><span class="token plain">                cpr::Body{&quot;post data&quot;},    // 传递body数据</span></div><div class="token-line"><span class="token plain">                cpr::Timeout{200ms}       // 超时时间</span></div><div class="token-line"><span class="token plain">    );</span></div></pre></div><p>cpr也支持异步处理，但它内部没有使用libcurl的multi接口，而是使用了标准库里的future和async（参见<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/245259">第14讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），和libcurl的实现相比，既简单又好理解。</p><p>异步接口与同步接口的调用方式基本一样，只是名字多了个“Async”的后缀，返回的是一个future对象。你可以调用wait()或者get()来获取响应结果：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">auto f = cpr::GetAsync(                    // 异步发送GET请求</span></div><div class="token-line"><span class="token plain">                cpr::Url{&quot;http://openresty.org&quot;}</span></div><div class="token-line"><span class="token plain">    );</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    auto res = f.get();                       // 等待响应结果</span></div><div class="token-line"><span class="token plain">    cout &lt;&lt; res.elapsed &lt;&lt; endl;              // 请求耗费的时间</span></div></pre></div><p>看了上面这些介绍，你是不是有些心动了。说实话，我原来在C加加里也是一直用libcurl，也写过自己的包装类，直到发现了cpr这个“大杀器”，就立即“弃暗投明”了。</p><p>相信有了cpr，你今后在C加加里写HTTP应用就不再是痛苦，而是一种享受了。</p><h2 id="zmq高效快速多功能的通信库"><a aria-hidden="true" tabindex="-1" href="/blog-backend/罗剑锋的c实战笔记/05.技能进阶/02#zmq高效快速多功能的通信库"><span class="icon icon-link"></span></a>ZMQ：高效、快速、多功能的通信库</h2><p>libcurl和cpr处理的都是HTTP协议，虽然用起来很方便，但协议自身也有一些限制，比如必须要一来一回，必须点对点直连，在超大数据量通信的时候就不是太合适。</p><p>还有一点，libcurl和cpr只能充当HTTP的客户端，如果你想写服务器端程序，这两个工具就完全派不上用场。</p><p>所以，我们就需要一个更底层、更灵活的网络通信工具，它应该能够弥补libcurl和cpr的不足，不仅快速高效，还能同时支持客户端和服务器端编程。</p><p>这就是我要说的第三个库：<a target="_blank" rel="noopener noreferrer" href="https://zeromq.org/">ZMQ<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>其实，ZMQ不仅是一个单纯的网络通信库，更像是一个高级的异步并发框架。</p><p>从名字上就可以看出来，Zero Message Queue——零延迟的消息队列，意味着它除了可以收发数据外，还可以用作消息中间件，解耦多个应用服务之间的强依赖关系，搭建高效、有弹性的分布式系统，从而超越原生的Socket。</p><p>作为消息队列，ZMQ的另一大特点是零配置零维护零成本，不需要搭建额外的代理服务器，只要安装了开发库就能够直接使用，相当于把消息队列功能直接嵌入到你的应用程序里：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apt-get install libzmq3-dev</span></div></pre></div><p>ZMQ是用C加加开发的，但出于兼容的考虑，对外提供的是纯C接口。不过它也有很多C加加封装，这里我选择的是自带的<a target="_blank" rel="noopener noreferrer" href="https://github.com/zeromq/cppzmq">cppzmq<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，虽然比较简单，但也基本够用了。</p><p>由于ZMQ把自身定位于更高层次的“异步消息队列”，所以它的用法就不像Socket、HTTP那么简单直白，而是定义了5种不同的工作模式，来适应实际中常见的网络通信场景。</p><p>我来大概说一下这5种模式：</p><ul><li>原生模式（RAW），没有消息队列功能，相当于底层Socket的简单封装；</li><li>结对模式（PAIR），两个端点一对一通信；</li><li>请求响应模式（REQ-REP），也是两个端点一对一通信，但请求必须有响应；</li><li>发布订阅模式（PUB-SUB），一对多通信，一个端点发布消息，多个端点接收处理；</li><li>管道模式（PUSH-PULL），或者叫流水线，可以一对多，也可以多对一。</li></ul><p>前四种模式类似HTTP协议、Client-Server架构，很简单，就不多说了。我拿我在工作中比较常用的管道模式来给你示范一下ZMQ的用法，它非常适合进程间无阻塞传送海量数据，也有点map-reduce的意思。</p><p><img src="data:image/png;base64,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" alt=""/></p><p>在ZMQ里有两个基本的类。</p><ul><li>第一个是context_t，它是ZMQ的运行环境。使用ZMQ的任何功能前，必须要先创建它。</li><li>第二个是socket_t，表示ZMQ的套接字，需要指定刚才说的那5种工作模式。注意它与原生Socket没有任何关系，只是借用了名字来方便理解。</li></ul><p>下面的代码声明了一个全局的ZMQ环境变量，并定义了一个lambda表达式，生产ZMQ套接字：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const auto thread_num = 1;              // 并发线程数</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    zmq::context_t context(thread_num);     // ZMQ环境变量</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    auto make_sock = [&amp;](auto mode)        // 定义一个lambda表达式</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        return zmq::socket_t(context, mode); // 创建ZMQ套接字</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>和原生Socket一样，ZMQ套接字也必须关联到一个确定的地址才能收发数据，但它不仅支持TCP/IP，还支持进程内和进程间通信，这在本机交换数据时会更高效：</p><ul><li>TCP通信地址的形式是“tcp://…”，指定IP地址和端口号；</li><li>进程内通信地址的形式是“inproc://…”，指定一个本地可访问的路径；</li><li>进程间通信地址的形式是“ipc://…”，也是一个本地可访问的路径。</li></ul><p>用bind()/connect()这两个函数把ZMQ套接字连接起来之后，就可以用send()/recv()来收发数据了，看一下示例代码吧：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const auto addr = &quot;ipc:///dev/shm/zmq.sock&quot;s;  // 通信地址</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    auto receiver = [=]()                     // lambda表达式接收数据</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        auto sock = make_sock(ZMQ_PULL);      // 创建ZMQ套接字，拉数据</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        sock.bind(addr);                     // 绑定套接字</span></div><div class="token-line"><span class="token plain">        assert(sock.connected());</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        zmq::message_t msg;</span></div><div class="token-line"><span class="token plain">        sock.recv(&amp;msg);                      // 接收消息</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        string s = {msg.data&lt;char&gt;(), msg.size()};</span></div><div class="token-line"><span class="token plain">        cout &lt;&lt; s &lt;&lt; endl;</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    auto sender = [=]()                     // lambda表达式发送数据</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        auto sock = make_sock(ZMQ_PUSH);     // 创建ZMQ套接字，推数据</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        sock.connect(addr);                  // 连接到对端</span></div><div class="token-line"><span class="token plain">        assert(sock.connected());</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        string s = &quot;hello zmq&quot;;</span></div><div class="token-line"><span class="token plain">        sock.send(s.data(), s.size());       // 发送消息</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>这段代码实现了两个最基本的客户端和服务器，看起来好像没什么特别的。但你应该注意到，使用ZMQ完全不需要考虑底层的TCP/IP通信细节，它会保证消息异步、安全、完整地到达服务器，让你关注网络通信之上更有价值的业务逻辑。</p><p>ZMQ的用法就是这么简单，但想要进一步发掘它的潜力，处理大流量的数据还是要去看<a target="_blank" rel="noopener noreferrer" href="http://wiki.zeromq.org/">它的文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，选择合适的工作模式，再仔细调节各种参数。</p><p>接下来，我再给你分享两个实际工作中会比较有用的细节吧。</p><p>一个是<strong>ZMQ环境的线程数</strong>。它的默认值是1，太小了，适当增大一些就可以提高ZMQ的并发处理能力。我一般用的是4~6，具体设置为多少最好还是通过性能测试来验证下。</p><p>另一个是<strong>收发消息时的本地缓存数量</strong>，ZMQ的术语叫High Water Mark。如果收发的数据过多，数量超过HWM，ZMQ要么阻塞，要么丢弃消息。</p><p>HWM需要调用套接字的成员函数setsockopt()来设置，注意收发使用的是两个不同的标志：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sock.setsockopt(ZMQ_RCVHWM, 1000);     // 接收消息最多缓存1000条</span></div><div class="token-line"><span class="token plain">    sock.setsockopt(ZMQ_SNDHWM, 100);      // 发送消息最多缓存100条</span></div></pre></div><p>我们把HWM设置成多大都可以，比如我就曾经在一个高并发系统里用过100万以上的值，不用担心，ZMQ会把一切都处理得很好。</p><p>关于ZMQ就暂时说到这里，它还有很多强大的功能，你可以阅读<a target="_blank" rel="noopener noreferrer" href="http://zguide.zeromq.org/page:all">官网<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上的教程和指南，里面非常详细地讨论了ZMQ的各种模式和要点。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/罗剑锋的c实战笔记/05.技能进阶/02#小结"><span class="icon icon-link"></span></a>小结</h2><p>好了，我来给今天的内容做一个小结：</p><ol><li>libcurl是一个功能完善、稳定可靠的应用层通信库，最常用的就是HTTP协议；</li><li>cpr是对libcurl的C加加封装，接口简单易用；</li><li>libcurl和cpr都只能作为客户端来使用，不能编写服务器端应用；</li><li>ZMQ是一个高级的网络通信库，支持多种通信模式，可以把消息队列功能直接嵌入应用程序，搭建出高效、灵活、免管理的分布式系统。</li></ol><p>最后，再说说即将到来的C加加20，原本预计会加入期待已久的networking库，但现在已经被推迟到了下一个版本（C加加23）。</p><p>networking库基于已有多年实践的boost.asio，采用前摄器模式（Proactor）统一封装了操作系统的各种异步机制（epoll、kqueue、IOCP），而且支持协程。有了它，我们的网络通信工作就会更加轻松。</p><h2 id="课下作业"><a aria-hidden="true" tabindex="-1" href="/blog-backend/罗剑锋的c实战笔记/05.技能进阶/02#课下作业"><span class="icon icon-link"></span></a>课下作业</h2><p>最后是课下作业时间，给你留两个思考题：</p><ol><li>你在网络编程的时候都遇到过哪些“坑”，今天说的这几个库能否解决你的问题？</li><li>你觉得ZMQ能够在多大程度上代替原生Socket？</li></ol><p>欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友。我们下节课见。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage3edd3e07516e87c61172f9b2ddc317c74add.994ed60e.jpg" alt=""/></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/罗剑锋的c实战笔记/05.技能进阶/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
