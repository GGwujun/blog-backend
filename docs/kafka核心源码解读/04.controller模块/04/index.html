<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-backend/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-backend";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>14 | Controller选举是怎么实现的？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/kafka核心源码解读/04.controller模块/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a aria-current="page" class="active" href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></span><span>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-backend/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-backend/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-backend/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-backend/go语言项目开发实战">go语言项目开发实战</a></li><li><a href="/blog-backend/kafka核心技术与实战">kafka核心技术与实战</a></li><li><a aria-current="page" class="active" href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/零基础学python">零基础学python</a></li><li><a href="/blog-backend/python核心技术与实战">python核心技术与实战</a></li><li><a href="/blog-backend/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-backend/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-backend/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-backend/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-backend/后端存储实战课">后端存储实战课</a></li><li><a href="/blog-backend/后端技术面试38讲">后端技术面试38讲</a></li><li><a href="/blog-backend/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-backend/现代c编程实战">现代c编程实战</a></li><li><a href="/blog-backend/罗剑锋的c实战笔记">罗剑锋的c实战笔记</a></li><li><a href="/blog-backend/零基础入门spark">零基础入门spark</a></li></ul></li><li>架构师<ul><li><a href="/blog-backend/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-backend/数据中台实战课">数据中台实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-backend/kafka核心源码解读">kafka核心源码解读</a></li><li><a href="/blog-backend/kafka核心源码解读/01.课前必学">01.课前必学</a><ul><li><a href="/blog-backend/kafka核心源码解读/01.课前必学/01"><span>开篇词 |  阅读源码，逐渐成了职业进阶道路上的“必选项”</span></a></li><li><a href="/blog-backend/kafka核心源码解读/01.课前必学/02"><span>导读 | 构建Kafka工程和源码阅读环境、Scala语言热身</span></a></li><li><a href="/blog-backend/kafka核心源码解读/01.课前必学/03"><span>重磅加餐 | 带你快速入门Scala语言</span></a></li></ul></li><li><a href="/blog-backend/kafka核心源码解读/02.日志模块">02.日志模块</a><ul><li><a href="/blog-backend/kafka核心源码解读/02.日志模块/01"><span>01 | 日志段：保存消息文件的对象是怎么实现的？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/02.日志模块/02"><span>02 | 日志（上）：日志究竟是如何加载日志段的？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/02.日志模块/03"><span>03 | 日志（下）：彻底搞懂Log对象的常见操作</span></a></li><li><a href="/blog-backend/kafka核心源码解读/02.日志模块/04"><span>04 | 索引（上）：改进的二分查找算法在Kafka索引的应用</span></a></li><li><a href="/blog-backend/kafka核心源码解读/02.日志模块/05"><span>05 | 索引（下）：位移索引和时间戳索引的区别是什么？</span></a></li></ul></li><li><a href="/blog-backend/kafka核心源码解读/03.请求处理模块">03.请求处理模块</a><ul><li><a href="/blog-backend/kafka核心源码解读/03.请求处理模块/01"><span>06 | 请求通道：如何实现Kafka请求队列？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/03.请求处理模块/02"><span>07 | SocketServer（上）：Kafka到底是怎么应用NIO实现网络通信的？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/03.请求处理模块/03"><span>08 | SocketServer（中）：请求还要区分优先级？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/03.请求处理模块/04"><span>09 | SocketServer（下）：请求处理全流程源码分析</span></a></li><li><a href="/blog-backend/kafka核心源码解读/03.请求处理模块/05"><span>10 | KafkaApis：Kafka最重要的源码入口，没有之一</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-backend/kafka核心源码解读/04.controller模块">04.Controller模块</a><ul><li><a href="/blog-backend/kafka核心源码解读/04.controller模块/01"><span>11 | Controller元数据：Controller都保存有哪些东西？有几种状态？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/04.controller模块/02"><span>12 | ControllerChannelManager：Controller如何管理请求发送？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/04.controller模块/03"><span>13 | ControllerEventManager：变身单线程后的Controller如何处理事件？</span></a></li><li><a aria-current="page" class="active" href="/blog-backend/kafka核心源码解读/04.controller模块/04"><span>14 | Controller选举是怎么实现的？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/04.controller模块/05"><span>15 | 如何理解Controller在Kafka集群中的作用？</span></a></li></ul></li><li><a href="/blog-backend/kafka核心源码解读/05.状态机模块">05.状态机模块</a><ul><li><a href="/blog-backend/kafka核心源码解读/05.状态机模块/01"><span>16 | TopicDeletionManager： Topic是怎么被删除的？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/05.状态机模块/02"><span>17 | ReplicaStateMachine：揭秘副本状态机实现原理</span></a></li><li><a href="/blog-backend/kafka核心源码解读/05.状态机模块/03"><span>18 | PartitionStateMachine：分区状态转换如何实现？</span></a></li></ul></li><li><a href="/blog-backend/kafka核心源码解读/06.延迟操作模块">06.延迟操作模块</a><ul><li><a href="/blog-backend/kafka核心源码解读/06.延迟操作模块/01"><span>19 | TimingWheel：探究Kafka定时器背后的高效时间轮算法</span></a></li><li><a href="/blog-backend/kafka核心源码解读/06.延迟操作模块/02"><span>20 | DelayedOperation：Broker是怎么延时处理请求的？</span></a></li></ul></li><li><a href="/blog-backend/kafka核心源码解读/07.副本管理模块">07.副本管理模块</a><ul><li><a href="/blog-backend/kafka核心源码解读/07.副本管理模块/01"><span>21 | AbstractFetcherThread：拉取消息分几步？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/07.副本管理模块/02"><span>22 | ReplicaFetcherThread：Follower如何拉取Leader消息？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/07.副本管理模块/03"><span>23 | ReplicaManager（上）：必须要掌握的副本管理类定义和核心字段</span></a></li><li><a href="/blog-backend/kafka核心源码解读/07.副本管理模块/04"><span>24 | ReplicaManager（中）：副本管理器是如何读写副本的？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/07.副本管理模块/05"><span>25 | ReplicaManager（下）：副本管理器是如何管理副本的？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/07.副本管理模块/06"><span>26 | MetadataCache：Broker是怎么异步更新元数据缓存的？</span></a></li></ul></li><li><a href="/blog-backend/kafka核心源码解读/08.消费者组管理模块">08.消费者组管理模块</a><ul><li><a href="/blog-backend/kafka核心源码解读/08.消费者组管理模块/01"><span>27 | 消费者组元数据（上）：消费者组都有哪些元数据？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/08.消费者组管理模块/02"><span>28 | 消费者组元数据（下）：Kafka如何管理这些元数据？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/08.消费者组管理模块/03"><span>29 | GroupMetadataManager：组元数据管理器是个什么东西？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/08.消费者组管理模块/04"><span>30 | GroupMetadataManager：位移主题保存的只是位移吗？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/08.消费者组管理模块/05"><span>31 | GroupMetadataManager：查询位移时，不用读取位移主题？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/08.消费者组管理模块/06"><span>32 | GroupCoordinator：在Rebalance中，Coordinator如何处理成员入组？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/08.消费者组管理模块/07"><span>33 | GroupCoordinator：在Rebalance中，如何进行组同步？</span></a></li></ul></li><li><a href="/blog-backend/kafka核心源码解读/09.特别放送">09.特别放送</a><ul><li><a href="/blog-backend/kafka核心源码解读/09.特别放送/01"><span>特别放送（一）| 经典的Kafka学习资料有哪些？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/09.特别放送/02"><span>特别放送（二）| 一篇文章带你了解参与开源社区的全部流程</span></a></li><li><a href="/blog-backend/kafka核心源码解读/09.特别放送/03"><span>特别放送（三）| 我是怎么度过日常一天的？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/09.特别放送/04"><span>特别放送（四）| 20道经典的Kafka面试题详解</span></a></li><li><a href="/blog-backend/kafka核心源码解读/09.特别放送/05"><span>特别放送（五） | Kafka 社区的重磅功能：移除 ZooKeeper 依赖</span></a></li></ul></li><li><a href="/blog-backend/kafka核心源码解读/10.测试题">10.测试题</a><ul><li><a href="/blog-backend/kafka核心源码解读/10.测试题/01"><span>期中测试 | 这些源码知识，你都掌握了吗？</span></a></li><li><a href="/blog-backend/kafka核心源码解读/10.测试题/02"><span>期末测试 | 一套习题，测试你的掌握程度</span></a></li></ul></li><li><a href="/blog-backend/kafka核心源码解读/11.结束语">11.结束语</a><ul><li><a href="/blog-backend/kafka核心源码解读/11.结束语/01"><span>结束语 | 源码学习，我们才刚上路呢</span></a></li></ul></li><li><a href="/blog-backend/kafka核心源码解读/summary">kafka核心源码解读</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="概览" data-depth="2"><a href="/blog-backend/kafka核心源码解读/04.controller模块/04#概览"><span>概览</span></a></li><li title="ZooKeeper /controller节点" data-depth="3"><a href="/blog-backend/kafka核心源码解读/04.controller模块/04#zookeeper-controller节点"><span>ZooKeeper /controller节点</span></a></li><li title="源码结构" data-depth="3"><a href="/blog-backend/kafka核心源码解读/04.controller模块/04#源码结构"><span>源码结构</span></a></li><li title="KafkaController类" data-depth="2"><a href="/blog-backend/kafka核心源码解读/04.controller模块/04#kafkacontroller类"><span>KafkaController类</span></a></li><li title="原生字段" data-depth="3"><a href="/blog-backend/kafka核心源码解读/04.controller模块/04#原生字段"><span>原生字段</span></a></li><li title="辅助字段" data-depth="3"><a href="/blog-backend/kafka核心源码解读/04.controller模块/04#辅助字段"><span>辅助字段</span></a></li><li title="各类ZooKeeper监听器" data-depth="3"><a href="/blog-backend/kafka核心源码解读/04.controller模块/04#各类zookeeper监听器"><span>各类ZooKeeper监听器</span></a></li><li title="统计字段" data-depth="3"><a href="/blog-backend/kafka核心源码解读/04.controller模块/04#统计字段"><span>统计字段</span></a></li><li title="ControllerChangeHandler监听器" data-depth="2"><a href="/blog-backend/kafka核心源码解读/04.controller模块/04#controllerchangehandler监听器"><span>ControllerChangeHandler监听器</span></a></li><li title="Controller选举流程" data-depth="2"><a href="/blog-backend/kafka核心源码解读/04.controller模块/04#controller选举流程"><span>Controller选举流程</span></a></li><li title="触发选举" data-depth="3"><a href="/blog-backend/kafka核心源码解读/04.controller模块/04#触发选举"><span>触发选举</span></a></li><li title="选举Controller" data-depth="3"><a href="/blog-backend/kafka核心源码解读/04.controller模块/04#选举controller"><span>选举Controller</span></a></li><li title="总结" data-depth="2"><a href="/blog-backend/kafka核心源码解读/04.controller模块/04#总结"><span>总结</span></a></li><li title="课后讨论" data-depth="2"><a href="/blog-backend/kafka核心源码解读/04.controller模块/04#课后讨论"><span>课后讨论</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="14--controller选举是怎么实现的"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心源码解读/04.controller模块/04#14--controller选举是怎么实现的"><span class="icon icon-link"></span></a>14 | Controller选举是怎么实现的？</h1><p>你好，我是胡夕。</p><p>上节课，我们学习了单线程事件队列模型处理Controller事件的代码。Controller组件通过ControllerEventManager类构造了一个阻塞队列，同时配以专属的事件处理线程，实现了对各类ControllerEvent的处理。</p><p>这种设计思路既保证了多线程访问所需的线程安全，还简化了Controller端的代码结构，极大地提升了代码的可维护性。</p><p>今天，我们学习下Controller选举部分的源码。</p><p>还记得我在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/235562">第11节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的案例中提到的“恢复大法”——删除ZooKeeper的/controller节点吗？当时，我们靠着这个“秘籍”涉险过关，既恢复了错误的集群状态，又避免了重启整个生产环境。</p><p>但你有没有想过，为什么删除/controller节点能够令集群元数据重新保持同步呢？如果不了解这背后的原理，我们是不敢贸然在生产环境做这种操作的。今天，我们要学习的就是这背后的一整套实现逻辑，重点关注下Controller是怎么被选举出来的。</p><p>我始终认为，只有掌握了这些知识，才算真正入门Kafka服务器端的代码了。作为Broker端最重要的组件之一，Controller在Kafka中的地位无可替代。整个Kafka集群就只有一个Controller，从某种意义上来说，它是目前Kafka这个分布式系统中唯一的“单点”。</p><p>因此，了解这个“单点”的选举触发场景，以及如何被选举出来的，对于我们后面深入理解Controller在集群中的作用非常有帮助。毕竟，Controller对外提供的一些服务也是采用了类似的实现原理。</p><h2 id="概览"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心源码解读/04.controller模块/04#概览"><span class="icon icon-link"></span></a>概览</h2><h3 id="zookeeper-controller节点"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心源码解读/04.controller模块/04#zookeeper-controller节点"><span class="icon icon-link"></span></a>ZooKeeper /controller节点</h3><p>再次强调下，<strong>在一个Kafka集群中，某段时间内只能有一台Broker被选举为Controller。随着时间的推移，可能会有不同的Broker陆续担任过Controller的角色，但是在某一时刻，Controller只能由一个Broker担任</strong>。</p><p>那选择哪个Broker充当Controller呢？当前，Controller的选举过程依赖ZooKeeper完成。ZooKeeper除了扮演集群元数据的“真理之源”角色，还定义了/controller临时节点（Ephemeral Node），以协助完成Controller的选举。</p><p>下面这段代码展示的是一个双Broker的Kafka集群上的ZooKeeper中/controller节点：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">{&quot;version&quot;:1,&quot;brokerid&quot;:0,&quot;timestamp&quot;:&quot;1585098432431&quot;}</span></div><div class="token-line"><span class="token plain">    cZxid = 0x1a</span></div><div class="token-line"><span class="token plain">    ctime = Wed Mar 25 09:07:12 CST 2020</span></div><div class="token-line"><span class="token plain">    mZxid = 0x1a</span></div><div class="token-line"><span class="token plain">    mtime = Wed Mar 25 09:07:12 CST 2020</span></div><div class="token-line"><span class="token plain">    pZxid = 0x1a</span></div><div class="token-line"><span class="token plain">    cversion = 0</span></div><div class="token-line"><span class="token plain">    dataVersion = 0</span></div><div class="token-line"><span class="token plain">    aclVersion = 0</span></div><div class="token-line"><span class="token plain">    ephemeralOwner = 0x100002d3a1f0000</span></div><div class="token-line"><span class="token plain">    dataLength = 54</span></div><div class="token-line"><span class="token plain">    numChildren = 0</span></div></pre></div><p>有两个地方的内容，你要重点关注一下。</p><ul><li>Controller Broker Id是0，表示序号为0的Broker是集群Controller。</li><li>ephemeralOwner字段不是0x0，说明这是一个临时节点。</li></ul><p>既然是临时节点，那么，一旦Broker与ZooKeeper的会话终止，该节点就会消失。Controller选举就依靠了这个特性。每个Broker都会监听/controller节点随时准备应聘Controller角色。下图展示了Broker与/controller节点的交互关系：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage2e832e75cdbfb68c86169ec83f58e59e1283.eed6fa7c.jpg" alt=""/></p><p>如图所示，集群上所有的Broker都在实时监听ZooKeeper上的这个节点。这里的“监听”有两个含义。</p><ul><li><strong>监听这个节点是否存在</strong>。倘若发现这个节点不存在，Broker会立即“抢注”该节点，即创建/controller节点。创建成功的那个Broker，即当选为新一届的Controller。</li><li><strong>监听这个节点数据是否发生了变更</strong>。同样，一旦发现该节点的内容发生了变化，Broker也会立即启动新一轮的Controller选举。</li></ul><p>掌握了这些基础之后，下面我们来阅读具体的源码文件：KafkaController.scala。这是一个2200行的大文件。我先向你介绍一下这个文件的大致结构，以免你陷入到一些繁枝末节中。</p><h3 id="源码结构"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心源码解读/04.controller模块/04#源码结构"><span class="icon icon-link"></span></a>源码结构</h3><p>KafkaController文件的代码结构如下图所示：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage7e887e5ddb69df585b5bbbcc91336ab8f588.bec0b752.jpg" alt=""/></p><p>整体而言，该文件大致由五部分组成。</p><ul><li><strong>选举触发器</strong>（ElectionTrigger）：这里的选举不是指Controller选举，而是指主题分区副本的选举，即为哪些分区选择Leader副本。后面在学习副本管理器和分区管理器时，我们会讲到它。</li><li><strong>KafkaController Object</strong>：KafkaController伴生对象，仅仅定义了一些常量和回调函数类型。</li><li><strong>ControllerEvent</strong>：定义Controller事件类型。上节课我们详细学习过Controller事件以及基于事件的单线程事件队列模型。这部分的代码看着很多，但实际上都是千篇一律的。你看懂了一个事件的定义，其他的也就不在话下了。</li><li><strong>各种ZooKeeper监听器</strong>：定义ZooKeeper监听器，去监听ZooKeeper中各个节点的变更。今天，我们重点关注监听/controller节点的那个监听器。</li><li><strong>KafkaController Class</strong>：定义KafkaController类以及实际的处理逻辑。这是我们今天的重点学习对象。</li></ul><p>接下来，我会给你重点介绍KafkaController类、ZooKeeper监听器和Controller选举这三大部分。在众多的ZooKeeper监听器中，我会详细介绍监听Controller变更的监听器，它也是我们了解Controller选举流程的核心环节。</p><h2 id="kafkacontroller类"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心源码解读/04.controller模块/04#kafkacontroller类"><span class="icon icon-link"></span></a>KafkaController类</h2><p>这个类大约有1900行代码，里面定义了非常多的变量和方法。这些方法大多是处理不同Controller事件的。后面讲到选举流程的时候，我会挑一些有代表性的来介绍。我希望你能举一反三，借此吃透其他方法的代码。毕竟，它们做的事情大同小异，至少代码风格非常相似。</p><p>在学习重要的方法之前，我们必须要先掌握KafkaController类的定义。接下来，我们从4个维度来进行学习，分别是原生字段、辅助字段、各类ZooKeeper监听器字段和统计字段。</p><p>弄明白了这些字段的含义之后，再去看操作这些字段的方法，会更加有的放矢，理解起来也会更加容易。</p><h3 id="原生字段"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心源码解读/04.controller模块/04#原生字段"><span class="icon icon-link"></span></a>原生字段</h3><p>首先来看原生字段。所谓的原生字段，是指在创建一个KafkaController实例时，需要指定的字段。</p><p>先来看下KafkaController类的定义代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 字段含义：</span></div><div class="token-line"><span class="token plain">    // config：Kafka配置信息，通过它，你能拿到Broker端所有参数的值</span></div><div class="token-line"><span class="token plain">    // zkClient：ZooKeeper客户端，Controller与ZooKeeper的所有交互均通过该属性完成</span></div><div class="token-line"><span class="token plain">    // time：提供时间服务(如获取当前时间)的工具类</span></div><div class="token-line"><span class="token plain">    // metrics：实现指标监控服务(如创建监控指标)的工具类</span></div><div class="token-line"><span class="token plain">    // initialBrokerInfo：Broker节点信息，包括主机名、端口号，所用监听器等</span></div><div class="token-line"><span class="token plain">    // initialBrokerEpoch：Broker Epoch值，用于隔离老Controller发送的请求</span></div><div class="token-line"><span class="token plain">    // tokenManager：实现Delegation token管理的工具类。Delegation token是一种轻量级的认证机制</span></div><div class="token-line"><span class="token plain">    // threadNamePrefix：Controller端事件处理线程名字前缀</span></div><div class="token-line"><span class="token plain">    class KafkaController(val config: KafkaConfig,</span></div><div class="token-line"><span class="token plain">                          zkClient: KafkaZkClient,</span></div><div class="token-line"><span class="token plain">                          time: Time,</span></div><div class="token-line"><span class="token plain">                          metrics: Metrics,</span></div><div class="token-line"><span class="token plain">                          initialBrokerInfo: BrokerInfo,</span></div><div class="token-line"><span class="token plain">                          initialBrokerEpoch: Long,</span></div><div class="token-line"><span class="token plain">                          tokenManager: DelegationTokenManager,</span></div><div class="token-line"><span class="token plain">                          threadNamePrefix: Option[String] = None)</span></div><div class="token-line"><span class="token plain">      extends ControllerEventProcessor with Logging with KafkaMetricsGroup {</span></div><div class="token-line"><span class="token plain">      ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>就像我上节课说过的，KafkaController实现了ControllerEventProcessor接口，因而也就实现了处理Controller事件的process方法。这里面比较重要的字段有3个。</p><ul><li><strong>config</strong>：KafkaConfig类实例，里面封装了Broker端所有参数的值。</li><li><strong>zkClient</strong>：ZooKeeper客户端类，定义了与ZooKeeper交互的所有方法。</li><li><strong>initialBrokerEpoch</strong>：Controller所在Broker的Epoch值。Kafka使用它来确保Broker不会处理老Controller发来的请求。</li></ul><p>其他字段要么是像time、metrics一样，是工具类字段，要么是像initialBrokerInfo、tokenManager字段一样，使用场景很有限，我就不展开讲了。</p><h3 id="辅助字段"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心源码解读/04.controller模块/04#辅助字段"><span class="icon icon-link"></span></a>辅助字段</h3><p>除了原生字段之外，KafkaController还定义了很多辅助字段，帮助实现Controller的各类功能。</p><p>我们来看一些重要的辅助字段：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">......</span></div><div class="token-line"><span class="token plain">    // 集群元数据类，保存集群所有元数据</span></div><div class="token-line"><span class="token plain">    val controllerContext = new ControllerContext</span></div><div class="token-line"><span class="token plain">    // Controller端通道管理器类，负责Controller向Broker发送请求</span></div><div class="token-line"><span class="token plain">    var controllerChannelManager = new ControllerChannelManager(controllerContext, config, time, metrics,</span></div><div class="token-line"><span class="token plain">      stateChangeLogger, threadNamePrefix)</span></div><div class="token-line"><span class="token plain">    // 线程调度器，当前唯一负责定期执行Leader重选举</span></div><div class="token-line"><span class="token plain">    private[controller] val kafkaScheduler = new KafkaScheduler(1)</span></div><div class="token-line"><span class="token plain">    // Controller事件管理器，负责管理事件处理线程</span></div><div class="token-line"><span class="token plain">    private[controller] val eventManager = new ControllerEventManager(config.brokerId, this, time,</span></div><div class="token-line"><span class="token plain">      controllerContext.stats.rateAndTimeMetrics)</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    // 副本状态机，负责副本状态转换</span></div><div class="token-line"><span class="token plain">    val replicaStateMachine: ReplicaStateMachine = new ZkReplicaStateMachine(config, stateChangeLogger, controllerContext, zkClient,</span></div><div class="token-line"><span class="token plain">      new ControllerBrokerRequestBatch(config, controllerChannelManager, eventManager, controllerContext, stateChangeLogger))</span></div><div class="token-line"><span class="token plain">    // 分区状态机，负责分区状态转换</span></div><div class="token-line"><span class="token plain">    val partitionStateMachine: PartitionStateMachine = new ZkPartitionStateMachine(config, stateChangeLogger, controllerContext, zkClient,</span></div><div class="token-line"><span class="token plain">      new ControllerBrokerRequestBatch(config, controllerChannelManager, eventManager, controllerContext, stateChangeLogger))</span></div><div class="token-line"><span class="token plain">    // 主题删除管理器，负责删除主题及日志</span></div><div class="token-line"><span class="token plain">    val topicDeletionManager = new TopicDeletionManager(config, controllerContext, replicaStateMachine,</span></div><div class="token-line"><span class="token plain">      partitionStateMachine, new ControllerDeletionClient(this, zkClient))</span></div><div class="token-line"><span class="token plain">    ......</span></div></pre></div><p>其中，有7个字段是重中之重。</p><ul><li><strong>controllerContext</strong>：集群元数据类，保存集群所有元数据。</li><li><strong>controllerChannelManager</strong>：Controller端通道管理器类，负责Controller向Broker发送请求。</li><li><strong>kafkaScheduler</strong>：线程调度器，当前唯一负责定期执行分区重平衡Leader选举。</li><li><strong>eventManager</strong>：Controller事件管理器，负责管理事件处理线程。</li><li><strong>replicaStateMachine</strong>：副本状态机，负责副本状态转换。</li><li><strong>partitionStateMachine</strong>：分区状态机，负责分区状态转换。</li><li><strong>topicDeletionManager</strong>：主题删除管理器，负责删除主题及日志。</li></ul><h3 id="各类zookeeper监听器"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心源码解读/04.controller模块/04#各类zookeeper监听器"><span class="icon icon-link"></span></a>各类ZooKeeper监听器</h3><p>我们今天开头学到的ControllerChangeHandler仅仅是其中的一种。实际上，该类定义了很多监听器，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Controller节点ZooKeeper监听器</span></div><div class="token-line"><span class="token plain">    private val controllerChangeHandler = new ControllerChangeHandler(eventManager)</span></div><div class="token-line"><span class="token plain">    // Broker数量ZooKeeper监听器</span></div><div class="token-line"><span class="token plain">    private val brokerChangeHandler = new BrokerChangeHandler(eventManager)</span></div><div class="token-line"><span class="token plain">    // Broker信息变更ZooKeeper监听器集合</span></div><div class="token-line"><span class="token plain">    private val brokerModificationsHandlers: mutable.Map[Int, BrokerModificationsHandler] = mutable.Map.empty</span></div><div class="token-line"><span class="token plain">    // 主题数量ZooKeeper监听器</span></div><div class="token-line"><span class="token plain">    private val topicChangeHandler = new TopicChangeHandler(eventManager)</span></div><div class="token-line"><span class="token plain">    // 主题删除ZooKeeper监听器</span></div><div class="token-line"><span class="token plain">    private val topicDeletionHandler = new TopicDeletionHandler(eventManager)</span></div><div class="token-line"><span class="token plain">    // 主题分区变更ZooKeeper监听器</span></div><div class="token-line"><span class="token plain">    private val partitionModificationsHandlers: mutable.Map[String, PartitionModificationsHandler] = mutable.Map.empty</span></div><div class="token-line"><span class="token plain">    // 主题分区重分配ZooKeeper监听器</span></div><div class="token-line"><span class="token plain">    private val partitionReassignmentHandler = new PartitionReassignmentHandler(eventManager)</span></div><div class="token-line"><span class="token plain">    // Preferred Leader选举ZooKeeper监听器</span></div><div class="token-line"><span class="token plain">    private val preferredReplicaElectionHandler = new PreferredReplicaElectionHandler(eventManager)</span></div><div class="token-line"><span class="token plain">    // ISR副本集合变更ZooKeeper监听器</span></div><div class="token-line"><span class="token plain">    private val isrChangeNotificationHandler = new IsrChangeNotificationHandler(eventManager)</span></div><div class="token-line"><span class="token plain">    // 日志路径变更ZooKeeper监听器</span></div><div class="token-line"><span class="token plain">    private val logDirEventNotificationHandler = new LogDirEventNotificationHandler(eventManager)</span></div></pre></div><p>我分别解释一下这些ZooKeeper监听器的作用：</p><ul><li><strong>controllerChangeHandler</strong>：前面说过，它是监听/controller节点变更的。这种变更包括节点创建、删除以及数据变更。</li><li><strong>brokerChangeHandler</strong>：监听Broker的数量变化。</li><li><strong>brokerModificationsHandlers</strong>：监听Broker的数据变更，比如Broker的配置信息发生的变化。</li><li><strong>topicChangeHandler</strong>：监控主题数量变更。</li><li><strong>topicDeletionHandler</strong>：监听主题删除节点/admin/delete_topics的子节点数量变更。</li><li><strong>partitionModificationsHandlers</strong>：监控主题分区数据变更的监听器，比如，新增加了副本、分区更换了Leader副本。</li><li><strong>partitionReassignmentHandler</strong>：监听分区副本重分配任务。一旦发现新提交的任务，就为目标分区执行副本重分配。</li><li><strong>preferredReplicaElectionHandler</strong>：监听Preferred Leader选举任务。一旦发现新提交的任务，就为目标主题执行Preferred Leader选举。</li><li><strong>isrChangeNotificationHandler</strong>：监听ISR副本集合变更。一旦被触发，就需要获取ISR发生变更的分区列表，然后更新Controller端对应的Leader和ISR缓存元数据。</li><li><strong>logDirEventNotificationHandler</strong>：监听日志路径变更。一旦被触发，需要获取受影响的Broker列表，然后处理这些Broker上失效的日志路径。</li></ul><p>我画了一张脑图，希望可以帮助你更高效地记住这些ZooKeeper监听器：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage8f318feed623165ab6e50b31614e67498c31.f6bf986c.jpg" alt=""/></p><h3 id="统计字段"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心源码解读/04.controller模块/04#统计字段"><span class="icon icon-link"></span></a>统计字段</h3><p>最后，我们来看统计字段。</p><p>这些统计字段大多用于计算统计指标。有的监控指标甚至是非常重要的Controller监控项，比如ActiveControllerCount指标。下面，我们来了解下KafkaController都定义了哪些统计字段。这些指标的含义一目了然，非常清晰，我用注释的方式给出每个字段的含义：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 当前Controller所在Broker Id</span></div><div class="token-line"><span class="token plain">    @volatile private var activeControllerId = -1</span></div><div class="token-line"><span class="token plain">    // 离线分区总数</span></div><div class="token-line"><span class="token plain">    @volatile private var offlinePartitionCount = 0</span></div><div class="token-line"><span class="token plain">    // 满足Preferred Leader选举条件的总分区数</span></div><div class="token-line"><span class="token plain">    @volatile private var preferredReplicaImbalanceCount = 0</span></div><div class="token-line"><span class="token plain">    // 总主题数</span></div><div class="token-line"><span class="token plain">    @volatile private var globalTopicCount = 0</span></div><div class="token-line"><span class="token plain">    // 总主题分区数</span></div><div class="token-line"><span class="token plain">    @volatile private var globalPartitionCount = 0</span></div><div class="token-line"><span class="token plain">    // 待删除主题数</span></div><div class="token-line"><span class="token plain">    @volatile private var topicsToDeleteCount = 0</span></div><div class="token-line"><span class="token plain">    //待删除副本数</span></div><div class="token-line"><span class="token plain">    @volatile private var replicasToDeleteCount = 0</span></div><div class="token-line"><span class="token plain">    // 暂时无法删除的主题数</span></div><div class="token-line"><span class="token plain">    @volatile private var ineligibleTopicsToDeleteCount = 0</span></div><div class="token-line"><span class="token plain">    // 暂时无法删除的副本数</span></div><div class="token-line"><span class="token plain">    @volatile private var ineligibleReplicasToDeleteCount = 0</span></div></pre></div><p>好了，KafkaController类的定义我们就全部介绍完了。再次强调下，因为KafkaController类的代码很多，我强烈建议你熟练掌握这些字段的含义，因为后面的所有方法都是围绕着这些字段进行操作的。</p><p>接下来，我以Controller的选举流程为例，引出KafkaController的一些方法的实现原理。不过，在此之前，我们要学习监听Controller变更的ZooKeeper监听器：ControllerChangeHandler的源码。</p><h2 id="controllerchangehandler监听器"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心源码解读/04.controller模块/04#controllerchangehandler监听器"><span class="icon icon-link"></span></a>ControllerChangeHandler监听器</h2><p>就像我前面说到的，KafkaController定义了十几种ZooKeeper监听器。和Controller相关的监听器是ControllerChangeHandler，用于监听Controller的变更，定义代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class ControllerChangeHandler(eventManager: ControllerEventManager) extends ZNodeChangeHandler {</span></div><div class="token-line"><span class="token plain">      // ZooKeeper中Controller节点路径，即/controller</span></div><div class="token-line"><span class="token plain">      override val path: String = ControllerZNode.path</span></div><div class="token-line"><span class="token plain">      // 监听/controller节点创建事件</span></div><div class="token-line"><span class="token plain">      override def handleCreation(): Unit = eventManager.put(ControllerChange)</span></div><div class="token-line"><span class="token plain">      // 监听/controller节点被删除事件</span></div><div class="token-line"><span class="token plain">      override def handleDeletion(): Unit = eventManager.put(Reelect)</span></div><div class="token-line"><span class="token plain">      // 监听/controller节点数据变更事件</span></div><div class="token-line"><span class="token plain">      override def handleDataChange(): Unit = eventManager.put(ControllerChange)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>该监听器接收ControllerEventManager实例，实现了ZNodeChangeHandler接口的三个方法：<strong>handleCreation</strong>、<strong>handleDeletion</strong>和<strong>handleDataChange</strong>。该监听器下的path变量，实际上就是/controller字符串，表示它监听ZooKeeper的这个节点。</p><p>3个handle方法都用于监听/controller节点的变更，但实现细节上稍有不同。</p><p>handleCreation和handleDataChange的处理方式是向事件队列写入ControllerChange事件；handleDeletion的处理方式是向事件队列写入Reelect事件。</p><p>Deletion表明ZooKeeper中/controller节点不存在了，即Kafka集群中的Controller暂时空缺了。因为它和Creation和DataChange是不同的状态，需要区别对待，因此，Reelect事件做的事情要比ControllerChange的多：处理ControllerChange事件，只需要当前Broker执行“卸任Controller”的逻辑即可，而Reelect事件是重选举，除了Broker执行卸任逻辑之外，还要求Broker参与到重选举中来。</p><p>由于KafkaController的process方法代码非常长，因此，我节选了刚刚提到的那两个事件的处理代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// process方法(部分)</span></div><div class="token-line"><span class="token plain">    override def process(event: ControllerEvent): Unit = {</span></div><div class="token-line"><span class="token plain">        try {</span></div><div class="token-line"><span class="token plain">          event match {</span></div><div class="token-line"><span class="token plain">           ......</span></div><div class="token-line"><span class="token plain">           // ControllerChange事件</span></div><div class="token-line"><span class="token plain">           case ControllerChange =&gt;</span></div><div class="token-line"><span class="token plain">              processControllerChange()</span></div><div class="token-line"><span class="token plain">           // Reelect事件</span></div><div class="token-line"><span class="token plain">           case Reelect =&gt;</span></div><div class="token-line"><span class="token plain">              processReelect()</span></div><div class="token-line"><span class="token plain">            ......</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        ......</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // 如果是ControllerChange事件，仅执行卸任逻辑即可</span></div><div class="token-line"><span class="token plain">    private def processControllerChange(): Unit = {</span></div><div class="token-line"><span class="token plain">        maybeResign()</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    // 如果是Reelect事件，还需要执行elect方法参与新一轮的选举</span></div><div class="token-line"><span class="token plain">    private def processReelect(): Unit = {</span></div><div class="token-line"><span class="token plain">        maybeResign()</span></div><div class="token-line"><span class="token plain">        elect()</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，虽然代码非常长，但整体结构却工整清晰，全部都是基于模式匹配的事件处理。process方法会根据给定的Controller事件类型，调用对应的process***方法处理该事件。这里只列举了ZooKeeper端/controller节点监听器监听的两类事件，以及对应的处理方法。</p><p>对于ControllerChange事件而言，处理方式是调用maybeResign去执行Controller的卸任逻辑。如果是Reelect事件，除了执行卸任逻辑之外，还要额外执行elect方法进行新一轮的Controller选举。</p><h2 id="controller选举流程"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心源码解读/04.controller模块/04#controller选举流程"><span class="icon icon-link"></span></a>Controller选举流程</h2><p>说完了ControllerChangeHandler源码，我们来看下Controller的选举。所谓的Controller选举，是指Kafka选择集群中一台Broker行使Controller职责。整个选举过程分为两个步骤：触发选举和开始选举。</p><h3 id="触发选举"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心源码解读/04.controller模块/04#触发选举"><span class="icon icon-link"></span></a>触发选举</h3><p>我先用一张图展示下可能触发Controller选举的三个场景。</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimagea898a8cbc562518f93f9befc6bd7a87d5b98.1f9f454a.jpg" alt=""/></p><p>这三个场景是：</p><ol><li>集群从零启动时；</li><li>Broker侦测/controller节点消失时；</li><li>Broker侦测到/controller节点数据发生变更时。</li></ol><p>这三个场景殊途同归，最后都要执行选举Controller的动作。我来一一解释下这三个场景，然后再介绍选举Controller的具体操作。</p><h4 id="场景一集群从零启动"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心源码解读/04.controller模块/04#场景一集群从零启动"><span class="icon icon-link"></span></a>场景一：集群从零启动</h4><p>集群首次启动时，Controller尚未被选举出来。于是，Broker启动后，首先将Startup这个ControllerEvent写入到事件队列中，然后启动对应的事件处理线程和ControllerChangeHandler ZooKeeper监听器，最后依赖事件处理线程进行Controller的选举。</p><p>在源码中，KafkaController类的startup方法就是做这些事情的。当Broker启动时，它会调用这个方法启动ControllerEventThread线程。值得注意的是，<strong>每个Broker都需要做这些事情，不是说只有Controller所在的Broker才需要执行这些逻辑</strong>。</p><p>startup方法的主体代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">def startup() = {</span></div><div class="token-line"><span class="token plain">      // 第1步：注册ZooKeeper状态变更监听器，它是用于监听Zookeeper会话过期的</span></div><div class="token-line"><span class="token plain">      zkClient.registerStateChangeHandler(new StateChangeHandler {</span></div><div class="token-line"><span class="token plain">        override val name: String = StateChangeHandlers.ControllerHandler</span></div><div class="token-line"><span class="token plain">        override def afterInitializingSession(): Unit = {</span></div><div class="token-line"><span class="token plain">          eventManager.put(RegisterBrokerAndReelect)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        override def beforeInitializingSession(): Unit = {</span></div><div class="token-line"><span class="token plain">          val queuedEvent = eventManager.clearAndPut(Expire)</span></div><div class="token-line"><span class="token plain">          queuedEvent.awaitProcessing()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      })</span></div><div class="token-line"><span class="token plain">      // 第2步：写入Startup事件到事件队列</span></div><div class="token-line"><span class="token plain">      eventManager.put(Startup)</span></div><div class="token-line"><span class="token plain">      // 第3步：启动ControllerEventThread线程，开始处理事件队列中的ControllerEvent</span></div><div class="token-line"><span class="token plain">      eventManager.start()</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>首先，startup方法会注册ZooKeeper状态变更监听器，用于监听Broker与ZooKeeper之间的会话是否过期。接着，写入Startup事件到事件队列，然后启动ControllerEventThread线程，开始处理事件队列中的Startup事件。</p><p>接下来，我们来学习下KafkaController的process方法处理Startup事件的方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// KafkaController的process方法，</span></div><div class="token-line"><span class="token plain">    override def process(event: ControllerEvent): Unit = {</span></div><div class="token-line"><span class="token plain">        try {</span></div><div class="token-line"><span class="token plain">          event match {</span></div><div class="token-line"><span class="token plain">           ......</span></div><div class="token-line"><span class="token plain">           case Startup =&gt;</span></div><div class="token-line"><span class="token plain">              processStartup() // 处理Startup事件</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        ......</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    private def processStartup(): Unit = {</span></div><div class="token-line"><span class="token plain">       // 注册ControllerChangeHandler ZooKeeper监听器</span></div><div class="token-line"><span class="token plain">       zkClient.registerZNodeChangeHandlerAndCheckExistence(</span></div><div class="token-line"><span class="token plain">        controllerChangeHandler)</span></div><div class="token-line"><span class="token plain">       // 执行Controller选举</span></div><div class="token-line"><span class="token plain">       elect()</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>从这段代码可知，process方法调用processStartup方法去处理Startup事件。而processStartup方法又会调用zkClient的registerZNodeChangeHandlerAndCheckExistence方法注册ControllerChangeHandler监听器。</p><p>值得注意的是，虽然前面的三个场景是并列的关系，但实际上，后面的两个场景必须要等场景一的这一步成功执行之后，才能被触发。</p><p>这三种场景都要选举Controller，因此，我们最后统一学习elect方法的代码实现。</p><p>总体来说，集群启动时，Broker通过向事件队列“塞入”Startup事件的方式，来触发Controller的竞选。</p><h4 id="场景二controller节点消失"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心源码解读/04.controller模块/04#场景二controller节点消失"><span class="icon icon-link"></span></a>场景二：/controller节点消失</h4><p>Broker检测到/controller节点消失时，就意味着，此时整个集群中没有Controller。因此，所有检测到/controller节点消失的Broker，都会立即调用elect方法执行竞选逻辑。</p><p>你可能会问：“Broker是怎么侦测到ZooKeeper上的这一变化的呢？”实际上，这是ZooKeeper监听器提供的功能，换句话说，这是Apache ZooKeeper自己实现的功能，所以我们才说，Kafka依赖ZooKeeper完成Controller的选举。</p><p>讲到这里，我说点题外话，社区最近正在酝酿彻底移除ZooKeeper依赖。具体到Controller端的变化，就是在Kafka内部实现一个类似于Raft的共识算法来选举Controller。我会在后面的特别放送里详细讲一下社区移除ZooKeeper的全盘计划。</p><h4 id="场景三controller节点数据变更"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心源码解读/04.controller模块/04#场景三controller节点数据变更"><span class="icon icon-link"></span></a>场景三：/controller节点数据变更</h4><p>Broker检测到/controller节点数据发生变化，通常表明，Controller“易主”了，这就分为两种情况：</p><ul><li>如果Broker之前是Controller，那么该Broker需要首先执行卸任操作，然后再尝试竞选；</li><li>如果Broker之前不是Controller，那么，该Broker直接去竞选新Controller。</li></ul><p>具体到代码层面，maybeResign方法形象地说明了这两种情况。你要注意方法中的maybe字样，这表明，Broker可能需要执行卸任操作，也可能不需要。Kafka源码非常喜欢用maybe***来命名方法名，以表示那些在特定条件下才需要执行的逻辑。以下是maybeResign的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private def maybeResign(): Unit = {</span></div><div class="token-line"><span class="token plain">      // 非常关键的一步！这是判断是否需要执行卸任逻辑的重要依据！</span></div><div class="token-line"><span class="token plain">      // 判断该Broker之前是否是Controller</span></div><div class="token-line"><span class="token plain">      val wasActiveBeforeChange = isActive</span></div><div class="token-line"><span class="token plain">      // 注册ControllerChangeHandler监听器  </span></div><div class="token-line"><span class="token plain">      zkClient.registerZNodeChangeHandlerAndCheckExistence(</span></div><div class="token-line"><span class="token plain">        controllerChangeHandler)</span></div><div class="token-line"><span class="token plain">      // 获取当前集群Controller所在的Broker Id，如果没有Controller则返回-1</span></div><div class="token-line"><span class="token plain">      activeControllerId = zkClient.getControllerId.getOrElse(-1)</span></div><div class="token-line"><span class="token plain">      // 如果该Broker之前是Controller但现在不是了</span></div><div class="token-line"><span class="token plain">      if (wasActiveBeforeChange &amp;&amp; !isActive) {</span></div><div class="token-line"><span class="token plain">        onControllerResignation() // 执行卸任逻辑</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>代码的第一行非常关键，它是决定是否需要执行卸任的重要依据。毕竟，如果Broker之前不是Controller，那何来“卸任”一说呢？之后代码要注册ControllerChangeHandler监听器，获取当前集群Controller所在的Broker ID，如果没有Controller，则返回-1。有了这些数据之后，maybeResign方法需要判断该Broker是否之前是Controller但现在不是了。如果是这种情况的话，则调用onControllerResignation方法执行Controller卸任逻辑。</p><p>说到“卸任”，你可能会问：“卸任逻辑是由哪个方法执行的呢？”实际上，这是由onControllerResignation方法执行的，它主要是用于清空各种数据结构的值、取消ZooKeeper监听器、关闭各种状态机以及管理器，等等。我用注释的方式给出它的逻辑实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private def onControllerResignation(): Unit = {</span></div><div class="token-line"><span class="token plain">      debug(&quot;Resigning&quot;)</span></div><div class="token-line"><span class="token plain">      // 取消ZooKeeper监听器的注册</span></div><div class="token-line"><span class="token plain">      zkClient.unregisterZNodeChildChangeHandler(</span></div><div class="token-line"><span class="token plain">        isrChangeNotificationHandler.path)</span></div><div class="token-line"><span class="token plain">      zkClient.unregisterZNodeChangeHandler(</span></div><div class="token-line"><span class="token plain">        partitionReassignmentHandler.path)</span></div><div class="token-line"><span class="token plain">      zkClient.unregisterZNodeChangeHandler(</span></div><div class="token-line"><span class="token plain">        preferredReplicaElectionHandler.path)</span></div><div class="token-line"><span class="token plain">      zkClient.unregisterZNodeChildChangeHandler(</span></div><div class="token-line"><span class="token plain">        logDirEventNotificationHandler.path)</span></div><div class="token-line"><span class="token plain">      unregisterBrokerModificationsHandler(</span></div><div class="token-line"><span class="token plain">        brokerModificationsHandlers.keySet)</span></div><div class="token-line"><span class="token plain">      // 关闭Kafka线程调度器，其实就是取消定期的Leader重选举</span></div><div class="token-line"><span class="token plain">      kafkaScheduler.shutdown()</span></div><div class="token-line"><span class="token plain">      // 将统计字段全部清0</span></div><div class="token-line"><span class="token plain">      offlinePartitionCount = 0</span></div><div class="token-line"><span class="token plain">      preferredReplicaImbalanceCount = 0</span></div><div class="token-line"><span class="token plain">      globalTopicCount = 0</span></div><div class="token-line"><span class="token plain">      globalPartitionCount = 0</span></div><div class="token-line"><span class="token plain">      topicsToDeleteCount = 0</span></div><div class="token-line"><span class="token plain">      replicasToDeleteCount = 0</span></div><div class="token-line"><span class="token plain">      ineligibleTopicsToDeleteCount = 0</span></div><div class="token-line"><span class="token plain">      ineligibleReplicasToDeleteCount = 0</span></div><div class="token-line"><span class="token plain">      // 关闭Token过期检查调度器</span></div><div class="token-line"><span class="token plain">      if (tokenCleanScheduler.isStarted)</span></div><div class="token-line"><span class="token plain">        tokenCleanScheduler.shutdown()</span></div><div class="token-line"><span class="token plain">      // 取消分区重分配监听器的注册</span></div><div class="token-line"><span class="token plain">      unregisterPartitionReassignmentIsrChangeHandlers()</span></div><div class="token-line"><span class="token plain">      // 关闭分区状态机</span></div><div class="token-line"><span class="token plain">      partitionStateMachine.shutdown()</span></div><div class="token-line"><span class="token plain">      // 取消主题变更监听器的注册</span></div><div class="token-line"><span class="token plain">      zkClient.unregisterZNodeChildChangeHandler(topicChangeHandler.path)</span></div><div class="token-line"><span class="token plain">      // 取消分区变更监听器的注册</span></div><div class="token-line"><span class="token plain">      unregisterPartitionModificationsHandlers(</span></div><div class="token-line"><span class="token plain">        partitionModificationsHandlers.keys.toSeq)</span></div><div class="token-line"><span class="token plain">      // 取消主题删除监听器的注册</span></div><div class="token-line"><span class="token plain">      zkClient.unregisterZNodeChildChangeHandler(</span></div><div class="token-line"><span class="token plain">        topicDeletionHandler.path)</span></div><div class="token-line"><span class="token plain">      // 关闭副本状态机</span></div><div class="token-line"><span class="token plain">      replicaStateMachine.shutdown()</span></div><div class="token-line"><span class="token plain">      // 取消Broker变更监听器的注册</span></div><div class="token-line"><span class="token plain">      zkClient.unregisterZNodeChildChangeHandler(brokerChangeHandler.path)</span></div><div class="token-line"><span class="token plain">      // 关闭Controller通道管理器</span></div><div class="token-line"><span class="token plain">      controllerChannelManager.shutdown()</span></div><div class="token-line"><span class="token plain">      // 清空集群元数据</span></div><div class="token-line"><span class="token plain">      controllerContext.resetContext()</span></div><div class="token-line"><span class="token plain">      info(&quot;Resigned&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="选举controller"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心源码解读/04.controller模块/04#选举controller"><span class="icon icon-link"></span></a>选举Controller</h3><p>讲完了触发场景，接下来，我们就要学习Controller选举的源码了。前面说过了，这三种选举场景最后都会调用elect方法来执行选举逻辑。我们来看下它的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private def elect(): Unit = {</span></div><div class="token-line"><span class="token plain">        // 第1步：获取当前Controller所在Broker的序号，如果Controller不存在，显式标记为-1</span></div><div class="token-line"><span class="token plain">        activeControllerId = zkClient.getControllerId.getOrElse(-1)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 第2步：如果当前Controller已经选出来了，直接返回即可</span></div><div class="token-line"><span class="token plain">        if (activeControllerId != -1) {</span></div><div class="token-line"><span class="token plain">          debug(s&quot;Broker $activeControllerId has been elected as the controller, so stopping the election process.&quot;)</span></div><div class="token-line"><span class="token plain">          return</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        try {</span></div><div class="token-line"><span class="token plain">          // 第3步：注册Controller相关信息</span></div><div class="token-line"><span class="token plain">          // 主要是创建/controller节点</span></div><div class="token-line"><span class="token plain">          val (epoch, epochZkVersion) = zkClient.registerControllerAndIncrementControllerEpoch(config.brokerId)</span></div><div class="token-line"><span class="token plain">          controllerContext.epoch = epoch</span></div><div class="token-line"><span class="token plain">          controllerContext.epochZkVersion = epochZkVersion</span></div><div class="token-line"><span class="token plain">          activeControllerId = config.brokerId</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          info(s&quot;${config.brokerId} successfully elected as the controller. Epoch incremented to ${controllerContext.epoch} &quot; +</span></div><div class="token-line"><span class="token plain">            s&quot;and epoch zk version is now ${controllerContext.epochZkVersion}&quot;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          // 第4步：执行当选Controller的后续逻辑</span></div><div class="token-line"><span class="token plain">          onControllerFailover()</span></div><div class="token-line"><span class="token plain">        } catch {</span></div><div class="token-line"><span class="token plain">          case e: ControllerMovedException =&gt;</span></div><div class="token-line"><span class="token plain">            maybeResign()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            if (activeControllerId != -1)</span></div><div class="token-line"><span class="token plain">              debug(s&quot;Broker $activeControllerId was elected as controller instead of broker ${config.brokerId}&quot;, e)</span></div><div class="token-line"><span class="token plain">            else</span></div><div class="token-line"><span class="token plain">              warn(&quot;A controller has been elected but just resigned, this will result in another round of election&quot;, e)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          case t: Throwable =&gt;</span></div><div class="token-line"><span class="token plain">            error(s&quot;Error while electing or becoming controller on broker ${config.brokerId}. &quot; +</span></div><div class="token-line"><span class="token plain">              s&quot;Trigger controller movement immediately&quot;, t)</span></div><div class="token-line"><span class="token plain">            triggerControllerMove()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div></pre></div><p>为了帮助你更好地理解这个方法，我再画一张图来进行说明：</p><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimage231b2331395774956a61f37836c46d65d01b.628c9345.jpg" alt=""/></p><p>该方法首先检查Controller是否已经选出来了。要知道，集群中的所有Broker都要执行这些逻辑，因此，非常有可能出现某些Broker在执行elect方法时，Controller已经被选出来的情况。如果Controller已经选出来了，那么，自然也就不用再做什么了。相反地，如果Controller尚未被选举出来，那么，代码会尝试创建/controller节点去抢注Controller。</p><p>一旦抢注成功，就调用onControllerFailover方法，执行选举成功后的动作。这些动作包括注册各类ZooKeeper监听器、删除日志路径变更和ISR副本变更通知事件、启动Controller通道管理器，以及启动副本状态机和分区状态机。</p><p>如果抢注失败了，代码会抛出ControllerMovedException异常。这通常表明Controller已经被其他Broker抢先占据了，那么，此时代码调用maybeResign方法去执行卸任逻辑。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心源码解读/04.controller模块/04#总结"><span class="icon icon-link"></span></a>总结</h2><p>今天，我们梳理了Controller选举的全过程，包括Controller如何借助ZooKeeper监听器实现监听Controller节点，以及Controller的选举触发场景和完整流程。我们来回顾一下这节课的重点。</p><ul><li>Controller依赖ZooKeeper实现Controller选举，主要是借助于/controller临时节点和ZooKeeper的监听器机制。</li><li>Controller触发场景有3种：集群启动时；/controller节点被删除时；/controller节点数据变更时。</li><li>源码最终调用elect方法实现Controller选举。</li></ul><p><img src="/blog-backend/static/httpsstatic001geekbangorgresourceimagee274e28c134e4fd11ff8ed87933aee88d374.28986125.jpg" alt=""/></p><p>下节课，我将带你学习Controller的其他重要功能，包括它如何管理Broker和副本等。你千万不要错过。</p><h2 id="课后讨论"><a aria-hidden="true" tabindex="-1" href="/blog-backend/kafka核心源码解读/04.controller模块/04#课后讨论"><span class="icon icon-link"></span></a>课后讨论</h2><p>在这节课刚开始的时候，我提到，删除/controller会触发Controller选举，之后会同步集群元数据信息。那么，你知道源码是在哪里更新的元数据请求吗？</p><p>欢迎你在留言区畅所欲言，跟我交流讨论，也欢迎你把今天的内容分享给你的朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/kafka核心源码解读/04.Controller模块/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:15:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-backend/umi.e14e5a14.js"></script>
  </body>
</html>
